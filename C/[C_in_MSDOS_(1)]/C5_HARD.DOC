


        Linguaggio C per MS DOS - F. Bernardotti - 1987 Opus Free Soft






















                            ACCENNI HARDWARE 8088/86
                                        E
                                   INTERRUPTS     


































                                       126





        Linguaggio C per MS DOS - F. Bernardotti - 1987 Opus Free Soft





                    Accenni all' hardware del sistema 8088/86


        Alcune  persone si domanderanno il perche' a questo punto compaia 
        un capitolo  dedicato all'hardware.
        I  linguaggi come il basic sono stati fatti  per le  persone  che 
        non   hanno   nessuna   intenzione   di   interessarsi   a   come 
        effettivamente il sistema gestisca le sue risorse.
        Nel  contesto di un discorso di programmazione a  basso  livello, 
        quale  quella  eseguita  mediante lo sfruttamento  delle  risorse 
        hardware, la conoscenza di quest'ultimo e' indispensabile.
        Ora   chiaramente  saremo  distanti  dal  fare  un  trattato   di 
        progettazione  di  un sistema a microprocessore ma  perlomeno  un 
        infarinatura,  nel caso che gia' non la si abbia',  e' necessaria 
        almeno  per far comprendere concetti normalmente utilizzati nella 
        programmazione a questo livello.



                             Architettura di sistema



        Escludendo per ora la trattazione relativa alle varie periferiche 
        e  alla  programmazione di queste facciamo un  discorso  relativo 
        alla struttura essenziale di un sistema.
        Fondamentalmente un computer e' costituito da sei blocchi.


        -----------------------------------------------------------------
                                ADDRESS    BUS
        ------+   +------------------+   +-------------------+   +-------
              :   :                  :   :                   :   :
           +---------+            +---------+             +---------+
           :         :            :         :             :         : 
           :         +------------+         +-------------+         :
           :  CPU    :  CONTROL   : MEMORY  :     BUS     :   I/O   :
           :         +------------+         +-------------+         :
           :         :            :         :             :         :
           +---------+            +---------+             +---------+
              :   :                  :   :                   :   :
        ------+   +------------------+   +-------------------+   +-------
                                   DATA   BUS
        -----------------------------------------------------------------

        La  CPU  e' in pratica il cuore del sistema in  quanto  tutte  le 
        operazioni logiche aritmetiche vengono svolte al suo interno.
        La  CPU 8088/96 possiede un set di registri a 16 bit che hanno  i 
        seguenti scopi.
          




                                       127





        Linguaggio C per MS DOS - F. Bernardotti - 1987 Opus Free Soft





        Come  gia' accennato precedentemente esistono  4 registri ad  uso 
        generale e precisamente AX, BX, CX e DX.
        Oltre  a  questi  ritroviamo  due registri indici  di  stringa  e 
        precisamente SI (indice sorgente) e DI (indice destinazione)  che 
        vengono utilizzati per puntare alla stringa di dati in memoria.
        Il  registro puntatore di stack SP e' utilizzato per implementare 
        una catasta hardware.
        Per integrare quest'ultimo puo' essere utilizzato il registro  BP 
        (base pointer).
        Il registro IP (istruction pointer) serve al processore per poter 
        puntare all'istruzione successiva che deve essere eseguita.
        Un breve discorso lo merita lo stack o pila.
        L'evoluzione   dei  microprocessori  ha  portato  negli  anni   a 
        modificare il concetto, a livello fisico, di stack.
        Nei  primi processori l'implementazione dello stack era a livello 
        hardware all'interno del processore stesso.
        Questo  infatti era una pila di registri organizzati con  accesso 
        seriale  e cioe' l'acceso ai dati era possibile solo  con  quelli 
        "superficiali".
        Questo  modo di utilizzare lo stack dava seri problemi in  quanto 
        l'inserimento  di  un  dato su questo faceva si che  quelli  gia' 
        presenti shiftassero verso il fondo.
        Nel  momento in cui il programmatore non teneva un conto  preciso 
        del  numero di dati inseriti,  capitava che quelli in fondo  allo 
        stack si perdevano in quanto "uscivano" da questo.
        Le seguenti generazioni di processori adottarono uno stratagemma, 
        spesso anche questo inefficace,  per far si che il  programmatore 
        potesse testare lo stato dello stack.
        La soluzione adottata di fatti contemplava la presenza di un flag 
        (bandierina) che segnalava lo stato dello stack.
        Come dicevo anche questa soluzione spesso risultava inefficace in 
        quanto  era sempre compito del programmatore testare lo stato del 
        flag di stack.
        La  soluzione  ideale,   quella  adottata  anche  dai  processori 
        8088/86,  fu' quella di tenere lo stack esterno in memoria e  non 
        piu' all'interno del processore.
        In  questo  modo  il  programmatore mediante  l'uso  di  uno  dei 
        registri  di  segmento  e precisamente SS  (stack  segment)  puo' 
        crearsi  in  una certa area di memoria lo stack adatto  alle  sue 
        esigenze e al limite, mediante apposite opzioni in fase di link o 
        mediante  programmi  particolari,  modificare  le  dimensioni  di 
        questo.
        Il registro che effettivamente indirizza lo stack e' SP.
        SP viene inizializzato a puntare alla prima locazione dello stack 
        e   ad   ogni   operazione  di  caricamento   in   questo   viene 
        automaticamente incrementato a puntare alla locazione successiva.
        In corrispondenza di un istruzione di prelevamento dallo stack il 
        registro  SP viene decrementato e quindi viene letta la la  cella 
        indirizzata.
        In altre parole,  come detto prima, vale la regola "primo entrato 
        ultimo uscito".



                                       128





        Linguaggio C per MS DOS - F. Bernardotti - 1987 Opus Free Soft





        Parlando  di variabili locali abbiamo gia' portato un esempio  di 
        utilizzo dello stack.
        La  manipolazione dei dati inseriti sullo stack e' una delle cose 
        fondamentali  nel  momento  in cui si agisce e  si  modificano  i 
        vettori di interruzione.
        Sull'argomento diremo tutto a suo tempo.
        L'assembler utilzza lo stack anche per memorizzare gli  indirizzi 
        presenti  nei registri di segmento e nel registro IP nel  momento 
        in cui viene eseguita una call con ritorno.
        In  altre parole e' chiaro che se il programma richiede un  salto 
        il  registro  puntatore di istruzione deve essere aggiornato  con 
        quello relativo alla destinazione.
        Se il processore non salvasse da qualche parte il vecchio  valore 
        del  registro  IP  non  si potrebbe verificare  un  ritorno  dopo 
        l'esecuzione della chiamata.
        A   questo   punto  possiamo  parlare  anche  del   concetto   di 
        segmentazione  argomento,  probabilmente,  nuovo  per  tutti  gli 
        utenti di sistemi a 8 bit.
        All'interno   del   processore  8088/86  ritroviamo  4   registri 
        incaricati  di mantenere memorizzati i vari segmenti relativi  al 
        codice, ai dati e allo stack.
        Per capire effetivamente cosa si intende per segmento vediamo  di 
        trattare il tutto a livello hardware.
        Alcuni   dei  blocchi  che  comparivano  sulla   schematizzazione 
        simbolica del sistema erano costituiti dai vari BUS.
        Le  operazioni  svolte dal processore sono guidate da  istruzioni 
        allocate in memoria.
        Questo significa che gran parte del lavoro svolto dal  processore 
        e'  appunto  l'inserimento  e il prelevamento di dati  per  e  da 
        questa.
        Lasciamo  da parte un attimo il sistema 8088/86 e  generalizziamo 
        il  concetto di indirizzamento di memoria su un sistema  astratto 
        dotato di un banco di memoria di 64 Kbytes.
        Il  processore  per le funzioni di trasferimento dalla e  per  la 
        momoria si supporta del DATA BUS.
        Questo  in  pratica e' costituito da una serie di conduttori  sui 
        quali i dati viaggiano in parallelo.
        L'ADDRESS  BUS e' concettualmente simile al DATA BUS solo che  su 
        questo  scorrono  i segnali relativi agli  indirizzi  interessati 
        nelle operazioni di trasferimento.
        Nel  nostro  sistema astratto l'ADDRESS BUS e' costituito  da  16 
        bit.
        Da questo fare il calcolo della memoria indirizzabile e' una cosa 
        banale.
        In  pratica  basta elevare a potenza la base numerica,  cioe'  il 
        numero  dei  valori che potra' assumere ogni  segnale  ,  con  il 
        numero dei segnali presenti.
        La  base  numerica e' in questo caso 2 (binaria) in  quanto  ogni 
        singolo segnale potra' assumere i valori di 0 o di 1.





                                       129





        Linguaggio C per MS DOS - F. Bernardotti - 1987 Opus Free Soft





        Il  numero  dei segnali presenti e 16 (il numero  dei  conduttori 
        del'ADDRESS BUS) e quindi

                                 2 ^ 16 =  65536

        e cioe' 64 Kbytes.
        Ora  il tutto sarebbe molto semplice se si disponesse di un  solo 
        chip di memoria di queste dimensioni.
        In  questo caso,  supponendo che il processore voglia leggere  il 
        contenuto  della  cella 2000,  le operazioni svolte sarebbero  le 
        seguenti.

        1)   Immisione   sul  ADDRESS  BUS  del   valore   corrispondente  
             all'indirizzo 2000 (0000011111010000).
        2)   La  memoria che riceve questo segnale dovrebbe  prendere  il 
             contenuto  della  cella relativa e immetterlo sul  DATA  BUS 
             dove il processore provvederebbe a leggerla.

        Purtroppo a questo punto sorge un problema.
        Come  fa' la memoria a sapere se l'indirizzo presente sul ADDRESS 
        BUS  e'relativo a un operazione di inserimento o di  prelevamento 
        dalla cella indicata ?
        A segnalare questo ci pensa il processore sfruttando un altro dei 
        blocchi  segnalati  nello  schema  iniziale  e  precisamente   il 
        CONTROLL BUS.
        Mediante  questo  il  processore  prima  di  inviare  l'indirizzo 
        emette  un segnale di R/W (read/write) che indica alla memoria la 
        natura dell'operazione da svolgere.
        A questo punto,  quando tutto sembrava spiegato,  sorge un  altro 
        problema.
        Noi  abbiamo schematizzato la memoria come un unico blocco di  64 
        Kbytes  ma  in effetti questa e' composta da un certo  numero  di 
        chip.
        Come sono montati questi chip sulla scheda ?
        Pensare  di  inserire  un  ADDRESS  BUS  per  ogni  chip  sarebbe 
        assurdo.
        La  soluzione  optata e' stata quella di montare tutti i  chip  i 
        parallelo sullo stesso ADDRESS BUS.
        Supponiamo per esempio che il banco da 64 Kbyte sia composto da 4 
        chip da 16 Kbyte.
        Il  numero dei chip in cui e' suddivisa la memoria totale non  ha 
        importanza  in quanto il concetto e' valido indipendentemente dal 
        numero di questi.
        Opto per una soluzione di questo tipo solo per comodita'  grafica 
        relativa all'esempio.
        Dicevamo  che  il  processore  dopo aver  segnalato  il  tipo  di 
        operazione   da  compiere  sulla  memoria  inserisce  l'indirizzo 
        relativo alla cella interessata sull'ADDRESS BUS.
        Essendo  tutti  i  chip in parallelo tra di loro come  si  fa'  a 
        indicare a quale chip e' relativo l'indirizzo ?




                                       130





        Linguaggio C per MS DOS - F. Bernardotti - 1987 Opus Free Soft





              +-------+
        16----:DECODER:----------------------------------------+
        15----:       :-------------------------+              :
              +-------+----------+              :              : 
                  : CS 1         : CS 2         : CS 3         : CS 4
        14----+---o---+------+---o---+------+---o---+------+---o---+
        13----:       :------:       :------:       :------:       :
        12----:       :------:       :------:       :------:       :
        11----:       :------:       :------:       :------:       :
        10----:   C   :------:   C   :------:   C   :------:   C   :
        9 ----:   H   :------:   H   :------:   H   :------:   H   :
        8 ----:   I   :------:   I   :------:   I   :------:   I   :
        7 ----:   P   :------:   P   :------:   P   :------:   P   :
        6 ----:       :------:       :------:       :------:       :
        5 ----:   1   :------:   2   :------:   3   :------:   4   :
        4 ----:       :------:       :------:       :------:       : 
        3 ----:       :------:       :------:       :------:       :
        2 ----:       :------:       :------:       :------:       :
        1 ----+-------+------+-------+------+-------+------+-------+
                  :              :              :              :
        R/W-------+--------------+--------------+--------------+     


        Considerando  un  esempio  di  questo genere  ci  accorgiamo  che 
        effettivamente  per indirizzare i 16 Kbyte di ogni chip non  sono 
        necessari tutti e 16 i bit dell'ADDRESS BUS in quanto ne  bastano 
        soltanto 14.
        Infatti facendo il calcolo

                                 2 ^ 14 = 16384

        e cioe' 16 Kbytes.
        Per  poter  disporre di tutti i 64 Kbytes presenti sui 4  chip  a 
        questo punto ci serve soltanto un metodo per poter mandare uno di 
        questi 16384 indirizzi possibili su uno di questi.
        Gli  ultimi  due bit dell'ADDRESS BUS non  sono  inutilizzati  in 
        quanto vengono inviati su un decoder.
        Non  voglio  trattare  a fondo il concetto di decoder  in  quanto 
        farlo e' inutile ai nostri fini.
        Un  decoder  e' un circuito che riceve in ingresso  una  codifica 
        binaria  e  che  segnala quale numero  sta'  ricevendo  attivando 
        un'uscita diversa per ogni numero.
        In  questo  caso  il  decoder ha 2 ingressi  e  quindi  i  numeri 
        ricevibili in formato binario sono esattamente 4 dati dalle varie 
        combinazioni che possono assumere i segnali in ingresso.

                    Ingresso    1    2    : Uscita
                             -------------+-------
                                0    0    :   0
                                0    1    :   1
                                1    0    :   2
                                1    1    :   3


                                       131





        Linguaggio C per MS DOS - F. Bernardotti - 1987 Opus Free Soft





        Da  questo  e' facile capire che mediante i 2 bit non  utilizzati 
        dell' ADDRESS BUS e' possibile attivare uno dei 4 chip.
        Infatti  ogni  chip possiede un pin (piedino)  chiamato  di  CHIP 
        SELECT.
        Supponiamo  ora  di  voler  indirizzare  la  cella  16383  ovvero 
        l'ultima   del  primo  chip  (considerate  sempre  che  si  parte 
        dall'indirizzo 0 relativo alla prima locazione).
        L'indirizzo  in binario immesso dal processore sull' ADDRESS  BUS 
        e' il seguente :

                                0011111111111111

        I  primi  14 bit dell'ADDRESS BUS sono in questo caso tutti  a  1 
        mentre gli ultimi due a 0 (quelli che raggiungono il decoder).
        Il  decoder  quindi ricevendo in ingresso 0 0 mette a 1 il  primo 
        piedino mandando il segnale di attivazione al pin di chip  select 
        del primo integrato.
        Questo  prelevera'  l'indirizzo  presente sui  rimanenti  14  bit 
        dell'ADDRESS BUS indirizzando in questo modo la locazione 16383.
        A  questo punto l'indirizzo richiesto dal processore,  sempre  ad 
        esempio,  potrebbe  essere 16384 che sommando la capacita' dei  4 
        chip risulterebbe essere la prima locazione del chip 2.
        Il processore immeterebbe in questo caso l'indirizzo in binario

                                0100000000000000

        I primi 14 bit,  tutti a 0,  indicherebbero ai chip che la  cella 
        richiesta e' la prima.
        In  questo  caso pero' i bit che raggiungono il decoder non  sono 
        piu'  tutti  a  0 ma il primo a 1 costringerebbe  il  decoder  ad 
        accendere il pin 2 relativo al secondo chip di memoria.
        Il discorso non cambia continuando di questo passo.
        Spero che questo sia stato comprensibile.
        Fate pure delle prove considerando magari piu' chip di  capacita' 
        minore.
        Vi   accorgerete  che  il  discorso  non  e'  diverso  in  quanto 
        chiaramente un numero di locazioni minore per ogni chip  pretende 
        anche   per  il  suo  indirizzamento  un  numero  minore  di  bit 
        sull'ADDRESS BUS.
        Tutti  i  rimanenti  ad arrivare a 16  sarebbero  utilizzati  dal 
        decoder  che avrebbe,  avendo piu' ingressi,  la possibilita'  di 
        indirizzare piu' chip.
        C'e' sicuramente chi si chiedera'.
        Ma  se un ADDRES BUS di 16 bit puo' indirizzare fino a 64  Kbytes 
        come fa' un PC IBM o un M24 ad avere una memoria indirizzabile di 
        1 Mbytes ?
        E' semplice.
        Per poter accedere a una simile quantita' di memoria occorrono 20 
        bit sull'ADDRESS BUS.

                               2 ^ 20 = 1.048.576



                                       132





        Linguaggio C per MS DOS - F. Bernardotti - 1987 Opus Free Soft





        Il  metodo  utilizzato  e' essenziale per  poter  comprendere  il 
        concetto di segmentazione della memoria.
        Il  processore indirizza la memoria a blocchi di 64 Kbytes  detti 
        segmenti utilizzando una parola di indirizzo di 16 bit.
        Come  abbiamo  accennato prima l'8088/86 possiede 4  registri  di 
        segmento (CS,DS,SS ed ES) che utilizza come indirizzo di partenza 
        per  contare  da  questo  il  numero  di  locazioni   specificate 
        dall'indirizzo a 16 bit.
        Piu'  precisamente il processore prende il valore di un  registro 
        di  segmento,  esegue  uno shift a sinistra di 4 posizioni e  gli 
        aggiunge quello definito offset che altro non e' che  l'indirizzo 
        a 16 bit di cui abbiamo parlato.
        In questo modo ottiene un indirizzo fisico a 20 bit.
        Ogni  segmento  puo'  iniziare ad ogni paragrafo  ossia  ad  ogni 
        blocco di 16 bytes.
        Questo  significa che un segmento potrebbe iniziare da  locazioni 
        tipo 0000H, 0010H, 0020H ecc.
        L'offset,  lo  ripeto,  e'  la  distanza di una  certa  locazione 
        dall'inizio del segmento.
        A  questo punto solo piu' due parole riguardo l'uso dei  registri 
        di segmento.
        CS  e' il segmento di codice e contine le istruzioni  che  devono 
        essere eseguite dal processore.
        DS  e' invece il registro di segmento dati atto a contenere  dati 
        di uso generale.
        SS  di  cui  abbiamo gia' parlato e' il  segmento  relativo  allo 
        stack.
        Infine  tra  i  registri  di segmento  ritroviamo  anche  l'extra 
        segmente,  ES,  che puo' essere usato come area secondaria ad uso 
        generale.
        Possiamo   aver   concluso  con  questo  il   discorso   relativo 
        all'indirizzamento di memoria.
        Spero di essere stato chiaro,  anche se sicuramente lungo, almeno 
        per  quanto  riguarda  il discorso dei  segmenti  in  quanto  nei 
        capitoli successivi,  quelli che tratteranno gli interrupt, sara' 
        un argomento ricorrente.
        Ometto la descrizione accurata su uno dei blocchi riportati nello 
        schema iniziale in quanto penso che tutti conoscano la differenza 
        tra una memoria RAM e una ROM.
        La  memoria  normalmente  utilizzata dal processore  per  le  sue 
        operazioni   e'   quella  RAM  ossia  una  memoria  in   cui   lo 
        stazionamento  dei dati e' momentaneo in quanto si tratta di  una 
        memoria di lettura/scrittura volatile e cioe' riscrivibile.
        La  ROM e' una memoria solo di lettura e viene utilizzata dal  PC 
        per  il mantenimento della parte residente del BIOS (Basic  Input 
        Output System).
        Il  processore  puo'  utilizzare questa solo  per  operazioni  di 
        lettura.
        Un  esempio  grafico  relativo  alla  costruzione  dell'indirizzo 
        fisico e' il seguente.




                                       133





        Linguaggio C per MS DOS - F. Bernardotti - 1987 Opus Free Soft




                                     16                1
                                     +-----------------+
                                     :      OFFSET     :
                                     +-------+--+------+  
                                 16          :  : 1   
                                 +-----------:  :-+----+ 
                                 :  SEG REG  :  : :0000:
                                 +-----------:  :-+----+
                                        :  : :  :
                                        :  : :  :
                                     +-------------+
                                      \     +     /
                                       +---------+
                                           :  :
                               20          :  :        1
                               +-----------------------+
                               :    INDIRIZZO FISICO   :
                               +-----------------------+


        Con  questo  concludo il discorso relativo all'indirizzamento  di 
        meoria e alla segmentazione.
        L'unico  blocco  di  cui non abbiamo accennato  nulla  e'  quello 
        relativo all' I/O per il quale sara' riservato un apposito spazio 
        quando  parleremo della gestione delle varie porte di un  sistema 
        8088/86.



                        Gestione memoria in linguaggio C



        Il  linguaggio C,  pur non possedendo di funzioni tipo quelle del 
        Basic (peek e poke), ci  permette mediante alcuni accorgimenti di 
        accedere alla memoria.
        Il  seguente  esempio  scrive  la lettera  A  direttamente  nella 
        memoria video.

        char far *var = 0xB8000000; /* Segmento + offset               */

        funzione()
        {
             *var = 'A';
             ..........
        }

        NOTA: 0xB800 e' il segmento della memoria video della scheda CGA.

        Un  esempio come quello precedente fa' emettere al compilatore un 
        messaggio di warning ma in ogni caso e' efficace.




                                       134





        Linguaggio C per MS DOS - F. Bernardotti - 1987 Opus Free Soft





        Come  abbiamo gia' detto la scrittura nei registri di segmento in 
        linguaggio C e possibile solo per quanto riguarda il registro  DS 
        ed ES.
        Il  discorso  relativo  alla segmentazione  assume  una  notevole 
        importanza nel momento in cui si tenta di eseguire il link di due 
        funzioni, una scritta in assembler e l'altra in linguaggio C.
        In  questo  caso  dovranno essere  seguite  alcune  regole  nella 
        dichiarazione  dei  segmenti  e delle funzioni al  momento  della 
        scrittura del modulo in assembler.
        Una tecnica del genere,  ovvero il link di un modulo assembler  e 
        uno C,  puo' rivelarsi utile nel momento in cui si eseguono delle 
        modifiche a vettori di interruzione.
        Benche'   sia  possibile  eseguire  certe  tecniche  anche   solo 
        utilizzando il linguaggio C queste risultano piu' ostiche.  
        Vediamo uno schema che raffigura l'utilizzo fatto dal compilatore 
        della memoria.

        Memoria Alta      +-------------------------------------------+
                          :      Spazio per  allocazione dinamica     :
                          +-------------------------------------------+
                          :                    Stack                  :
                          +-------------------------------------------+
                          :            _BSS    e   c_common           :
                          +-------------------------------------------+
                          :                    CONST                  :
                          +-------------------------------------------+
                          :                    _DATA                  :
                          +-------------------------------------------+
                          :                    NULL                   :
                          +-------------------------------------------+
                          :                Data Segments              :
                          +-------------------------------------------+
                          :                    _TEXT                  :
        Memoria bassa     +-------------------------------------------+


        La  prima area consiste in una zona non allocata che il programma 
        puo'utilizzare per le allocazioni dinamiche.

        La descrizione dei segmenti e' la seguente.

        STACK         Il segmento dello stack viene utilizzato per  tutte 
                      le variabili locali.

        _BSS          Questo  segmento contiene tutte i dati statici  non 
                      inizializzati  eccetto quelli che utilizzano la key
                      far nella dichiarazione del sorgente.

        c_common      Il segmento c_common contiene tutti i dati  globali 
                      non  inizializzati per i modelli di memoria piccolo 
                      e  medio.  Nel modello largo di memoria questi tipi 
                      di  dati  vengono piazzati in un data  segment  con 


                                       135





        Linguaggio C per MS DOS - F. Bernardotti - 1987 Opus Free Soft





                      classe FAR_BSS.

        CONST         Vengono  contenute  in  questo  segmento  tutte  le 
                      costanti che possono solo essere lette.

        _DATA         E' considerato  il data segment  di  default.  Dopo 
                      l'inizializzazione  tutte  le variabili  globali  e 
                      statiche  vengono  conservate  qui  eccetto  quelle 
                      utilizzanti nella dichiarazione la key far.  Queste 
                      vengono poste in un segmento differente.

        NULL          E' un  segmento particolare che viene utilizzato ad 
                      esempio  per  la memorizzazione del  copyright  del 
                      compilatore.  Questo  segmento e' testato  prima  e 
                      dopo    l'esecuzione  del  programma.   Se  durante 
                      l'esecuzione   il   contenuto  cambia   allora   il 
                      programma  emettera' un messaggio di  errore  "Null 
                      pointer assignment".

        Data Segment  Le  variabili statiche e globali far sono  inserite 
                      in questo segmento con classe FAR_DATA.

        _TEXT         Questo e' il segmento di codice.


        La  scrittura  di  funzioni in assembler da  linkare  con  quelle 
        scritte in C ci obbliga a riferirci al segmento di codice _TEXT.
        E' anche facile che venga utilizzato come segmento data _DATA.
        Parlando nel capitolo riguardante l'hardware dei vari registri di 
        segmento avevamo visto che questi erano 4.
        Come  e'  possibile  che il compilatore Microsoft  tratti  invece 
        tutti i segmenti appena visti ?
        Qui entra in ballo il concetto di gruppo.
        Tutti  i segmenti con lo stesso nome di gruppo  possono  trovarsi 
        nello stesso segmento fisico.
        Questo abilita tutti i segmenti di un gruppo ad essere acessibili 
        attraverso lo stesso registro di segmento.

        I  segmenti  NULL,  _DATA,  CONST,  _BSS,  c-common e STACK  sono 
        raggruppati  insieme in un gruppo data chiamato DGROUP che  viene 
        indirizzato utilizzando i registri DS o SS.
        Questo  abilita il compilatore a generare un codice per  accedere 
        ai  dati  in ogniuno di questi  senza dover leggere di  volta  in 
        volta il valore del segmento.

        Guardatevi   la  seguente  tabella  riportata  dal  manuale   del 
        compilatore  Microsoft  in cui vengono  indicati  i  segmenti,  i 
        gruppi e le classi per i modelli standard di memoria.






                                       136





        Linguaggio C per MS DOS - F. Bernardotti - 1987 Opus Free Soft





        -----------------------------------------------------------------
        Modello    Nome         Tipo di       Classe  di  Nome     Gruppo
        memoria    segmento     allineamento  combin.     classe
        -----------------------------------------------------------------
        Small      _TEXT        byte          public      CODE
                   Data Seg.(a) para          private     FAR_DATA
                   Data Seg.(b) para          public      FAR_BSS
                   NULL         para          public      BEGDATA  DGROUP
                   _DATA        word          public      DATA     DGROUP
                   CONST        word          public      CONST    DGROUP
                   _BSS         word          public      BSS      DGROUP
                   STACK        para          stack       STACK    DGROUP

        Medium     mod_TEXT     byte          public      CODE 
                      .
                      . 
                   Data Seg.(a) para          private     FAR_DATA
                   Data Seg.(b) para          public      FAR_BSS
                   NULL         para          public      BEGDATA  DGROUP
                   _DATA        word          public      DATA     DGROUP
                   CONST        word          public      CONST    DGROUP
                   _BSS         word          public      BSS      DGROUP
                   STACK        para          stack       STACK    DGROUP

        Large      mod_TEXT     byte          public      CODE     
                      .
                      .
                   Data Seg.(c) para          private     FAR_DATA
                   Data Seg.(d) para          public      FAR_BBS
                   NULL         para          public      BEGDATA  DGROUP
                   _DATA        word          public      DATA     DGROUP
                   CONST        word          public      CONST    DGROUP
                   _BSS         word          public      BSS      DGROUP
                   STACK        para          stack       STACK    DGROUP

        (a) Segmento per i dati far inizializzati
        (b) Segmento per i dati far non inizializzati
        (c) Segmento per i dati globali e statici inizializzati
        (d) Segmento per i dati globali e statici non inizializzati

        Utilizzando   con  il  linguaggio  C  delle  routine  scritte  in 
        assembler   dobbiamo  prestare  attenzione  al   salvataggio   in 
        ingresso dei registri BP, SI e DI.
        Dopo  aver fatto questo si deve settare anche il registro BP  con 
        il contenuto del SP.
        Lo stesso discorso vale per i registri SS, CS e DS.
        Quando  il modulo assembler,  durante la sua esecuzione, modifica 
        il   contenuto   di   questi  registri  e   necessario   salvarli 
        inizialmente e ripristinarli in uscita dalla routine.





                                       137





        Linguaggio C per MS DOS - F. Bernardotti - 1987 Opus Free Soft





        Non  mi sembra il caso,  vista la gia' consistente  lunghezza  di 
        questo   testo,   di  estendere  la  trattazione  al   linguaggio 
        assembler   e  quindi  il  significato  di  quanto  riportato  e' 
        esclusivamente  per  coloro che possiedono  gia'  una  conoscenza 
        almeno concettuale di questo.


        D'altra  parte mi sembra inutile il discorso in quanto se non  si 
        possiede  una  conoscenza minima sull'argomento che  permetta  di 
        scrivere  almeno  4  righe  in  linguaggio  assemblativo  diventa 
        impensabile scrivere programmi misti linguaggio C - assembler.
        In ogni caso una routine classica di salvataggio dei registri  da 
        utilizzare in ingresso nel modulo assembler e' il seguente.

        ingresso:
                    push  bp
                    mov   bp,sp
                    push  di
                    push  si

        Nella  fase  di estrazione in uscita ricordatevi che questa  deve 
        essere contraria all'ordine seguito in ingresso.

        uscita:
                    pop   si
                    pop   di
                    mov   sp,bp
                    pop   bp
                    ret

        Come  una funzione in linguaggio C anche un modulo in  assembler, 
        mediante  in  registri AX e DX,  puo' ritornare  un  valore  alla 
        funzione chiamante.
        Per convenzione vale la seguente tabella :

                 Tipo valore ritornato          Registri
                 -----------------------------------------------
                 char                           AX
                 short                          AX
                 int                            AX
                 unsigned char                  AX
                 unsigned short                 AX
                 unsigned int                   AX
                 long                           DX - parte alta
                                                AX - parte bassa
                 unsigned long                  come long
                 struct o union                 AX - indirizzo
                 float o double                 AX - indirizzo
                 near pointer                   AX
                 far pointer                    DX - segmento
                                                AX - offset



                                       138





        Linguaggio C per MS DOS - F. Bernardotti - 1987 Opus Free Soft





        Le  funzioni  chiamate  dal linguaggio  assembler  devono  essere 
        precedute dal carattere underscore (_).
        Supponendo di voler chiamare dal modulo in assembler una funzione 
        della parte di programma scritto in C chiamata stampa(),  dovremo 
        fare   riferimento,   dopo  opportuna  dichiarazione  extern  nel 
        seguente modo :

                                  EXTRN _stampa

                                  call  _stampa

        La  stessa  regola della dichiarazione come extern  vale  per  le 
        chiamate da linguaggio C a funzioni del modulo assembler.
        La funzione chiamata dovra' essere

                                 extern funz();

        Anche il nome della funzione assembler deve cominciare con _ .
        Vedremo degli esempi di utilizzo piu' avanti.



                               Interrupts hardware 



        Gli interrupts permettono alle varie periferiche di comunicare al 
        processore  il  verificarsi di un determinato evento e quindi  di 
        avere la sua attenzione.
        La battitura di un tasto sulla tastiera,  ad esempio,  fa' si che 
        questa   emetta  una  richiesta  di  interrupt  sulla  linea   di 
        controllo.
        L'integrato  8259  riceverebbe  la  richiesta  e  dopo  opportuna 
        codifica la passerebbe al processore 8088/86.
        Questo  integrato  accetta dal bus di controllo fino a 8  diverse 
        richieste  di interruzione provvenienti dai vari dispositivi  che 
        compongono il sistema.

                  8259              Codice          Dispositivo
                  ---------------------------------------------
                  IRQ0              08H             Timer
                  IRQ1              09H             Tastiera
                  IRQ2              0AH             Scheda grafica
                  IRQ3              0BH             RS_232 (COM1)
                  IRQ4              0CH             RS_232 (COM2)
                  IRQ5              0DH             Disco fisso
                  IRQ6              0EH             Dischi
                  IRQ7              0FH             Stampante

        I  servizi  di interrupts di cui tra breve  parleremo  sono  gia' 
        relativi  alle routine del sistema operativo ovvero alle funzioni 



                                       139





        Linguaggio C per MS DOS - F. Bernardotti - 1987 Opus Free Soft





        che servono a sodisfare le varie richieste di interrupt software.
        Per   ora   ancora  due  parole  relative   al   controllore   di 
        interruzioni.
        Analizzando  una  delle strutture definita  in  dos.h,  riportata 
        precedentemente  quando parlavamo delle funzioni per la  gestione 
        degli  interrupts  da linguaggio C,  si puo' notare che  uno  dei 
        membri di questa era sotto il nome di cflag.
        Parlando  del  processore e dei vari registri presenti in  questo 
        avevo  omesso  la  descrizione  relativa  al registro dei  flags.
        Il nome flag sta' per indicatore o bandierina.
        Da questo risulta facile comprendere il compito svolto da questi.
        Parlando  della struttura dei processori della prima  generazione 
        avevamo   detto   a   riguardo  dello   stack   che   una   delle 
        implementazioni  fatte  dai progettisti allo scopo  di  eliminare 
        l'inconveniente  della  perdita'  sul fondo dei  dati  era  stata 
        quella di inserire un flag di stack.
        Questo, come dicevamo, indicava lo stato dello stack .
        I  flags infatti segnalano degli eventi collaterali frutto  delle 
        operazioni del processore.
        Vediamo l'elenco dei flags nell'apposito registro.

                       11  10   9   8   7   6   4   2   0
                      +---+---+---+---+---+---+---+---+---+
                      :OF :DF :IF :TF :SF :ZF :AF :PF :CF :
                      +---+---+---+---+---+---+---+---+---+

        Come  noterete  non ho riportato tutti i bit dei 16 presenti  nel 
        registro in quanto alcuni non sono utilizzati.

                              OF - Flag di overflow

        Nel caso che si esegua un operazione aritmetica e che si abbia un 
        riporto  che  invade  o supera il bit di  segno,  quello  piu'  a 
        sinistra, questo flag viene messo a 1.
          
                              DF - Flag di direzione

        Quando in memoria si eseguono operazioni su stringhe e' possibile 
        utilizzare i registri DI e SI come indici.
        Nel  caso  che questo flag sia a 0 i  suddetti  registri  vengono 
        incrementati mentre, al contrario, se a 1 vengono decrementati.
         
                            * IF - Flag di interruzione
                            * TF - Flag di trappola

        Per questi due flags vedi la descrizione nella prossima pagina.
         
                              SF - Flag di segno

        Dopo  un operazione aritmetica il valore a 0 del flag  indica  un 
        risultato positivo mentre uno a 1 lo indica negativo.



                                       140





        Linguaggio C per MS DOS - F. Bernardotti - 1987 Opus Free Soft




                              ZF - Flag di zero

        Viene utilizzato nelle operazioni di confronto.
        Un  valore 0 indica un risultato diverso da 0 mentre 1 lo  indica 
        uguale a 0.

                              AF - Flag di riporto aux.

        Viene  settato  ad 1 se un calcolo ha un riporto dal bit 3 di  un 
        operazione di un byte su di un registro.

                              PF - Flag di parita'

        Viene settato a 0 se il controllo sugli 8 bit dei dati e' dispari 
        mentre a 1 se e' pari.
        Non ha nulla a che vedere con il controllo di parita'.
        Sinceramente non saprei indicarne un uso.

                              CF - Flag di riporto

        Contine  il  riporto dal bit di ordine piu' alto (quello  piu'  a 
        sinistra).

        Ad  esempio  se un operazione ha avuto un risultato  negativo  il 
        flag di segno lo indichera'.
        Anche per quanto riguarda le interruzioni esistono dei flags  che 
        si interessano di queste.
        Nell'elenco   precedente   le  ho  contrassegnate   mediante   un 
        asterisco.
        Il  flag  di trappola ha un significato particolare in quanto  se 
        settato  permette  l'esecuzione passo a passo  del  programma.
        Il  processore in questo caso,  dopo l'esecuzione di ogni singola 
        istruzione, segnalera' un interruzione di tipo 1.
        Simile tecnica e' utilizzata dall'opzione trace del DEBUG.
        Questa,  come molti sapranno,  permette di seguire lo svolgimento 
        di un programma visualizzando ad ogni istruzione il contenuto dei 
        vari registri, in pratica l'operazione definita di trace.
        Il  flag IF invece ha il compito di abilitare o  di  disabilitare 
        gli interrupts.
        Quando   questo  viene  messo  a  0  tutti  gli  interrupts  sono 
        disabilitati mentre se a 1 sono tutti abilitati. 
        Alcune  interruzioni  vengono  definite di tipo  mascherabile  in 
        quanto  e' possibile disabilitarle mediante l'apposito  settaggio 
        di valore sulla porta 21H .
        Questa  operazione puo' essere eseguita su ogni singolo  tipo  di 
        interruzione  hardware visto precedentemente (non su  l'interrupt 
        non mascherabile 02H).
        Il registro di interruzione mascherabile ha il seguente schema :

                    +----+----+----+----+----+----+----+----+
              Bit   : 7  : 6  : 5  : 4  : 3  : 2  : 1  : 0  :
                    +----+----+----+----+----+----+----+----+
                     IRQ7 IRQ6 IRQ5 IRQ4 IRQ3 IRQ2 IRQ1 IRQ0


                                       141





        Linguaggio C per MS DOS - F. Bernardotti - 1987 Opus Free Soft




        Ogni  singolo  bit se a 0 disabilita  l'interrupt  corrispondente 
        mentre se a 1 lo abilita.       
        Il  settaggio  di  un valore 0x20 all'interno  della  porta  0x20 
        indica che l'interrupt e' terminato.
        Allo  scopo  di  evitare la sovrapposizione di  due  chiamate  di 
        interrupt  l'integrato 8259 assegna una priorita' a  ciascuno  di 
        questi in modo che,  nel caso che due giungano conteporaneamente, 
        quella  con priorita' maggiore viene eseguita per prima mentre la 
        seconda viene accodata in attesa che la prima finisca.
        Prima  di proseguire voglio dire alcune parole sul chip di  timer 
        che   risulta   importantissimo  per  tutte  le   operazioni   di 
        temporizzazione del sistema.



                                 8253 Timer Chip


        In  questo capitolo parleremo degli interrupts legati agli eventi 
        del timer e della programmazione del chip 8253.
        Iniziamo a vedere i primi anche se poi l'argomento sara'  ripreso 
        con i programmi residenti in memoria.
        L'  interrupt  08H (Clock Tick) e' molto importante per  tutti  i 
        programmi che pretendono delle particolari temporizzazioni.
        L'interrupt generalmente richiama a ogni tick di clock, dopo aver 
        eseguito  l'update  del  time  of  day,   un  altro  interrupt  e 
        precisamente l'int 1CH.
        Questo normalmente punta,  se il programmatore non ha  effettuato 
        modifiche, a un istruzione di IRET.
        Possiamo  sfruttare questo per settare come routine  di  servizio 
        delle  nostre funzioni particolari che devono essere eseguite  in 
        continuazione in modo regolare.
        Bisogna prestare molta attenzione in quanto,  essendo l'interrupt 
        richiamato a tempi fissi, si potrebbe verificare, nel caso di una 
        routine di servizio troppo lunga,  che la successiva call avvenga 
        quando la prima non e' ancora completata.
        L'interrupt 1CH costituisce un metodo per processi real-time.
        L'interrupt  viene richiamato 18.2 volte al secondo anche se  con 
        opportuna   programmazione  del  chip  del  timer  e'   possibile 
        modificare questo parametro.
        Le   porte  di  sistema  da  40H  a  43H  si  interessano   della 
        programmazione del chip di timer (8253).
        Questo chip dispone internamente di tre timer indipendenti.
        Il  canale 0 del timer viene utilizzato per l'orologio di sistema 
        tramite l'interrupt 08H di cui abbiamo appena parlato.
        Il canale 1 temporizza i cicli di rinfresco della memoria  mentre 
        il canale 2 e' utilizzato per l'altoparlante.
        Le porte che si interessano ai precedenti canali sono

                                  40H Canale 0
                                  41H Canale 1
                                  42H Canale 2



                                       142





        Linguaggio C per MS DOS - F. Bernardotti - 1987 Opus Free Soft





        Per  poter  programmare  una  delle  precedenti  porte  si  ha  a 
        disposizione  la  porta  43H che si interessa di  indirizzare  il 
        canale, l'operazione da eseguire su questo e la modalita'.

                       Bit       Descrizione
                       ------------------------------------------
                       7-6       00 = Operazione su canale 0
                                 01 = Operazione su canale 1 
                                 10 = Operazione su canale 2

                       5-4       00 = Blocca contatore
                                 01 = Legge o scrive MSB
                                 10 = Legge o scrive LSB
                                 11 = Legge o scrive LSB e MSB

                       3-1     *000 = Decremento contatore con 
                                      inibizione opzionale
                                      (uscita a livelli)
                               *001 = Decremento contatore con
                                      ripartenza opzionale
                                      (uscita a livelli)
                                010 = Usato per DMA su canale 1
                                011 = Genera un onda quadra
                                      per canali 0 e 2
                                100 = Decremento contatore con
                                      inibizione opzionale
                                      (uscita a impulsi)
                                101 = Decremento contatore con
                                      ripartenza opzionale
                                      (uscita a impulsi)
                         0            Decremento contatore
                                  0 = Binario
                                  1 = BCD

        (*) Inibizione e ripartenza mediante ricaricamento contatore.
        I valori MSB e LSB sono la parte alta e la parte bassa del valore 
        del  divisore  che  deve  essere settato in un  canale  che  puo' 
        variare da 0 a 65535.
        Una schematizzazione e' la seguente

            
        Canali      0   +-------+       +---------+
                 +------: Latch :-------: Counter :---> Timer Interrupt
                 :      +-------+       +---------+
                 :
        +----+---+  1   +-------+       +---------+
        :8253:----------: Latch :-------: Counter :---> Refresh RAM
        +----+---+      +-------+       +---------+
                 :
                 :  2   +-------+       +---------+
                 +------: Latch :-------: Counter :---> Speaker Interface
                        +-------+       +---------+       


                                       143





        Linguaggio C per MS DOS - F. Bernardotti - 1987 Opus Free Soft






        Supponiamo,  per  esempio,  di voler cambiare il valore di 18.2 a 
        1000.
        La velocita' di input del clock 8253 e' di 1.193.180 Hz.
        Per  poter  ottenere  il  divisore relativo a  si  divide  questa 
        frequenza  per   il  numero  di  oscillazioni  desiderate  ovvero 
        1.193.180/1000 = 1193.

        Il programma sara' il seguente.


        mov al,00110110b   ; valore di settaggio porta 43H
                           ; 00  = canale 0
                           ; 11  = scrive LSB e poi MSB
                           ; 011 = genera onda quadra
                           ; 0   = binario
        out 43H,al         ; setta la porta 43H
        ;
        mov ax,1193        ; valore del divisore
                           ; AH = parte alta e AL = parte bassa
        out 40H,al         ; LSB canale 0
        out 40H,ah         ; MSB canale 0


        Spero che il discorso relativo alla programmazione del timer  sia 
        stato sufficentemente chiaro.
        Ritornando all' interrupt 1CH si puo',  allo scopo di chiarire le 
        idee,  riportare  uno  schema in cui risulta il "tragitto"  fatto 
        dallo stesso.


               Vector Table
                    :                     +--------------+ Routine
                    :        +----------->:-             : INT 1CH
                    :      /              :-             :
                    :    /                :-             :
                    :  /                  :-             :
                    :/                    :-             :
                    :\               +---<:- IRET        :
                    :  \             :    +--------------+
                    :    \           :
                    :      \         :
                    :        \       :    +--------------+ Time of Day
                    :      +---\-----:--->:-             : routine
                    :    /       \   :    :-             :
                    :  /          +--:---<:- INT 1CH     :
                    :/               +--->:- MOV AL,20H  :
                    :\                    :- OUT 20H,AL  :  
                    :  \                  :- IRET        :
                    :    \ INT 08H        +--------------+




                                       144





        Linguaggio C per MS DOS - F. Bernardotti - 1987 Opus Free Soft






        Come   vedremo   successivamente  la  ridirezione  dell'int   08H 
        costitusce uno dei metodi per la scrittura di programmi residenti 
        nel caso che questi facciano per l'input utilizzo di alcune  call 
        del Dos.
        Prima  di  terminare  voglio  solo  accennare  al  fatto  che  la 
        programmazione  del  timer  viene  anche  utilizzata  per  quanto 
        riguarda la generazione di suoni.
        Finisco  con questo  discorso relativo all' hardware del  sistema 
        Ms Dos ma prima riporto una panoramica riguardante gli errori che 
        potrebbero essere segnalati dal computer.
        Sicuramente  non fanno parte delle argomentazioni trattate ma  in 
        ogni  caso  potranno  essere utili per risalire  alla  natura  di 
        alcuni inconvenienti che potrebbero verificarsi.
        Non  che  con questo voglia dire che trafficando a basso  livello 
        con interrupts e affini possa portare a guastare l'hardware della 
        macchina in quanto non e' possibile.


        Codice Descrizione
        -----------------------------------------------------------------


        101    Main system board failed.
        109    Direct memory access test error
        121    Unexpected hardware interrupts occurred.
        131    Cassette wrap test failed.
        199    User indicated configuration not correct.
        201    Memory test failed
        301    Keboard did not respond to software reset correctly or  a 
               stuck  key  failure  was  detected.  If a  stuck  key  was 
               detected, the scan code for the key is displayed.
        302    User indicated error from the keyboard test.
        401    Monochrome memory test, horizontal sync frequency test, or 
               video test failed.
        408    User indicated display attributes failure.
        416    User indicated character set failure.
        424    User indicated 80X25 mode failure.
        432    Parallel port test failed ( monochrome adapter ).
        501    Color memory test failed,  horizontal sync frequency test, 
               or video test failed.
        508    User indicated display attribute failure.
        516    User indicated character set failure.
        524    User indicated 80x25 mode failure.
        532    User indicated 40x25 mode failure.
        540    User indicated 320x200 graphics mode failure.
        548    User indicated 640x200 graphics mode failure.
        601    Diskette power on diagnostics test failed.
        602    Diskette test failed
        606    Diskette verify function failed.
        607    Write protected diskette.
        608    Bad command diskette status returned.


                                       145





        Linguaggio C per MS DOS - F. Bernardotti - 1987 Opus Free Soft






        610    Diskette initialization failed.
        611    Timeout - diskette status returned.
        612    bad NEC - diskette status returned.
        613    Bad DMA - diskette status returned.
        621    Bad seek - diskette status returned.
        622    Bad CRC - diskette status returned.
        623    Record not found - diskette status returned.
        624    Bad address mark - diskette status returned.
        625    Bad NEC seek - diskette status returned.
        626    Diskette data compare error.
        7xx    8087 math coprocessor
        901    Parallel printer adapter test failed.
        10xx   Reserved for parallel printer adapter.
        1101   Asynchronous communications adapter test failed.
        1201   Alternate Asynchronous communications adapter test failed.
        1301   Game control adapter test failed.
        1302   Joystick test failed.
        1401   Printer test failed.
        15xx   Sdlc communications adapter errors.
        1510   8255 port B failure.
        1511   8255 port A failure.
        1512   8255 prot C failure.
        1513   8253 timer 1 did not reach terminal count.
        1514   8253 timer 1 stuck on.
        1515   8253 timer 0 did not reach terminal count.
        1516   8253 timer 0 stuck on.
        1517   8253 timer 2 did not reach terminal count.
        1518   8253 timer 2 stuck on.
        1519   8273 port B error.
        1520   8273 port A error.
        1521   8273 command/read timeout.
        1522   Interrupt level 4 failure.
        1523   Ring Indicate stuck on.
        1524   Receive clock stuck on.
        1525   Transmit clock stuck on.
        1526   Test indicate stuck on.
        1527   Ring indicate not on.
        1528   Receive clock not on.
        1529   Transmit clock not on.
        1530   Test indicate not on.
        1531   Data set ready not on.
        1532   Carrier detect not on.
        1533   Clear to send not on.
        1534   Data set ready stuck on.
        1536   Clear to send stuck on.
        1537   Level 3 interrupt failure.
        1538   Receive interrupt results error.
        1539   Wrap data miscompare.
        1540   DMA channel 1 error.
        1541   DMA channel 1 error.
        1542   Error in 8273 error checking or status reporting.


                                       146





        Linguaggio C per MS DOS - F. Bernardotti - 1987 Opus Free Soft






        1547   Stray interrupt level 4
        1548   Stray interrupt level 3
        1549   Interrupt presentation sequence timeout.
        17xx   Fixed Disk errors.
        1701   Fixed disk Post error.
        1702   Fixed disk adapter error.
        1703   Fixed disk drive error
        1704   Fixed disk adapter or drive error.
        18xx   I/O Expansion unit errors.
        1801   I/O Expansion unit POST error.
        1810   Enable/Disable failure.
        1811   Extender card wrap test failed (disabled).
        1812   High order addtess lines failure (disabled).
        1813   Wait state failure (disabled).
        1814   Enable/Diaable could not be set on.
        1815   Wait state failure (enabled).
        1816   Extender card wrap test failed (enabled).
        1817   High order adress lines failure (enabled).
        1818   Disable not functioning
        1819   Wait request switch not set correctly
        1820   Receiver card wrap test failure
        1821   Receiver high order address lines failure
        20xx   Bisync communications adapter errors
        2010   8255 port a failure
        2011   8255 port b failure
        2012   8255 port c failure
        2013   8253 timer 1 did not reach terminal count
        2014   8253 timer 1 stuck on
        2016   8253 timer 2 did not reach terminal count or timer 2 stuck on.
        2017   8251 Data set ready failed to come on
        2018   8251 Clear to send not sensed
        2019   8251 Data set ready stuck on
        2020   8251 Clear to send stuck on
        2021   8251 hardware reset failed
        2022   8251 software reset failed
        2023   8251 software "error reset" failed
        2024   8251 transmit ready did not come on
        2025   8251 receive ready did not come on
        2026   8251 could not force "overrun" error status
        2027   Interrupt failure-no timer interrupt
        2028   Interrupt failure-transmit, replace card or planar
        2029   Interrupt failure-transmit, replace card
        2030   Interrupt failure-receive, replace card or planar
        2031   Interrupt failure-receive, replace card
        2033   Ring indicate stuck on
        2034   Receive clock stuck on
        2035   Transmit clock stuck on
        2036   Test indicate stuck on
        2037   Ring indicate stuck on
        2038   Receive clock not on
        2039   Transmit clock not on


                                       147





        Linguaggio C per MS DOS - F. Bernardotti - 1987 Opus Free Soft






        2040   Test incicate not on
        2041   Data set ready not on
        2042   Carrier detect not on
        2043   Clear to send not on
        2044   Data set ready stuck on
        2045   Carrier detect stuck on
        2046   Clear to send stuck on
        2047   Unexpected transmit interrupt
        2048   Unexpected receive interrupt
        2049   Transmit data did not equal receive data
        2050   8251 detected overrun error
        2051   Lost data set ready during data wrap
        2052   Receive timeout during data wrap
        21xx   Alternate bisync communications adapter errors
        2110   8255 port a failure
        2111   8255 port b failure
        2112   8255 port c failure
        2113   8253 timer 1 did not reach terminal count
        2114   8253 timer 1 stuck on
        2116   8253 timer 2 did not reach terminal count or
        2117   8251 Date set ready failed to come on
        2117   8251 Clear to send not sensed
        2118   8251 Data set ready stuck on
        2119   8251 Clear to send stuck on
        2120   8251 hardware reset failed
        2121   8251 software reset failed
        2122   8251 software "error reset" failed
        2123   8251 transmit ready did not come on
        2124   8251 receive ready did not come on
        2125   8251 could not force "overrun" error status
        2126   Interrupt failure-no timer interrupt
        2128   Interrupt failure-transmit, replace card or
        2129   Interrupt failure-transmit, replace card
        2130   Interrupt failure-receive, replace card or planar
        2131   Interrupt failure-receive, replace card
        2133   Ring indicate stuck on
        2134   Receive clock stuck on
        2135   Transmit clock stuck on
        2136   Test indicate stuck on
        2137   Ring indicate stuck on
        2138   Receive clock not on
        2139   Transmit clock not on
        2140   Test incicate not on
        2142   Data set ready not on
        2142   Carrier detect not on
        2143   Clear to send not on
        2144   Data set ready stuck on
        2145   Carrier detect stuck on
        2146   Clear to send stuck on
        2147   Unexpected transmit interrupt
        2148   Unexpected receive interrupt


                                       148





        Linguaggio C per MS DOS - F. Bernardotti - 1987 Opus Free Soft






        2149   Transmit data did not equal receive data
        2150   8251 detected overrun error
        2151   Lost data set ready during data wrap
        2152   Receive timeout during data wrap



        Con  questo  concludiamo  il  discorso  relativo  alla   gestione 
        hardware  degli interrupts e iniziamo a vedere come sfruttare gli 
        interrupts software disponibili sotto sistema MS DOS.



                                 Interrupts BIOS



        Dopo aver affrontato,  durante i capitoli precedenti,  il viaggio 
        attraverso l'analisi strutturata, la sintassi del linguaggio C ed 
        alcuni  accenni  di  hardware del sistema eccoci  ora  pronti  ad 
        interessarci degli interrupts software del BIOS e del DOS.
        Vedremo  inizialmente  i  primi in quanto sono  alla  base  della 
        gestione della macchina 8088/86.
        Parlando  precedentemente  della struttura hardware  del  sistema 
        avevamo  fatto una descrizione sommaria trattando  esclusivamente 
        alcuni   blocchi  principali  senza  preoccuparci  di  tutte   le 
        periferiche  che svolgono un compito complementare ma  essenziale 
        all'interno di questa.
        Il  BIOS,  in parte residente su ROM e in parte su  disco,  serve 
        appunto alla diagnostica e al controllo di questi blocchi.
        Nei  capitoli  precedenti  i  concetti  di  timer,   di  DMA,  di 
        controllore dischi,  porte di comunicazione ecc.  non sono  stati 
        trattati  in  quanto ho pensato di cogliere  l'occasione  offerta 
        dagli interrupts BIOS per ampliare il discorso a questi.
        Come  nel  caso di una programmazione diretta delle  porte  anche 
        l'utilizzo  degli  interrupts del DOS in linguaggio C porta  alla 
        scrittura  di  un codice non trasportabile in  quanto  fortemente 
        legato alla struttura hardware della macchina.
        Che cosa sono gli interrupts del BIOS e del DOS ?
        Possiamo  considerare  questi  come  delle  chiamate  a  speciali 
        funzioni che hanno il compito di svolgere dei particolari servizi
        di gestione.
        Nei   capitoli   successivi  alla  descrizione  dei  servizi   di 
        interrupts parleremo del modo da seguire per l'intercettazione  e 
        la modifica di questi.
        A questo scopo e' fondamentale capire il meccanismo che sta' alla 
        base dello svolgimento del servizio stesso.
        Precedentemente  parlando  dei compito dello stack avevamo  detto 
        che  in caso di una call l'indirizzo presente sul registro  IP  e 
        precisamente quello relativo alla successiva istruzione da essere 
        eseguita veniva salvato su questo.


                                       149





        Linguaggio C per MS DOS - F. Bernardotti - 1987 Opus Free Soft





        Anche  nel  caso di una richiesta di interrupt il sistema  salva, 
        prima  di  eseguire  la routine  di  servizio  dell'interruzione, 
        l'ambiente  di  lavoro allo scopo di porterlo  ripristinare  alla 
        fine di questa.
        Le operazioni svolte prima di richiamare la funzione di  servizio 
        sono le seguenti :


        1 - viene salvato sullo stack il registro dei flags.

        2 - I flags IF e TF vengono messi a zero in modo da prevenire una 
            seconda  chiamata di interrupt mentre la prima e'  ancora  in 
            svolgimento.

        3 - vengono salvati sullo stack i registro di codice CS e IP.


        Queste  operazioni risultano indispensabili ed e' facile  capirne 
        il  perche' vedendo come il processore riesce ad identificare  la 
        routine di servizio e a mandarla in esecuzione.
        Ogni  periferica collegata oltre alla possibilita' di  richiedere 
        al  processore  un  interruzione  ha  il  dovere  di  specificare 
        mediante  un  apposito byte il codice di  tipo  dell'interruzione 
        stessa.
        Il processore infatti utilizza quest'ultimo per l'identificazione 
        del subroutine da richiamare. 
        Gli  indirizzi  delle funzioni sono contenuti  all'interno  delle 
        locazioni comprese tra 0000H e 03FFH (Tavola vettori interrupts).
        Ogni  accesso  a  questa tavola contiene quattro byte in  cui  e' 
        specificato il segmento e l'indirizzo relativo alla routine.
        Da  questo  e' possibile risalire alle locazioni  che  contengono 
        l'indirizzo  relativo  e quello del  segmento  corrispondente  al 
        tipo di interruzione richiesto.

                               indirizzo relativo

                          parte bassa  =  4 * TIPO
                          parte alta   =  4 * TIPO + 1             

                               indirizzo segmento

                          parte bassa  =  4 * TIPO + 2
                          parte alta   =  4 * TIPO + 3
         
        Prima  di  portare un esempio vediamo gli indirizzi  relativi  ad 
        alcuni vettori di interruzione.
        Una   chiamata  ad  un  interrupt  potrebbe  essere  eseguita  in 
        assembler con :

                       pushf
                       cli
                       call DWORD 0000:4*Numero_Interrupt


                                       150





        Linguaggio C per MS DOS - F. Bernardotti - 1987 Opus Free Soft






        Guardiamo l'elenco dei principali interrupts.

                 
              -----------------------------------------------------
              Tipo    Num.HEX                Descrizione  Seg. Off.
              -----------------------------------------------------

              Hard    0000                Divide by zero  3910:010F
              Soft    0001                   Single step  0070:01F0
              Hard    0002        Non-Maskable interrupt  F000:E2C3
              Soft    0003                    Breakpoint  0070:01F0
              Soft    0004                      Overflow  0070:01F0
              Soft    0005                  Print screen  F000:FF54
              Hard    0008                         Timer  F000:FEA5
              Hard    0009                      Keyboard  28D6:0104
              Hard    000A            I/O channel action  F000:E6DD
              Hard    000B                  RS_232  COM1  F000:E6DD
              Hard    000C                  RS_232  COM2  F000:E6DD
              Hard    000D             Fixed disk action  C800:01BE
              Hard    000E                      Diskette  F000:EF57
              Hard    000F                   LPT1 action  0070:01F0
              Soft    0010                     Video I/O  F000:F065
              Soft    0011               Equipment check  F000:F84D
              Soft    0012                  Memory check  F000:F841
              Soft    0013                  Diskette I/O  0070:09AB
              Soft    0014                    RS-232 I/O  F000:E739
              Soft    0015                  Cassette I/O  F000:F859
              Soft    0016                  Keyboard I/O  F000:E82E
              Soft    0017                   Printer I/O  295B:30F6
              Soft    0018               ROM BASIC Entry  F600:0000
              Soft    0019              Bootstrap Loader  0070:0ADD
              Soft    001A                   Time of Day  F000:FE6E
              Soft    001B      Get control on KBD Break  07FE:00F2
              Soft    001C          Get control on Timer  F000:FF53
              Tav.    001D      Video control parameters  F000:F0A4
              Tav.    001E       Disk control parameters  0000:0522
              Tav.    001F      Graphics character table  F000:0000
              Soft    0020        DOS programm terminate  012E:12D0
              Soft    0021                 DOS  services  3865:0260
              Soft    0022 Routine to jump to after ....  36FF:012F
              Soft    0023           CTRL BREAK handling  36FF:013C
              Soft    0024            DOS critical error  36FF:04C4
              Soft    0025                 DOS disk read  012E:1468
              Soft    0026                DOS disk write  012E:14AB
              Soft    0027       Terminate,stay resident  012E:5B5A
              Hard    0028       Called when DOS is free  012E:12D6


        PS:  Gli  interrupts  segnati  hard sono hardware,  i  soft  sono 
        interrupts software e i tav. puntano a tavole di parametri.



                                       151





        Linguaggio C per MS DOS - F. Bernardotti - 1987 Opus Free Soft





        Gli interrupts che puntano a tavole non possiedono vere e proprie 
        routine  ma  bensi' contengono gli indirizzi segmentati  relativi 
        appunto a tavole di parametri essenziali per il sistema.
        Oltre a quelli visti esistono altri interrupts.
        Ad  esempio il Basic quando viene caricato se ne crea alcuni  sui 
        particolari.
        Non  parleremo  di  questi in quanto non  parleremo  neppure  del 
        Basic.
        Il numero di interrupts disponibili in un sistema sono 256 di cui 
        solo alcuni possiedono delle routine di servizio settate.
        Altri   interrupts,   come  e'  possibile  notare   nell'esempio, 
        possiedono il vettore che punta agli stessi indirizzi.
        Questi,  pur  avendo degli scopi specifici,  possono  puntare  ad 
        istruzioni di IRET.
        E'  compito  del programmatore scrivere le routine di gestione  e 
        settare nella tavola dei vettori gliindirizzi relativi a queste.
        Altri   interrupts   non  possiedono  scopi  specifici   e   sono 
        disponibili al programmatore per usi particolari.
        Anche  in questo caso si dovranno scrivere le routine di gestione 
        e settare nella tavola dei vettori gli indirizzi relativi.
        Allo  scopo  di  dimostrare come sia  possibile  individuare  gli 
        indirizzi  relativi  al segmento e all'offset delle  funzioni  di 
        servizio degli interrupts anticipo che la call 35H dell'interrupt 
        21H del DOS riporta appunto questi valori.
        Chiaramente  gli indirizzi contenuti nella tavola dei vettori  di 
        interrupts   potrebbero  anche  essere  visualizzati  andando   a 
        scrutare  direttamente nelle locazioni date dai calcoli visti  in 
        precedenza.
        Ad esempio con il Debug fornito con il dos sarebbe possibile, nel
        caso che si voglia vedere l'indirizzo relativo all'interrupt 02H, 
        dare il comando

        C>debug
          -d 0000:0008       <----- Num. Interrupt (02H) * 4

        Vogliate  considerare l'esempio solo una parentesi fuori posto in 
        quanto  come ho gia' detto i servizi dell'interrupt 21H  verranno 
        discussi a suo tempo.
        Avevamo  visto  nei capitoli precedenti che la  funzione  intdosx 
        del compilatore Microsoft C permetteva di eseguire una call ad un 
        servizio  dell'interrupt  21H specificando il  numero  di  questo 
        all'interno del registro AH.
        La funzione intdosx() include nell'operazione anche i registri di 
        segmento.
        La  funzione  35H  (Get  Vector) ritorna nei  registri  ES:BX  il 
        segmento  e l'offset del numero di interrupt  specificato,  prima 
        della chiamata, nel registro AL.
        Il  seguente  programma utilizza come tipi di interrupts  di  cui 
        avere  gli indirizzi i valori inizializzati nell' array di interi 
        dichiarato in testa al programma.
        La  matrice  *descrizione[] viene inizializzata con  i  nomi  dei 
        servizi relativi.


                                       152





        Linguaggio C per MS DOS - F. Bernardotti - 1987 Opus Free Soft





        #include <stdio.h>
        #include <dos.h>

        union REGS inregs, outregs;

        struct SREGS segregs;

        int tipo[] = { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05,
                       0x08, 0x09, 0x0E, 0x10, 0x11, 0x12,
                       0x13, 0x14, 0x15, 0x16, 0x17, 0x18,
                       0x19, 0x1A, 0x1B, 0x1C, 0x1F
        };

        char *descrizione[] = {
                       "Divide by zero",
                       "Single step",
                       "Non maskable int",
                       "Breakpoint",
                       "Overflow",
                       "Print screen",
                       "Timer",
                       "Keyboard",
                       "Diskette",
                       "Video",
                       "Equipment check",
                       "Memory check",
                       "Diskette I/O",
                       "RS 232 I/O",
                       "Cassette I/O",
                       "Keyboard I/O",
                       "Printer I/O",
                       "ROM BASIC Entry",
                       "Boostrap Loader",
                       "Time of day",
                       "Get control on KBD Break",
                       "Get control on Timer",
                       "Graphics character table"
        };

        main()
        {
             int ciclo;

             for(ciclo=0;ciclo!=23;ciclo++) {
                 printf("Interrupts %02x   ", tipo[ciclo]);
                 printf("%25s", descrizione[ciclo]);
                     inregs.h.ah = 0x35;
                     inregs.h.al = tipo[ciclo];
                     intdosx(&inregs, &outregs, &segregs);
                 printf("\t %04x : %04x\n", segregs.es, outregs.x.bx);
             }
        }


                                       153





        Linguaggio C per MS DOS - F. Bernardotti - 1987 Opus Free Soft





        Il  processore  quando viene richiesta un interruzione  riesce  a 
        risalire  all'indirizzo del segmento e dell'offset della funzione 
        di servizio nel modo visto prima.
        Il  segmento  viene assegnato al registro CS mentre  l'offset  al 
        registro  IP in modo che l'istruzione successiva inizi nel  punto 
        in cui e' situata la routine dell'interrupt.
        Ecco  il  motivo  per cui avviene  il  salvataggio  dell'ambiente 
        precedente alla chiamata.
        L'istruzione  IRET che indica la fine della funzione di  servizio 
        dell'interrupt  ripristina  successivamente i valori  salvati  in 
        modo   che  il  programma  che  era  in  esecuzione  al   momento 
        dell'interruzione riprenda.

        A  questo punto possiamo iniziare a trattare la  descrizione  dei 
        vari interrupts del BIOS.
        Abbinero'  a  questi  anche la descrizione delle  funzioni  delle 
        porte  di I/O che gestiscono le periferiche a cui si  interessano 
        gli interrupts stessi.
        In altre parole diciamo che prendo due piccioni con una fava.
        Verranno  visti  non per ordine numerico ma per  quello  relativo 
        alla  loro  ubicazione  fisica  nel  programma  di  gestione   in 
        assembler.


                           Interrupt 14H (RS_232 I/O)


        L'interrupt  14H  si  interessa  della gestione  delle  porte  di 
        comunicazione seriali del sistema.
        I  servizi  svolti,  che vedremo tra  breve,  sono  selezionabili 
        mediante l'apposito settaggio di valore all'interno del  registro 
        AH.
        Le funzioni svolte sono le seguenti :

        AH = 0      Setta i parametri relativi alla porta seriale.

        I valori (baudrate, parita', bit di dati e bit di stop) sono dati 
        dalle seguenti combinazioni e devono essere inseriti, prima della 
        chiamata del'interrupt, nel registro AL.

               bit    7    6    5        4    3      2          1    0
               ----------baud------------parity-----stop---------data-

               110    0    0    0  NONE  0    0  1   0   7 bits 1    0
               150    0    0    1  ODD   0    1  2   1   8 bits 1    1
               300    0    1    0  EVEN  1    1   
               600    0    1    1
               1200   1    0    0
               2400   1    0    1
               4800   1    1    0
               9600   1    1    1
           


                                       154





        Linguaggio C per MS DOS - F. Bernardotti - 1987 Opus Free Soft


                             


        Facciamo subito un esempio.
        Supponiamo  di  voler  settare  la  porta  di  comunicazione  per 
        trasmettere a 300 bauds,  nessuna parita', 1 bit di stop e 8 bits 
        di dati.

        La combinazione binaria da inserire in AL sara' allora 

                                 0 1 0 0 0 0 1 1

        equivalente al numero esadecimale  43H.


        #include <dos.h>

        #define RS_232     0x14        /* Interrupt 14 H               */

        union REGS inregs, outregs;

        set_baud_rate()
        {
               inregs.h.ah = 0x00;     /* Funzione setta porta         */
               inregs.h.al = 0x43;     /* 300,N,8,1                    */

               int86(RS_232, &inregs, &outregs);
        }


        Nel  caso che si possieda piu' di una porta seriale e'  possibile 
        specificare  a  quale  di  questa ci  si  riferisce  il  servizio 
        mediante l'apposito settaggio all'interno del registro DX.
        I  valori ammessi sono due e precisamente 0 relativoa COM1 e 1  a 
        COM2.
        Questa specifica e' valida per tutti i servizi dell'interrupt 14.



        AH = 1     Trasmette il carattere in AL 


        Il  carattere inserito prima della chiamata dell'interrupt in  AL 
        viene fatto uscire dalla porta di comunicazione.
        Dopo   l'esecuzione  del  servizio  il  registro  AH  riporta  il 
        risultato di questo.
        Se  il  valore  contenuto  e' 0  allora  il  carattere  e'  stato 
        trasmesso  correttamente mentre se il bit 7 e' a 1 significa  che 
        c'e' stato un errore.
        Per  l'identificazione del tipo di errore guardate la tabella che 
        riportero' abbinata al servizio 3 dell'interrupt.






                                       155





        Linguaggio C per MS DOS - F. Bernardotti - 1987 Opus Free Soft





        Un esempio di utilizzo e' il seguente :

        #include <dos,h>

        #define  RS_232    0x14
         
        union REGS inregs, outregs;

        tx_char(carat)

        char carat;
        {
             inregs.h.ah = 0x01;
             inregs.h.al = carat;
             int86(RS_232, &inregs, &outregs);
             if(outregs.h.ah != 0)
                 puts("Errore");
        }     


        AH = 2     Riceve un carattere dalla porta.


        Il  carattere  ricevuto viene inserito nel registro AL oppure  il 
        servizio termina in seguito a un errore, ad esempio di timeout.
        Anche in questo caso il modo migliore per identificare il tipo di 
        errore e' quello di supportarsi al servizio che vedremo ora.
        In caso di errore questo viene riportato dal registro AH solo che 
        i bit indicanti il tipo sono solo il 7,4,3,2,1.
        Il  settimo  bit indica un errore di timeout che se  si  verifica 
        rende inutile la lettura dei rimanenti bit di stato.


        AH = 3     Riporta lo stato della linea e del modem.


        Il valore riportato e' contenuto nel registro AX.
        La parte alta del registro (AH) contiene lo stato della linea e i 
        bit testabili sono i seguenti :

        bit 7  =  Timeout
        bit 6  =  Registro di scorrimento trasmettitore vuoto
        bit 5  =  Registro memorizzazione trasmettitore vuoto
        bit 4  =  Rivelazione di break
        bit 3  =  Errore di framing
        bit 2  =  Errore di parita'
        bit 1  =  Errore di sovrapposizione
        bit 0  =  Dato ricevuto pronto






                                       156





        Linguaggio C per MS DOS - F. Bernardotti - 1987 Opus Free Soft




        Il   registro   AL  conterra'  invece  lo  stato  del   modem   e 
        l'interpretazione dei bit e' la seguente :

        bit 7  =  Data carrier detect
        bit 6  =  Ring indicator
        bit 5  =  Data set ready
        bit 4  =  Clear to send
        bit 3  =  Delta data carrier detect
        bit 2  =  Delta ring indicator
        bit 1  =  Delta data set ready
        bit 0  =  Delta clear to send

        Le  routine dell'interrupt si supportano sulle seguenti porte  di 
        I/O per l'esecuzione dei servizi richiesti.
        E'  possibile  utilizzarle  per  la  stesura  dei  programmi   di 
        comunicazione  scritti  in linguaggio C senza dover far  uso  dei 
        servizi elencati precedentemente.
        L'integrato 8250 della scheda RS 232 possiede 10 registri.
        Alcuni  di  questi  sono  testabili in lettura  mentre  ad  altri 
        potremo  scriverci  sopra per settare alcuni parametri  quali  il 
        baud rate, la parita' ecc. 
        Iniziamo  ad  elencare le varie porte legate  alle  comunicazioni 
        seriali.

        Indirizzo porta     Input o Output     Servizio
        -----------------------------------------------------------------
        0x3F8               Out                Registro memorizzazione TX
        0x3F8               In                 Registro dati RX
        0x3F8               Out                Divisore baud rate (LSB)
        0x3F9               Out                Divisore baud rate (MSB)
        0x3F9               Out                Abilitazione interruzioni
        0x3FA               In                 Identificazione interruz.
        0x3FB               Out                Controllo linea
        0x3FC               Out                Controllo modem
        0x3FD               In                 Stato linea
        0x3FE               In                 Stato modem

        Questi indirizzi sono relativi alla porta di comunicazione COM1.
        Gli  indirizzi  relativi  alla porta  COM2  si  possono  ottenere 
        sotraendo 256 agli indirizzi visti precedentemente.
        Un esempio :

        main()
        {
               int indirizzo;
               int porta;
               do {       
                    printf("\nQuale porta (1 o 2) : ");
                    porta = getch();
               } while(porta != 1 && porta != 2);
               indirizzo = 0x2F8 + 256 * (2 - porta); /* 0x3F8 se 1   */ 
        }



                                       157





        Linguaggio C per MS DOS - F. Bernardotti - 1987 Opus Free Soft





        Come  avrete notato nell'elenco precedente alcune porte descritte 
        con funzioni diverse tra di loro possedevano lo stesso indirizzo.
        Lo   scopo  di  queste   e'  selezionabile  mediante   l'apposito 
        settaggio  di un bit all'interno del registro di controllo  della 
        linea.
        Vediamolo.


        Registro di controllo della linea.


                        +---+---+---+---+---+---+---+---+
        0x3FB           : 7 : 6 : 5 : 4 : 3 : 2 : 1 : 0 :
                        +---+---+---+---+---+---+---+---+
                          :   :   :   :   :   :   :   :
                          :   :   :   :   :   :   ---Bit data---
                          :   :   :   :   :   :   0   0 = 5 bits
                          :   :   :   :   :   :   0   1 = 6 bits
                          :   :   :   :   :   :   1   0 = 7 bits
                          :   :   :   :   :   :   1   1 = 8 bits
                          :   :   :   :   :-Bit stop-
                          :   :   :   :   :   0 = 1
                          :   :   :   :   :   1 = 1.5 se 5 bits data
                          :   :   :   :-Parity-
                          :   :   :   :   0 = Nessun bit
                          :   :   :   :   1 = Bit generato
                          :   :   : -Tipo-
                          :   :   :   0 = dispari
                          :   :   :   1 = pari
                          :   :-Test.-
                          :   :   0 = disabilitato
                          :   :   1 = abilitato
                          :-Break-
                          :   0 = disabilitato
                          :   1 = forzato condizione di space
                      ---I/O---
                          0 = Condizione normale
                          1 = Per indirizzare divisori baud rate


        Come  potete  vedere  l'ultimo bit e' quello che fa  si'  che  se 
        impostato  ad  1 i registri 0x3F8 e 0x3F9 vengano utilizzati  per 
        settare i divisori del baudrate.
        Da  questo  e'  facile comprendere  che  e'  possibile  impostare 
        momentaneamente il valore di questo per poter settare la porta al 
        baudrate desiderato  per poi riportarlo al valore normale (0) per 
        utilizzare la porta per funzioni di ricezione.
        Appena  avremo  finito di parlare delle altre  porte  vedremo  un 
        esempio che probabilmente chiarira' le idee nel caso che cio' che 
        e'  stato detto precedentemente non sia risultato sufficentemente 
        chiaro.



                                       158





        Linguaggio C per MS DOS - F. Bernardotti - 1987 Opus Free Soft





        I registri 0x3F8 e 0x3F9, nel caso che bit di cui abbiamo parlato 
        e' a 1, servono per settare i divisori del baud rate.
        Il  primo  conterra' il byte meno significativo (LSB)  mentre  la 
        seconda quello piu' significativo (MSB).
        I valori sono quelli riportati in tabella.

                          Baud rate      MSB        LSB
                          -----------------------------
                            50           09H        00H
                            75           06H        00H
                           110           04H        17H
                           150           03H        00H
                           300           01H        80H
                           600           00H        C0H
                          1200           00H        60H
                          2400           00H        30H
                          4800           00H        18H
                          9600           00H        0CH

         
        Supponiamo  di voler creare una funzione da abbinare a un  nostro 
        programma  di  comunicazione che serva a settare il baud rate  in 
        funzione di una scelta offerta da menu.

        set_baud()
        {
              int key;
              puts("1 .. 300  bauds");
              puts("2 .. 1200 bauds");
              puts("3 .. 2400 bauds");
              puts("\nScelta : ");
              key = getch();
              outp(0x3FB,0x80);       /* A 1 l'ultimo bit a sinistra  */
              switch(key) {
                    case 1:
                        outp(0x3F8,0x80);
                        outp(0x3F9,0x01);
                        break;
                    case 2:
                        outp(0x3F8,0x60);
                        outp(0x3F9,0x00);
                        break;
                    case 3:
                        outp(0x3F8,0x30);
                        outp(0x3F9,0x00);
                        break;
                    default:
                        puts("\nScelta errata");
                        break;
              }
        }
           


                                       159





        Linguaggio C per MS DOS - F. Bernardotti - 1987 Opus Free Soft






        Il  servizio 3 dell'interrupt 14H visto prima riportava lo  stato 
        della linea e del modem.
        La  stessa funzione puo' essere eseguita testando direttamente  i 
        due registri del 8250 che svolgono questo compito.


                               0x3FD  Stato linea

                        +---+---+---+---+---+---+---+---+
                        : 7 : 6 : 5 : 4 : 3 : 2 : 1 : 0 :
                        +---+---+---+---+---+---+---+---+
                          :   :   :   :   :   :   :   :
                          :   :   :   :   :   :   : Dato ricevuto
                          :   :   :   :   :   : Sovrapposizione
                          :   :   :   :   : Errore parita
                          :   :   :   : Errore di framing
                          :   :   : Break rivelato
                          :   : Registro memorizzazione TX vuoto
                          : Registro scorrimento TX vuoto
                        Timeout

         
        Uno bit a 1 indica che un determinato stato esiste.


                             0x3FE  Stato del modem

                        +---+---+---+---+---+---+---+---+
                        : 7 : 6 : 5 : 4 : 3 : 2 : 1 : 0 :
                        +---+---+---+---+---+---+---+---+
                          :   :   :   :   :   :   :   :
                          :   :   :   :   :   :   : Delta clear to send
                          :   :   :   :   :   : Delta data set ready
                          :   :   :   :   : Delta ring indicator
                          :   :   :   : Delta carrier detect
                          :   :   : Clear to send
                          :   : Data set ready
                          : Ring indicator
                        Carrier detect


        Oltre ai due registri precedenti, relativi allo stato della linea 
        e a quello del modem,  esistono due registri per il controllo  di 
        questi.

        Il  primo  lo abbiamo gia' visto e precisamente  quello  relativo 
        al controllo della linea.






                                       160





        Linguaggio C per MS DOS - F. Bernardotti - 1987 Opus Free Soft






        Vediamo ora il registro di controllo del modem.


                        0x3FC  Registro  controllo  modem
                       
                        +---+---+---+---+---+---+---+---+
                        : 7 : 6 : 5 : 4 : 3 : 2 : 1 : 0 :
                        +---+---+---+---+---+---+---+---+
                          0   0   0   :   :   :   :   :
                                      :   :   :   : DTR attivo
                                      :   :   : RTS attivo
                                      :   : OUT1 Non usato
                                      : OUT2 Deve essere 1 per
                                      : mandare interruzioni
                                      0 = Normale
                                      1 = Cortocircuito


        Gli  ultimi 3 bit sono forzati a 0 mentre il numero 4 deve essere 
        a 0 per trasmissioni normali sulla porta.
        Nel  caso  che per motivi di test si  voglia  cortocircuitare  la 
        porta bastera' metterlo ad 1 .
        In  questo  modo  ogni carattere trasmesso verra'  restituito  di 
        ritorno come se fosse stato ricevuto.
        Vediamo  ora  un esempio di utilizzo di questo registro  mediante 
        una  funzione  che  setta il DTR a on o ad  off  a  seconda   che 
        l'argomento passato sia 1 o 0.

                       
        set_dtr(stato)

        int stato;
        {
                char byte_on;
                char byte_of;
                byte_on=0x03;
                byte_of=0x00;
                if(stato)
                        outp(0x3FC,byte_on);
                else
                        outp(0x3FC,byte_of);
        }

        Esistono  ancora i registri di abilitazione e di  identificazione 
        interruzione che vedremo dopo il seguente esempio.
        Si tratta di un programmino che mostra l'utilizzo di quanto detto 
        fino  ad ora costituito da un modulo base che potrete voi  stessi 
        ampliare  con  funzioni per vari scopi  quale,  ad  esempio,  per 
        catturare o trasmettere un file ASCII.




                                       161





        Linguaggio C per MS DOS - F. Bernardotti - 1987 Opus Free Soft





        #include <stdio.h>


        #define LSR      0x3FD  /* Indirizzi registri 8250      */
        #define DLL      0x3F8
        #define MCR      0x3FC
        #define LCR      0x3FB
        #define DLM      0x3F9
        #define MSR      0x3FE

        #define CLS      puts("\33[2J")
        #define BEL      putchar('\007');

        char *msr=(char*)MSR;
        char *dlm=(char*)DLM;
        char *lcr=(char*)LCR;
        char *lsr=(char*)LSR;
        char *dll=(char*)DLL;
        char *mcr=(char*)MCR;

        int ind,baud,parity;

        main(argc,argv)
        int argc;
        char *argv[];
        {
             baud  =2400;
             CLS;
             puts("\33[3;7p");      /* Assegna al carettere 3 il 7  */
             set_dtr();
             puts("****** MTRM ******");
             puts("  Opus Free Soft");
             puts("******************");
             if(argc>1) {
                  switch(*argv[1]) {
                           case '1':
                                  puts("\n2400 bauds");
                                  baud = 2400;
                                  break;
                           case '2':
                                  puts("\n1200 bauds");
                                  baud = 1200;
                                  break;
                           case '3':
                                  puts("\n300 bauds");
                                  baud = 300;
                                  break;
                           default:
                                  puts("\n\nERRORE: Argomenti errati");
                                  puts("\nUso :  mtrm [bauds] ");

                                                              Segue....


                                       162





        Linguaggio C per MS DOS - F. Bernardotti - 1987 Opus Free Soft





                                  puts("       Es:  mtrm 1 ");
                                  puts("       bauds:   1 = 2400");
                                  puts("                2 = 1200");
                                  puts("                3 =  300");
                                  puts("\nDefault = 2400 bauds");
                                  exit(0);
                                  break;
                     }
              }
              baud_set(baud);
              parity_set();
              colloquia();
        }

        colloquia()         /* Ciclo ricevi/trasmetti                 */
        {
              int key;
              for(;;) {
                     while(!kbhit()) {       /* Finche nessun tasto.. */
                           ind = rx_char();  /* guarda se e' ricevuto */
                           if(ind != NULL)   /* un carattere          */
                               putchar(ind); /* Se si lo stampa       */
                     }
                     key = getch();          /* Se e' stato premuto   */
                     if(key == '\033')       /* guarda se e' ESC      */
                           exit(0);          /* Se si esce a DOS      */
                     tx_char(key);           /* se no lo trasmette    */
              }
        }

        parity_set()        /* Setta la par., dati,stop               */
        {
              outp(lcr,0x3A);                /* N,8,1                 */ 
        }

        rx_char()           /* Riceve un carattere         */
        {
              int util,key;
              if(((util=inp(lsr)) & 0x1E) != 0) {  /* Test per errore */
                     key = inp(dll);         /* C'e' un errore        */
                     return(NULL);           /* ritorna NULL          */
              }
              else
              if((util & 0x01) != 0) {
                     key = inp(dll);         /* Prende il carattere   */ 
                     return(key);            /* e lo ritorna          */
              }
              else
              return(NULL);                  /* Non e' stato ricevuto */
        }

                                                              Segue ....


                                       163





        Linguaggio C per MS DOS - F. Bernardotti - 1987 Opus Free Soft






        tx_char(var)        /* Trasmette un carattere                */
        char var;
        {
             register util;
             while(((util=inp(lsr)) & 0x20) == 0); /* Test reg. tx   */
             outp(dll,var);                   /* Trasmette il carat. */  
        }

        baud_set(speed)     /* Setta il baudrate           */
        {
             outp(lcr,0x80);       /* Setta bit 7 porta 0x3FB        */
             switch(speed) {
                     case 300:
                             outp(dlm,0x01);  /* MSB  300 bauds      */ 
                             outp(dll,0x80);  /* LSB  300 bauds      */
                             break;
                     case 1200:
                             outp(dlm,0x00);  /* MSB  1200 bauds     */ 
                             outp(dll,0x60);  /* LSB  1200 bauds     */
                             break;
                     case 2400:
                             outp(dlm,0x00);  /* MSB  2400 bauds     */
                             outp(dll,0x30);  /* LSB  2400 bauds     */
                             break;
                     default:
                     break;
              }
        }

        set_dtr()           /* Mette ad on il DTR                    */
        {
              char byte_on = 0x03;
              outp(mcr,byte_on);
        }

        Il commento iniziale "assegna il carattere 3 a 7" sara' risultato 
        oscuro.
        Si  tratta di un semplice metodo per assegnare al carattere ASCII 
        3 (CTRL C) il carattere 7 relativo al BEEP in modo da far si  che 
        battendo CTRL C non si esca dal programma.
        Per fare questo bisognera' invece battere ESC.

        Il  discorso  relativo  ai registri dedicati  all'abilitazione  e 
        all'identificazione  dell'interruzione e' particolare  in  quanto 
        permette  al programmatore di evitare di testare in continuazione 
        il  registro  di stato della linea per sapere se  un  determinato 
        evento si e' verificato o meno.
        Per  ora vedremo solo il funzionamento generale in quanto per  la 
        stesura di un programma che sfrutti questa particolarita' bisogna 
        avere  la  conoscenza  relativa al settaggio nella  tavola  degli 



                                       164





        Linguaggio C per MS DOS - F. Bernardotti - 1987 Opus Free Soft





        indirizzi  dei  servizi  di interrupt del  valore  relativo  alla 
        routine di gestione dell'interrupt stesso.
        Nei  capitoli precedenti abbiamo parlato del metodo  seguito  per 
        l'identificazione dell'indirizzo di una routine di servizio di un 
        interrupt.
        Mediante  l'opportuno settaggio di un registro del 8250  possiamo 
        attivare  o disabilitare le interruzioni associate a  particolari 
        eventi.
        Vediamo quali sono.


                    0x3F9 Registro abilitazione interruzioni

                        +---+---+---+---+---+---+---+---+
                        : 7 : 6 : 5 : 4 : 3 : 2 : 1 : 0 :
                        +---+---+---+---+---+---+---+---+
                          0   0   0   0   :   :   :   :
                                          :   :   : Dato pronto
                                          :   : Registro TX vuoto
                                          : Errore carattere ricevuto
                                        Cambiamento stato modem 

        Il registro che permette di identificare l'interruzione e' invece 
        il seguente.


                       0x3FA Identificazione interruzione

                        +---+---+---+---+---+---+---+---+
                        : 7 : 6 : 5 : 4 : 3 : 2 : 1 : 0 :
                        +---+---+---+---+---+---+---+---+
                          0   0   0   0   0   :   :   :
                                              :   :   0 = Interrupt
                                              :   :   1 = No interrupt
                                              ^   ^
                  Identificazione interruzione+---+

                                              0   0 Cambiamento stato mdm
                                              0   1 Registro TX vuoto
                                              1   0 Dato ricevuto
                                              1   1 Errore carattere RX

        Come  dicevamo,  parlando della gestione degli  interrupt,  viene 
        abbinata  a questi una priorita' per far si che il sistema possa, 
        in  caso  che  due o piu'  vengano  richiesti  conteporaneamente, 
        accodare  e quindi eseguire successiavamente quelle  a  priorita' 
        piu' bassa.
        Lo stesso discorso vale per questi appena visti.
        Errore  carattere  ricevuto   ha la  priorita'  piu'  alta,  dato 
        ricevuto la seconda,  trasmettitore pronto la terza e stato modem 
        la quarta. 



                                       165





        Linguaggio C per MS DOS - F. Bernardotti - 1987 Opus Free Soft





        L'esempio  riportato  precedentemente  non e' dei  piu'  corretti 
        perlomeno per quanto riguarda il settaggio di velocita' superiori 
        a 1200 baud.
        Il motivo e' che in ricezione potrebbero verificarsi degli errori 
        di  sovrapposizione  dei  caratteri in quanto  non  esiste  alcun 
        buffer  predisposto a conservare i caratteri ricevuti nel  mentre 
        che il programma e' intento ad assolvere altri compiti.
        La  soluzione del problema sta' appunto nella  programmazione  di 
        una routine d'interrupt che assolva a determinati compiti.
        In  altre  parole  quello eseguito dal  programma  esempio  viene 
        definito polling.
        Questo  consiste  in un ciclo in cui vengono svolte  le  seguenti 
        operazioni in modo ripetitivo.


        inizio:
                E' stato premuto un tasto ?
                Se si trasmetti il carattere
                Altrimenti
                         Guarda se e' stato ricevuto un carattere.
                         Se si controlla che non ci sia stato un errore
                               Se errore ritorna NULL
                               Altrimenti ritorna il carattere
                         Se non e' stato ricevuto nulla ritorna a inizio


        L'alternativa  sta'  appunto  nel  fare in modo  che  gli  eventi 
        controllati dal ciclo vengano eseguiti automaticamente a  seguito 
        di una richiesta di interruzione.
        La   routine   dell'interrupt   (0BH)  di   cui   abbiamo   visto 
        precedentemente  i  registri  di  controllo  e'  un  interruzione 
        hardware  e quindi prima dell'istruzione IRET deve finire con  le 
        istruzioni MOV AL,20H e OUT 20H,AL.
        Come   abbiamo  visto  prima  i  casi  che  possono  causare  un' 
        interruzione sono quattro.
        Questi  possono essere abilitati indipendentemente  oppure  anche 
        piu'di uno  contemporaneamente.
        Nel  secondo  caso la routine di gestione  dell'interrupt  dovra' 
        provvedere all'identificazione del tipo mediante il test eseguito 
        sull' apposito registro, anche questo visto prima.
        Anche  in questo caso la routine d'interruzione andrebbe  settata 
        con  una  call del Dos che ancora non abbiamo trattato ovvero  il 
        servizio 25H dell' interrupt 21H.
        Nella  schematizzazione successiva vengono distinti il  programma 
        principale dalla routine di servizio dell'interrupt.
        Il programma sara' quello che si incarica di eseguire l'input dei 
        caratteri da trasmettere, di analizzarli , di visualizzare i dati 
        e   di  controllare  il buffer di input per  vedere  se  ci  sono 
        all'interno   caratteri   inseriti  dalla   routine   d'interrupt 
        incaricata della ricezione.
        Quest'ultima  sara'  quella  che si  incarichera'  effettivamente 



                                       166





        Linguaggio C per MS DOS - F. Bernardotti - 1987 Opus Free Soft





        della   trasmissione dei caratteri inseriti nel buffer di  output 
        dal  programma principale,  dell'immagazzinamento  dei  caratteri 
        ricevuti correttamente nel buffer di input,  come dicevamo prima, 
        dell'intercettazione   del  cambiamento  di  stato   del   modem, 
        dell'individuazione di un errore di ricezione e della rilevazione 
        di uno stato di break.
        Ad ogni blocco corrisponde un azione intrappresa dalla routine di 
        gestione dell'interrupt.

                     Evento Interrupt       Azione intrappresa
                     --------------------------------------------------
                     TX pronto              Trasmetti carattere
                     Carattere ricevuto     Salva nel buffer
                     Stato modem cambiato   Testa e intrapprendi azione
                     Break ricevuto         Finisci comunicazione
                     Errore carattere       Segnala
              
        Programma
                                    +----------------------------+
                                    :    Input, salvataggio  e   :
                                    :       visualizzazione      :
                                    +----------------------------+
                                                         :    :
                                                         :    :
                                                         :    +------+
        Routine Interrupt                                :           :
                                                         :           :
        INT 0BH ----->+--------+    +----------+      +------+   +------+
                      :Analizza:    : TX ready :----->:buffer:   :buffer:
                +---->:tipo int:--->:          :<-----: OUT  :   :  IN  :
                :     +--------+    +----------+---+  +------+   +------+
                :        : : :                     :               ^  :
                :        : : :      +----------+   :               :  :
                :        : : +----->: RX data  :---:---------------+  :
                :        : :        :          :<--:------------------+
                :        : :        +----------+---+-------+
                :        : :                               :
                :        : :        +----------+           :
                :        : +------->:  Stato   :    +-------------+no
                :        :          :  modem   :--->: Altro INT ? :---->
                :        :          +----------+    +-------------+ IRET
                :        :                            ^    :si
                :        :          +----------+      :    :
                :        +--------->: Break  o :------+    :
                :                   :  errore  :           :
                :                   +----------+           :
                :                                          :
                +------------------------------------------+






                                       167





        Linguaggio C per MS DOS - F. Bernardotti - 1987 Opus Free Soft





        Un esempio di routine di gestione interrupt e' la seguente.
        Sulle  motivazioni per cui utilizzo un file .COM non diro'  nulla 
        per ora  e rimando il tutto ai capitoli in cui verra' trattata la 
        call relativa al settaggio di una routine d' interrupt.

        _text    segment   para 'code'
                 assume    cs:_text
                 org       100H
                 jmp       init        ;salta alla routine di settaggio
        ;
        new_int  proc      far         ;procedura servizio interrupt
        al_int:
                 in        al,03FAH    ;porta identificazione INT COM1          
                 and       al,110b     
                 cmp       al,2        ;se 0 = registro TX vuoto
                 jz        tx_char
                 cmp       al,4        ;se 0 = dato ricevuto
                 jz        rx_char
                 cmp       al,6        ;se 0 = errore dato ricevuto
                 jz        error
                 ....      ......      ;se arriva qui e' cambiato lo
                 ....      ......      ;stato del modem
                 jmp       short altro ;guarda se c'e'altro INT
        tx_char:
                 ....      ......      ;routine TX carattere
                 jmp       short altro ;salta a vedere se c'e un altro
        rx_char:                       ;interrupt pendente
                 ....      ......      ;routine ricezione carattere
                 jmp       short altro ;salta a controllo altro int
        error:
                 ....      ......      ;routine errore ricevuto
        altro: 
                 in        al,3FAH     ;la routine testa il primo bit
                 test      al,1        ;per vedere se c'e'un altro INT
                 jnz       al_int      ;se <> 0 allora c'e' un altro INT
                 mov       al,20H      ;se no fine int hardware
                 out       20H,al      
        fine     equ       $
                 iret                  ;e ritorna a programma
        new_int  endp
        ;
        init:                          ;abilita interrupt e setta routine
                 push      ds          ;di servizio interrupt
                 mov       dx,offset new_int
                 mov       ax,seg new_int
                 mov       ds,ax       ;setta offset e seg routine
                 mov       al,0BH      ;vettore int per COM1
                 mov       ah,25H      ;call SET INTERRUPT VECTOR
                 int       21H         ;dell'int 21H del DOS

                                                           Segue ....



                                       168





        Linguaggio C per MS DOS - F. Bernardotti - 1987 Opus Free Soft




        ;
        ;  Dopo  aver  settato  l'indirizzo  della  routine  di  servizio 
        ;  dell' interrupt   abilita   l' interruzione  della  porta   di 
        ;  comunicazione 
        ;

                 mov       al,0FH      ;1111 binario = tutte le inter.
                                       ;abilitate
                 out       03F9H,al    ;porta abilitazione interrupt
                 lea       dx,fine     ;offset fine routine interrupt
                                       ;che deve rimanere residente
                 pop       ds          ;ripristina ds salvato all'inizio
                                       ;della routine di settaggio 
                                       ;dell'interrupt
                 int       27H         ;termina e rimani residente
        ;
        _text    ends
                 end


        Come  avrete  notato,  a  parte la call 25H  dell'  int  21H,  vi 
        risultera' nuova anche la chiamata all'interrupt 27H.
        Anche questo verra' trattato successivamente.
        Per  ora  vi  accenno  solo che questo interrupt  permette  a  un 
        programma di terminare ma di rimanere residente in memoria.
        Il  discorso relativo alla trasmissione dati potrebbe  continuare 
        ancora  per  un  bel  pezzo  in  quanto  le  problematiche   sono 
        moltissime.
        Ultimamente con Sergio Villone e Giorgio Griffini stiamo cercando 
        di   portare   avanti  un  progetto  di  programma  di  BBS   con 
        caratteristiche innovative.
        Se  il tutto andra' avanti come si spera  e' facile che a  lavoro 
        compiuto  venga scritto un testo in cui verranno affrontate tutte 
        le problematiche.
        Oltre   alla  gestione  a  livello  hardware  dei  programmi   di 
        trasmissione esiste la pur complessa progettazione dei protocolli 
        destinati alla trasmissione binaria di programmi nei casi in  cui 
        sia necessaria una verifica dei dati.
        Protocolli  come  Xmodem,   Kermit,  Sealink  (TM),  Telink  ecc. 
        pretenderebbero  per  la descrizione della parte  algoritmica  un 
        notevole spazio.
        Man  mano che il tempo passa fanno comparsa nuovi protocolli  del 
        tipo degli Sliding Window.
        Alle  persone  interessate alla progettazione dei  protocolli  di 
        comunicazione  consiglio  uno dei volumi di Andrew  S.  Tanenbaum 
        intitolato   "Computer  Networks"  edito  dalla   Prentice   Hall 
        International.
        In  molti BBS italiani utilizzanti il software OPUS (Tm)  potrete 
        reperire  i  sorgenti del protocollo SEAlink (Tm) oltre  a  testi 
        recanti  le  caratteristiche di vecchi protocolli  quali  Xmodem, 
        Kermit ecc.




                                       169





        Linguaggio C per MS DOS - F. Bernardotti - 1987 Opus Free Soft





                           Interrupt di tastiera (16H)


        Questo  interrupt  svolge  alcuni  servizi  legati  all'input  da 
        tastiera.
        La modifica di questo costituisce uno dei metodi per la creazione 
        di   programmi   residenti   in   memoria   attivabili   mediante 
        l'intercettazione di un determinato tasto premuto.
        Di  questo  parleremo tra breve mentre per ora vediamo i  compiti 
        svolti.
        Come  per  gli  altri interrupts  i  servizi  sono  selezionabile 
        mediante l'opportuno settaggio di valore all'interno del registro 
        AH.


        AH = 0  Legge un carattere dalla tastiera


        Quando  questo servizio viene richiesto inputa un carattere dalla 
        tastiera del PC.
        Nel  caso che non ci sia nessun carattere a disposizione  aspetta 
        che ne venga inserito uno.
        Il seguente esempio ne mostra l'utilizzo.

        union REGS inregs, outregs; 
          
        inchar()
        {
                inregs.h.ah = 0x00;
                int86(0x16, &inregs, &outregs);
                return(outregs.h.al);
        }

        AL,  come  si sara' potuto notare,  contiene il codice principale 
        del carattere.
        AH potrebbe contenere il byte ausiliario.
        Nel caso che il tasto premuto sia,  ad esempio, un tasto funzione 
        allora AL conterra' 0 mentre AH il codice secondario di questo.
        Sono codici secondari i seguenti :

                              3      Carattere nullo (NUL)
                             15      Prima tabulazione
                             16-25   Alt - Q,W,E,R,T,Y,U,I,O,P
                             30-38   Alt - A,S,D,F,G,H,J,K,L
                             44-50   Alt - Z,X,C,V,B,N,M
                             59-68   Tasti funzione F1-F10
                             71      Home
                             72      Cursore in alto
                             73      Pg Up
                             75      Cursore a sinistra
                             77      Cursore a destra
                             79      End


                                       170





        Linguaggio C per MS DOS - F. Bernardotti - 1987 Opus Free Soft





                             80      Cursore in basso
                             81      Pg Dn
                             82      Ins
                             83      Del
                             84-93   Tasti funzione F11-F20 (Shift+Fx)
                             94-103  Tasti funzione F21-F30 (Ctrl +Fx)
                            104-113  Tasti funzione F31-F40 (Alt  +Fx)
                            114      Ctrl-PrtSc
                            115      Ctrl-cursore a sinistra
                            116      Ctrl-cursore a destra
                            117      Ctrl-End
                            118      Ctrl-PgDn
                            119      Ctrl-Home
                            120-131  Alt -1,2,3,4,5,6,7,8,9,0,-,=
                            132      Ctrl-PgUp


        AH = 1    Guarda se c'e' un carattere nel buffer


        Mentre il servizio precedente aspettava che ci fosse un carattere 
        in input dalla tastiera questo controlla solo la sua presenza.
        Ad indicarne la presenza  ci pensera' il flag di Zero.
        Se  il   flag e' a 0 significa che il carattere e' disponibile  e 
        quindi viene restituito nel registro AX mentre il  caso contrario 
        e cioe' il flag di Zero a 1 indichera' un assenza di input.
        Per  la  suddivisione  di  questo in AH e  AL  vedi  il  servizio 
        precedente.
        Una funzione di questo tipo e' utile per la scrittura di funzioni 
        quali  kbhit()  gia'  presente  nella  libreria  del  compilatore 
        Microsoft.


        AH = 2    Acquisisce lo stato dello Shift


        Il servizio riporta nel registro AL lo stato di shift.
        I  bit testabili per riconoscere lo stato della tastiera  sono  i 
        seguenti :

                        +---+---+---+---+---+---+---+---+
                        : 7 : 6 : 5 : 4 : 3 : 2 : 1 : 0 :
                        +---+---+---+---+---+---+---+---+
                          :   :   :   :   :   :   :   :
                          :   :   :   :   :   :   : Shift di destra ON
                          :   :   :   :   :   : Shift sinistra ON
                          :   :   :   :   : Ctrl ON
                          :   :   :   : Alt ON  
                          :   :   : Scroll lock ON
                          :   : Num lock ON
                          : Caps lock ON
                        Ins ON


                                       171





        Linguaggio C per MS DOS - F. Bernardotti - 1987 Opus Free Soft






        A indicare lo stato ON sara' il relativo bit a 1.
        Questo  valore  viene letto dal servizio dalla cella  di  memoria 
        0x417 relativa agli indicatori di stato della tastiera.

        Un  esempio  di routine atta ad indicare lo  stato,  ad  esempio, 
        dell' insert e' :


        /*
         * Insert.c
         *
         * Riporta 0 se lo stato del tasto insert e' OFF
         *         1 se e' ON
         */


        char far *status = 0x00400017;

        insert()
        {
           int result;
           result = 128;
           result &= *status;
           return(result ? 1 : 0);
        }


        Il  puntatore *status viene inizializzato a puntare al  segmento, 
        offset  della locazione dove sono conservati i bit indicanti  gli 
        stati dei vari tasti.
        Eseguendo  un operazione di AND con 128 (10000000) si puo' sapere 
        lo stato del tasto insert.
        Eseguendo  operazioni  di AND con altri valori si  puo'  risalire 
        allo  stato  di ogni singolo tasto elencato con il  servizio  02H 
        dell'interrupt 16H. 
        Esiste  anche  la  locazione 0040:0018  che  indica  altri  stati 
        relativi a tasti shift , Ctrl-Num-Lock ecc.
        Possiamo  schematizzare  mediante due tabelle i tasti di  cui  e' 
        possibile testare lo stato:
         

                 0040:0017       bit      Tasto      Se == 1
                                  7       Insert     Insert 'ON'
                                  6       CapsLock   CapsLock 'ON'
                                  5       NumLock    NumLock 'ON'
                                  4       ScrollLock ScrollLock 'ON'
                                  3       Alt shift  Tasto premuto
                                  2       Ctrl shift   "      "
                                  1       Left shift   "      "
                                  0       Right shift  "      "
           


                                       172





        Linguaggio C per MS DOS - F. Bernardotti - 1987 Opus Free Soft




                 0040:0018       bit      Tasto        Se == 1
                                  7       Insert       Tasto premuto
                                  6       CapsLock       "      "
                                  5       NumLock        "      "
                                  4       ScrollLock     "      "
                                  3       Ctrl_Numlock  Stato 'ON'

        La modifica di questo vettore di interruzione costituisce uno dei 
        metodi per la scrittura di programmi residenti in memoria.
        Non  si parla ancora di programmi in grado di richiamare funzioni 
        esterne  in  quanto il richiamo di queste   dall'interno  di  una 
        routine  di servizio di un interrupt presenta alcuni problemi non 
        facili da risolvere.
        Sarebbe molto facile modificare il vettore di interruzione  della 
        tastiera  in modo che questo non legga solo il carattere  premuto 
        ma che controlli anche il suo codice e nel caso che questo sia il 
        tasto da noi aspettato  richiami  una determinata routine.
        Un piccolo esempio scritto in assembler su cui si potra' lavorare 
        per evolverlo e' il seguente.  
        In  pratica il programma modifica il vettore di interrupt 16H per 
        far si che il carattere inputato venga controllato per vedere  se 
        corrisponde a CTRL A.
        In  caso  affermativo controlla un flag  che,  mediante  apposito 
        settaggio, indica lo stato del DTR.
        Se questo risulta disattivato lo attiva e viceversa.

        _TEXT SEGMENT    PUBLIC
              assume     cs:_text,ds:_text  ;assume CS e DS
              org        100H               ;origine a 100H per .COM 
        start:
              jmp        init               ;salta all' inizializzazione
        old_k dd         0                  ;conterra' vecchio vettore
        flag  db         0                  ;flag DTR
        ;
        k_int proc far
              assume     cs:_text, ds:_text
              sti                           ;attiva interrupt                     
              or         ah,ah              ;e'una richiesta di lettura?
              jnz        ki2                ;se no salta al vecchio vet.
              pushf                         ;simula una chiamata 
              assume     ds:nothing         ;
              call       old_k              ;di interrupt
              cmp        al,01H             ;e' CTRL A ?
              jne        ki1                ;se no ritorna dall'interrupt
              mov        dx,3FCH            ;metti in DX reg. cont.modem
              cmp        flag,01H           ;e' il flag DTR a 1 ?
              jne        off                ;se no vai a off
              mov        flag,00H           ;se si metti flag a 0
              mov        ax,00H             ;metti valore DTR OFF in AX
              out        dx,ax              ;e setta la porta
              mov        al,01H             ;rimetti CTRL A in AL
              jmp        ki1                ;ritorna dall'interrupt



                                       173





        Linguaggio C per MS DOS - F. Bernardotti - 1987 Opus Free Soft




        off:  
              mov        flag,01H           ;se DTR ON allora metti a 0
              mov        ax,03H             ;AX = DTR attivo
              out        dx,ax              ;setta la porta 3FC
              mov        al,01H             ;metti CTRL A in AL
        ki1:
              iret                          ;ritorna dall'interrupt     
        ki2:
              assume     ds:nothing      
              jmp        old_k              ;chiama vecchio vettore
        ;
        k_int endp
        ;
        init:
              mov        bx,cs                     
              mov        ds,bx      
        ;
              mov        al,16H             ;interrupt di cui si vuole
              mov        ah,35H             ;l'indirizzo con call 35H
              int        21H                ;dell'interrupt 21H
              mov        word ptr old_k,bx  ;mette l'indirizzo ottenuto
              mov        word ptr old_k[2],es ;nella variabile old_k
        ;
              mov        bx,cs         
              mov        ds,bx        
              mov        dx,offset k_int    ;mette in DX l'indirizzo
              mov        al,16H             ;del nuovo vettore 16H che
              mov        ah,25H             ;viene settato con call 25H
              int        21H                ;dell'interrupt 21H
        ;
              mov        bx,cs           
              mov        ds,bx          
              mov        dx,offset init     
              int        27H                ;termina ma rimani residente
        ;
        _TEXT ENDS
              END START


        Di  alcuni  servizi dell'interrupt 21 ne avevamo  solo  accennato 
        qualche cosa parlando del programma in C che riportava i segmenti 
        e gli offset dei vettori di interrupts.
        Per ora solo un altro accennno in quanto ne parleremo piu' avanti 
        in modo dettagliato.
        La  call  35H dell'interrupt 21H riporta in ES:BX il  segmento  e 
        l'offset  di un interrupt specificato in AL prima della  chiamata 
        dello stesso.
        La call 25H invece setta il segmento e l'offset di un interrupt.
        Nel  programma  precedente abbiamo prima  preso  l'indirizzo  del 
        vecchio  vettore  dell'interrupt 16H e lo abbiamo  salvato  nella 
        variabile  old_k e dopo abbiamo settato con l'indirizzo  relativo 
        alla nostra procedura il riferimento al nuovo interrupt.



                                       174





        Linguaggio C per MS DOS - F. Bernardotti - 1987 Opus Free Soft





        Vedremo piu' avanti come e' possibile scrivere una procedura come 
        questa in linguaggio C.
          


                              Gestione dischi (13H)



        A livello di BIOS la gestione dei dischi, per tutte le operazioni 
        riguardanti  la  lettura,  la scrittura,  la formattazione  e  la 
        verifica,  viene eseguita dall'interrupt 13H selezionando come al 
        solito il servizio da svolgere mediante il registro AH.
        In  questo  caso altri registri dovranno,  come  vedremo,  essere 
        settati  con gli opportuni parametri indicanti,  ad  esempio,  il 
        drive interessato, la testina ecc.
        Vediamo i servizi e i registri interessati alle varie operazioni.

        AH = 0     Resetta il disco


        Serve a ricalibrare il dischetto per iniziare un servizio.
        Puo'  essere utilizzato anche quando si e' verificato  un  errore 
        prima di ripartire con un ulteriore tentativo.
        Coinvolge  solo  il  drive senza  influenzare  effettivamente  il 
        dischetto inserito in questo.


        AH = 1     Acquisisce lo stato del dischetto


        Mediante  questo  servizio e' possibile avere restituito un  byte 
        che indica lo stato del dischetto.
        Questo  byte  viene restituito in AL e puo' assumere  i  seguenti 
        valori :


                  Valore     Stato indicato
                  ---------------------------------------------
                  128        Timeout del lettore
                   64        Spostamento su una traccia fallito
                   32        Errore del controller
                   16        Cattivo CRC
                    9        Errore margine DMA
                    8        Errore DMA
                    4        Settore errato
                    3        Errore protezione da scrittura
                    2        Indirizzo marcato errato
                    1        Comando errato





                                       175





        Linguaggio C per MS DOS - F. Bernardotti - 1987 Opus Free Soft




        AH = 2    Lettura settori disco

        In  questo  servizio  iniziamo a vedere  l'utilizzo  degli  altri 
        registri.
        Riportero' una sola volta la mappa di utilizzo dei vari  registri 
        senza piu' specificarla in seguito.

              Registro   Scopo                  NOTE
              -----------------------------------------------------
              DL         Numero drive (0-3)     Nessuna
              DH         Facciata (0-1)         Nessuna
              CH         Traccia (0-39)         Nessuna
              CL         Settore (1-8)          Non usato da format
              AL         Numero settori         Non usato da format
              ES:BX      Indirizzo buffer       Non usato da verify

        Come dicevo,  se non specificato diversamente nelle note,  questi 
        registri sono utilizzati da tutti i servizi che stiamo vedendo.
        Lo scopo penso che sia sufficentemente chiaro a parte la copia di 
        registri ES:BX di cui parleremo.
        Nelle  operazioni  di  lettura  bisogna  creare  una  memoria  di 
        transito  in  cui  il sistema depositera' i dati durante  le  sue 
        operazioni.
        Il  registro  ES conterra' l'indirizzo del  segmento  relativo  a 
        questa memoria mentre BX conterra' il suo offset.
        Un  altro punto comune ai vari servizi riguarda il flag del carry 
        che normalmente e' a 0.
        Uno stato a 1 successivo a uno di questi servizi indica un errore 
        dell'operazione.
        Penso  che  vi  ricordiate che uno  dei  membri  della  struttura 
        WORDREGS dichiarata in dos.h e' appunto il flag di carry (cflag).
        Vedremo  l'utilizzo  mediante un esempio dopo aver parlato  della 
        funzione di formattazione di una traccia.
        E' interessante notare che l'interrupt 1E ha il vettore contenuto 
        all'indirizzo 78H (1E * 4).
        Questo  punta  alla locazione 522H in cui sono contenuti 10  byte 
        che riguardano determinati parametri del disco.
        Questi sono utilizzati per le operazioni su disco.

        Indirizzo    Scopo                                        Default
        -----------------------------------------------------------------
        522 bit 7-4  Passi con incrementi di tempo di 2 ms.       D0
        522 bit 0-3  Tempo scarico testina                        0F
        523          Tempo caricamento testina                    02
        524          Tempo per lo spegnimento del motore          25
        525          Byte per settore (0=128,1=256,2=512,3=1024)  02 
        526          Settori per traccia                          09
        527          Lunghezza gap tra due settori                2A
        528          Lunghezza dei dati                           FF
        529          Lunghezza gap formattato                     50
        52A          Byte riempimento formattazione               F6
        52B          Tempo di arresto della testina               0F
        52C          Tempo di avvio del motore                    02


                                       176





        Linguaggio C per MS DOS - F. Bernardotti - 1987 Opus Free Soft





        Questi   valori   sono   settabili  per   ottenere   ad   esempio 
        formattazioni  inconsuete o per creare programmi di  format  piu' 
        veloci, come vedremo tra breve.

        Vediamo  ora  un esempio che legge i settori  della  directory  e 
        mostra il contenuto in esadecimale e in ASCII.

        /* Readdir.c - F. Bernardotti
         */

        #include <stdio.h>
        #include <dos.h>
        #include <malloc.h>

        union REGS inregs, outregs;

        struct SREGS segregs;

        unsigned char far *buffer;

        char *calloc();

        main()
        {
           int n;
           buffer = calloc(2048,sizeof(char));
           inregs.x.bx = FP_OFF(buffer);
           segregs.es  = FP_SEG(buffer);
           inregs.h.dl = 0x00;   /* Drive  A:  */
           inregs.h.dh = 0x00;   /* Head       */
           inregs.h.ch = 0x00;   /* Track      */
           inregs.h.cl = 0x06;   /* Sector     */
           inregs.h.al = 0x04;   /* Num. sect. */
           inregs.h.ah = 0x02;   /* Funct.read */

           int86x(0x013,&inregs,&outregs,&segregs);
           puts("Funzione read con INT 13H");

           puts("Disk Directory Esa -----------------\n");
           for(n=0;n!=2048;n++)
              printf("%02x  ",*buffer++);

           buffer -= 2048;

           puts("Disk Directory Char -----------------\n");
           for(n=0;n!=2048;n++)
              printf("%c",*buffer++);
        }


        Potreste  modificare l'esempio in modo da poter leggere qualsiasi 
        settore del disco.


                                       177





        Linguaggio C per MS DOS - F. Bernardotti - 1987 Opus Free Soft





        Specificando come codice disco 80H farete in modo che il servizio 
        sia riguardante l'hard disk.
        Sinceramente non mi sento di portare esempi in quanto per poterlo 
        fare dovrei sperimentarli sul mio hard (!!!).


        AH = 3       Scrive un settore o piu' su disco


        Anche    per   questo   servizio   valgono   i   registri   visti 
        precedentemente. 


        AH = 4       Verifica i settori del dischetto


        Il servizio esegue il controllo ciclico di rindondanza (CRC)  per 
        scoprire  se  esistono  errori nei dati  registrati  nei  settori 
        specificati.
        Anche  in  questo caso i registri sono gli stessi utilizzati  per 
        gli  altri servizi a parte ES:BX che non viene settato in  quanto 
        inutile per il verify.


        AH = 5       Formatta una traccia 


        Il  servizio  merita  due parole in quanto  alcuni  dei  registri 
        precedentemente    trattati   non  vengono   utilizzati   ma   in 
        particolar  modo  si  fa'  dell'area  puntata  da  ES:BX  un  uso 
        particolare.
        ES:BX deve puntare ad un area in cui sono memorizzati i marcatori 
        di settore.
        Questi  sono  gruppi di 4 byte per ogni settore della traccia  in 
        cui vengono inseriti il numero di traccia (C), la testina (H), il 
        numero del settore (R) e il numero di byte per settore (N).
        Se  si vuole formattare,  ad esempio,  la traccia 1 faccia 1 a  9 
        settori per traccia si dovra' impostare ES:BX a puntare a :


                  CHRN CHRN CHRN CHRN CHRN CHRN CHRN CHRN CHRN
        ES:BX     0112 0122 0132 0142 0152 0162 0172 0182 0192 
                  ---- ---- ---- ---- ---- ---- ---- ---- ----
        Settore    00   01   02   03   04   05   06   07   08


        Questo lavoro deve essere eseguito per ogni traccia.
        E'  possibile anche eseguire,  a scopi di protezione dei  dischi, 
        delle  formattazioni  con  i numeri di  settore  all'interno  dei 
        marcatori errati o non in ordine crescente.
        Per  il servizio di format e' possibile anche alterare  i  valori 
        relativi ai dieci bytes visti in precedenza (Loc. 522).


                                       178





        Linguaggio C per MS DOS - F. Bernardotti - 1987 Opus Free Soft




        Vediamo  ora  un  programma  che esegue la  formattazione  di  un 
        dischetto a 360K e a 320K.
        Il tempo impiegato e' meno della meta' di quello del format IBM.
        Il  programma  l'ho  tradotto in C e modificato da  un  programma 
        uplodato  nel BBS da Giorgio Griffini scritto originariamente  in 
        Turbo Pascal e Assembler dallo stesso.

        #include <stdio.h>
        #include <dos.h>
        #define AT(x,y)    printf("\33[%d;%dH", x, y) /* Macro         */
        #define CLS        puts("\33[2J");
        #define FLASH      puts("\33[5m");
        #define NORM       puts("\33[0m");

        union REGS inregs, outregs;

        struct SREGS segregs;

        unsigned char table[37];      /* Tavola CHRN                   */  
        unsigned char disktable[12];  /* Tavola parametri disco        */
        unsigned char sector[512];    /* Matrice contenente boot       */    

        char far  *tab = table;       /* Puntatore far a table         */
        char far  *dle = disktable;   /* a disktable e a sector per    */
        char far  *sct = sector;      /* utilizzare macro FP_SEG/OFF   */ 
        char bootmsg[255];            /* Messaggio no boot             */

        unsigned  dto, dts;           /* Offset e segmento tavola disco*/

        int  drive;                   /* Disco A: o B:                 */
        int  size;                   
        int  status;                  /* Flag di errore                */

        main(argc,argv)
        int argc;
        char *argv[];
        {
           int   key;
           drive = 0;
           size  = 1;
           set_cur();
           ol_table();

           if(argc > 1) {
              for(key=1;key != argc;key++) {
                 if(strcmp(argv[key],"B:") == 0 || strcmp(argv[key],"b:") 
        == 0)
                    drive = 1;
                 if(strcmp(argv[key],"/s") == 0 || strcmp(argv[key],"/S") 
        == 0)
                    size  = 0;
              }
           }


                                       179





        Linguaggio C per MS DOS - F. Bernardotti - 1987 Opus Free Soft



           init();
        }

        init()         /* Cicli traccia, side                          */
        {
           register track, side;
           int key;
           status= 0;
           CLS;
           puts("FAST FORMAT 1.0  by  F. Bernardotti");
           puts("(C) Copyright Opus Free Soft   1987");
           puts("Public Domain Software");
           printf("\nInsert a new disk  to format  into  drive  ");
           FLASH;
           AT(6,43);
           printf("%c:\33[1A", 65+drive);
           NORM;
           puts("\nand press any  key to start or ESC to abort.");
           key = getch();
           if(key == '\033') {
              puts("\n\nFormat aborted by operator");
              exit(0);
           }
           AT(9,1);
           printf("Formatting track ->");
           disk_reset();
           setdtab();
           disktable[8] = 0x00;
           disktable[10]= 0x04;
           for(track=0;track!=40;track++) {
              AT(9,21);
              printf("%02d", track);
              for(side=0;side != size+1;side++) {
                 mk_table(track,side);
                 format(track,side);
                 disktable[10]= 0x00;
                 if(status==1) {
                    puts("\n\nUnable to format diskette.");
                    resetdtab();
                    abort();
                 }
              }
              if(track==0) {
                 disktable[8] = 0xF6;
                 AT(9,21);
                 printf(" *");
                 writesysblock();
                 if(status==1) {
                    puts("\n\nUnable to write boot");
                    resetdtab();
                    abort();
                 }
              }
           }


                                       180





        Linguaggio C per MS DOS - F. Bernardotti - 1987 Opus Free Soft




           resetdtab();
           puts("\n\n<FORMAT COMPLETE>\n");
           printf("Format another diskette (y/n) ? ");
           key = getch();
           if(key == 'Y' || key == 'y') init();
           CLS;
        }

        writesysblock()      /* Scrive traccia 0                       */   
        {
           setupfat();
           if(status==0)
              setupboot();
        }

        ol_table()           /* Vecchi parametri tavola disco          */
        { 
           dto = 0x0522;
           dts = 0x0000;
           disktable[0]  = 0xDF;
           disktable[1]  = 0x02;
           disktable[2]  = 0x25;
           disktable[3]  = 0x02;
           disktable[4]  = 0x09;
           disktable[5]  = 0x2A;
           disktable[6]  = 0xFF;
           disktable[7]  = 0x50;
           disktable[8]  = 0xF6;
           disktable[9]  = 0x0F;
           disktable[10] = 0x02;
        }

        format(track,side)   /* Formatta tr/si specificati come arg.   */ 
        int track,side;
        {
           register retry;
           retry = 3;      /* Come dice IBM prova tre volte al massimo */
           do {
              inregs.h.ah = 0x05;
              inregs.h.dl = drive;
              inregs.h.dh = side;
              inregs.h.ch = track;
              inregs.h.cl = 0x01;
              inregs.h.al = 0x09;
              segregs.es  = FP_SEG(tab); 
              inregs.x.bx = FP_OFF(tab);
              int86x(0x13,&inregs,&outregs,&segregs);
              status = outregs.x.cflag;
              if(status != 0) {
                 disk_reset();
                 --retry;
              }



                                       181





        Linguaggio C per MS DOS - F. Bernardotti - 1987 Opus Free Soft





              else
                 retry = 0;
           } while(retry != 0);
        }

        write_sector(numsect)  /* Scrive con INT 26 un settore         */
        int numsect;
        {
           segregs.ds = FP_SEG(sct);
           inregs.x.bx= FP_OFF(sct);
           inregs.x.cx= 0x01;
           inregs.x.dx= numsect;
           inregs.h.al= drive;
           int86x(0x26,&inregs,&outregs,&segregs);
           status=outregs.x.cflag;
        }

        setdtab()              /* Setta la tavola disco in disktable   */ 
        {
           inregs.h.ah = 0x25;
           inregs.h.al = 0x1E;
           inregs.x.dx = FP_OFF(dle);
           segregs.ds  = FP_SEG(dle);
           intdosx(&inregs, &outregs, &segregs);
        }

        setupfat()         /* Marca sulla il tipo di disco             */ 
        {
           clrsector();
           if(size == 0) 
              sector[0] = 0xFF;
           else
              sector[0] = 0xFD;
           sector[1] = 0xFF;
           sector[2] = 0xFF;
           write_sector(1);
           if(size == 1)
              write_sector(3);
        }

        resetdtab()         /* Ripristina vecchia tavola disco        */
        {
           inregs.h.ah = 0x25;
           inregs.h.al = 0x1E;
           inregs.x.dx = dto;
           segregs.ds  = dts;
           intdosx(&inregs, &outregs, &segregs);
        }






                                       182





        Linguaggio C per MS DOS - F. Bernardotti - 1987 Opus Free Soft





        clrsector()         /* Azzera 512 elementi di sector           */
        {
           register key;
           for(key=0;key!=512;key++)
              sector[key] = 0;
        }

        setupboot()         /* Setta  il settore del boot              */
        {
           register key;
           clrsector();
           strcpy(bootmsg,"\007\n\rThis disk has not boot.");
           strcat(bootmsg,"\n\rPress any key to restart...");
           for(key = 0;key != strlen(bootmsg)+1;key++) 
              sector[0x80+key] = bootmsg[key];

           sector[0] = 0xEB;
           sector[1] = 0x29;

           strcpy(bootmsg,"CFORMAT ");
           for(key = 0;key != strlen(bootmsg)+1;key++)
              sector[0x03+key] = bootmsg[key];

           if(size==1) {
              sector[11] = 0x00;
              sector[12] = 0x02;
              sector[13] = 0x02;
              sector[14] = 0x01;
              sector[15] = 0x00;
              sector[16] = 0x02;
              sector[17] = 0x70;
              sector[18] = 0x00;
              sector[19] = 0xD0;
              sector[20] = 0x02;
              sector[21] = 0xFD;
              sector[22] = 0x02;
              sector[23] = 0x00;
              sector[24] = 0x09;
              sector[25] = 0x00;
              sector[26] = 0x02;
              sector[27] = 0x00;
              sector[28] = 0x00;
              sector[29] = 0x00;
           }

           sector[43] = 0xFA;
           sector[44] = 0x33;
           sector[45] = 0xC0;
           sector[46] = 0x8E;
           sector[47] = 0xD0;
           sector[48] = 0xBC;
           sector[49] = 0x00;


                                       183





        Linguaggio C per MS DOS - F. Bernardotti - 1987 Opus Free Soft





           sector[50] = 0x7C;
           sector[51] = 0x16;
           sector[52] = 0x1F;
           sector[53] = 0xBE;
           sector[54] = 0x80;
           sector[55] = 0x7C;
           sector[56] = 0xAC;
           sector[57] = 0x0A;
           sector[58] = 0xC0;
           sector[59] = 0x74;
           sector[60] = 0x09;
           sector[61] = 0xB4;
           sector[62] = 0x0E;
           sector[63] = 0xBB;
           sector[64] = 0x07;
           sector[65] = 0x00;
           sector[66] = 0xCD;
           sector[67] = 0x10;
           sector[68] = 0xEB;
           sector[69] = 0xF2;
           sector[70] = 0x32;
           sector[71] = 0xE4;
           sector[72] = 0xCD;
           sector[73] = 0x16;
           sector[74] = 0xCD;
           sector[75] = 0x19;

           sector[510]= 0x55;
           sector[511]= 0xAA;

           write_sector(0);
        }

        disk_reset()          /* Resetta il controller                */
        {
           inregs.h.ah = 0x00;
           int86(0x13,&inregs,&outregs);
        }

        mk_table(track,side)  /* Crea marcatori di traccia  CHRN      */
        int track,side;
        {
           register sect, s;
           s = 0;
           for(sect=1;sect!=10;sect++) {
              table[s++] = track;
              table[s++] = side;
              table[s++] = sect;
              table[s++] = 0x02;
           }
        }



                                       184





        Linguaggio C per MS DOS - F. Bernardotti - 1987 Opus Free Soft





        set_cur()       /* Setta il cursore a 0 di dimensioni          */
        {
           inregs.h.ah=0x01;
           inregs.h.cl=0x13;
           inregs.h.ch=0x13;
           int86(0x10,&inregs,&outregs);
        }


        Il  programma  memorizza in una matrice la  vecchia  tabella  dei 
        parametri   del   disco  per  poi  modificare  il   decimo   byte 
        (disktable[10]) per metterlo a 0.
        La  funzione setupboot serve a inizializzare la tabella dei  dati 
        da  registrare nell'area di boot mediante un interrupt di cui non 
        abbiamo parlato prima e precisamente del 26H.
        L'interrupt  25H  (Absolute Disk Read) e il  26H  (Absolute  Disk 
        Write)  costituiscono  due metodi per trasferire il controllo  al 
        DOS  BIOS  per  quanto  riguarda operazioni  di  scrittura  e  di 
        lettura.
        Prendiamo ad esempio il 25H.
        I registri interessati a questa operazione sono :

        AL = Numero del drive (0=A:, 1=B: ecc.)
        CX = Numero dei settori da leggere
        DX = Settore logico d'inizio

        DS:DX = Indirizzo memoria di trasferimento.

        Se  in uscita dall'interrupt il flag di carry e' a zero significa 
        che l'operazione ha avuto successo.
        Se questo si trova invece ad 1 significa che c'e' stato un errore 
        il cui codice sara' testabile all'interno del registro AX.
        La parte alta (AH) contiene il codice di errore del DOS mentre la 
        parte bassa (AL) contiene uno dei seguenti valori :

                    80H  Il drive non risponde
                    40H  Operazione di posizionamento fallita
                    08H  Cattivo CRC
                    04H  Settore richiesto non trovato
                    03H  Disco protetto in scrittura
                    02H  Altro tipo di errore non elencato

        L'interrupt  26H svolge l'operazione di scrittura invece  che  di 
        lettura come il 25H.
        Valgono  per questo i registri e i codici di errore riportati  in 
        uscita per l'interrupt 25H.








                                       185





        Linguaggio C per MS DOS - F. Bernardotti - 1987 Opus Free Soft





        Nei  capitoli  successivi  tratteremo la struttura  di  un  disco 
        parlando della FAT e  dell' organizzazione della  directory.
        Colgo  l'occasione  portata dall'esempio precedente  per  parlare 
        di come e' strutturato il  record di boot.
        Si  sarebbe  potuto  optare per una trattazione unica  di  quanto 
        riguarda l'organizzazione logica del disco.
        Il  problema e' dovuto al fatto che se non si parlasse  a  questo 
        punto  di  come  e'  strutturato il record  di  boot  gran  parte 
        dell'esempio  rimarrebbe oscuro. 
        Infatti,  come avrete notato, una funzione del programma serve al 
        settaggio dei parametri relativi a questo settore.
        Il  record di boot occupa 1 settore del dischetto e  precisamente 
        il primo.
        In  questo settore e' contenuto un breve programma che serve  per 
        il  caricamento  del  sistema operativo che varia  leggermente  a 
        seconda del formato (in genere la prima parte occupa i byte 0,  1 
        e 3).
        Oltre a cio' si trovano nel record di boot delle informazioni del 
        Bios che servono a controllare il disco stesso.

        L'offset di questi dati e' a partire dal byte 4 e precisamente:


        Byte       Lunghezza      Descrizione
        -----------------------------------------------------------------

          4            8          Identificatore di sistema
         12            2          Numero di byte per settore
         14            1          Numero settori per cluster
         15            2          Numero settori riservati boot
         17            1          Numero copie FAT
         18            2          Numero voci nella directory
         20            2          Numero dei settori su disco
         22            1          ID formato (FF, FE ...Vedi avanti FAT)
         23            2          Numero settori FAT
         25            2          Numero settori per traccia
         27            2          Numero dei lati del disco
         29            2          Numero settori speciali


        Il settore di boot e' sempre presente indipendentemente dal fatto 
        che sul disco sia presente il sistema operativo o meno.
        Nel  caso che si tenti di caricare il dos da un disco su cui  non 
        e'  presente sara' compito del boot visualizzare un messaggio  di 
        errore.
          
        Terminiamo  questa  panoramica sui servizi riguardante  i  dischi 
        parlando di alcune porte che riguardano questo argomento.






                                       186





        Linguaggio C per MS DOS - F. Bernardotti - 1987 Opus Free Soft





                        0x3F2  Controllo del controllore

        Vediamo una descrizione degli 8 bit di questo registro.

                        +---+---+---+---+---+---+---+---+
                        : 7 : 6 : 5 : 4 : 3 : 2 : 1 : 0 :
                        +---+---+---+---+---+---+---+---+
                          :   :   :   :   :   :   :   :
                          :   :   :   :   :   : Selezione drive
                          :   :   :   :   :   :   0   0  = A
                          :   :   :   :   :   :   0   1  = B
                          :   :   :   :   :   :   1   0  = C
                          :   :   :   :   :   :   1   1  = D
                          :   :   :   :   :   0 = reset controllore
                          :   :   :   :   0 = sconnessione dal BUS
                          :   :   :   :   1 = abilitazione interruz.
                          :   :   :   :       e richieste DMA
                          :   :   :   1 = abilitazione motore A
                          :   :   1 = abilitazione motore B
                          :   1 = abilitazione motore C
                          1 = abilitazione motore D

        Penso che lo schema possa essere sufficentemente chiaro.
        Questa porta e' possibile settarla.


                          0x3F4   Stato del controllore


        Mediante  questo  registro  e' possibile acquisire lo  stato  del 
        controllore.
        Un determinato evento e' indicato da uno stato alto (1) sui  vari 
        bit.

                        +---+---+---+---+---+---+---+---+
                        : 7 : 6 : 5 : 4 : 3 : 2 : 1 : 0 :
                        +---+---+---+---+---+---+---+---+
                          :   :   :   :   :   :   :   :
                          :   :   :   :   :   :   : Drive a in modo SEEK
                          :   :   :   :   :   : Drive b in modo SEEK
                          :   :   :   :   : Drive c in modo SEEK
                          :   :   :   : Drive d in modo SEEK
                          :   :   : Comando in esecuzione
                          :   : Modo non DMA
                          : Direzione dati dal controller al processore
                        Pronto a comunicare al controller

        C'e'  un  termine di cui non abbiamo mai visto il  significato  e 
        precisamente DMA (Direct Memory Access).
        Vedremo,  dopo la descrizione della seguente porta,  di accennare 
        a qualche informazione riguardante quest'ultimo.



                                       187





        Linguaggio C per MS DOS - F. Bernardotti - 1987 Opus Free Soft





        L'interrupt  13H,  per l'esecuzione dei suoi servizi,  sfrutta la 
        porta 0x3F5.
        Il  settaggio in questo registro dei seguenti valori  corrisponde 
        alla funzione descritta sul lato :

                        0x02 = Lettura traccia
                        0x03 = Specifica SRT,HUT,HLT,DMA
                        0x04 = Riporta stati del drive
                        0x05 = Scrittura dati
                        0x06 = Lettura dati
                        0x07 = Ricalibrazione
                        0x08 = Stato interruzioni
                        0x09 = Scrittura dati cancellati
                        0x0A = Lettura ID
                        0x0C = Lettura dati cancellati
                        0x0D = Formattazione traccia
                        0x0F = SEEK testina
                        0x11 = Ricerca per uguale
                        0x19 = Ricerca per minore o uguale
                        0x1D = Ricerca per maggiore o uguale


        Parlavamo prima del DMA.
        Dal suo stesso nome e' facile capire che si tratta di sistema  di 
        accesso diretto in memoria.
        In molte operazioni di trasferimento dati, ad esempio tra memoria 
        e dispositivi veloci di memorizzazione, il processore puo' essere 
        completamente escluso e il controllo delle operazioni viene preso 
        dal  DMA che in pratica potremmo considerarlo come  un  ulteriore 
        blocco del sistema hardware visto precedentemente.
        Infatti  la  tecnica  di accesso diretto in memoria  permette  la 
        gestione di un trasferimento veloce di dati fra la stessa memoria 
        interna del sistema e le periferiche di I/O.
        Un controllore DMA,  in genere,  per ogni linea gestita  possiede 
        tre registri.
        Un registro di indirizzo che contiene in ogni istante l'indirizzo 
        della  prossima locazione di memoria che deve essere  trasferita, 
        un  contatore che contiene il numero di parole che devono  essere 
        ancora  trasferite  e  un  registro  di  stato  che  segnala   la 
        condizione del dispositivo.
        In  pratica il processore 8088/86 possiede un piedino di HOLD che 
        se  portato  ad un livello opportuno trasmette una  richiesta  di 
        bus.
        In questo caso,  dopo aver terminato il ciclo corrente,  si mette 
        in una fase in cui sospende le sue operazioni fino alla rimozione 
        del segnale da parte del controller.
        Il  PC IBM possiede quattro canali di DMA per i quali valgono  le 
        seguenti porte per il loro controllo.
        Uno  dei  canali del DMA serve per il "rinfresco"  della  memoria  
        RAM  che  altro non e' che una continua lettura  e  scrittura  di 
        questa  allo  scopo  di  evitare la  perdita  delle  informazioni 
        contenute.


                                       188





        Linguaggio C per MS DOS - F. Bernardotti - 1987 Opus Free Soft





        Le  RAM dinamiche,  infatti,  possono mantenere solo per un breve 
        tempo  le  informazioni  e quindi  questa  operazione  si  rivela 
        indispensabile.
        La  porta  0x000  (Registro  di indirizzo  del  canale  0)  viene 
        utilizzata  appunto  per  questo  scopo e  cioe'  il  refresh  di 
        memoria.
        La  porta 0x001 (Contatore di parola del canale 0) e' impostato a 
        0xFFFF (64 K) per il rinfresco di memoria.
        L'integrato  controllore  dell'accesso  diretto  in  memoria   e' 
        siglato 8237.
        Il  canale  1  di questo non viene utilizzato dal  PC  in  quanto 
        questo non supporta il trasferimento da memoria a memoria.
        Il registro 0x004 (Registro indirizzi del canale 2) e' utilizzato 
        per  i trasferimenti dei dati dai dischetti mentre il 0x005 e' il 
        contatore di parola dello stesso canale.
        I  registri  0x006  e 0x007 sono i corrispondenti  del  canale  0 
        relativi  al canale 3 utilizzato per trasferimenti tra memoria  e 
        disco fisso.
        La  lettura  sulla porta 0x008 riporta lo  stato  del  controller 
        mentre la sua scrittura imbastisce un comando per questo.
        Il  chip  8237  considera a priorita' in 4 canali  assegnando  al 
        canale 0 la priorita' piu' alta mentre al 3 quella piu' bassa.
        Il  discorso  delle  priorita' diventa complesso  se  trattato  a 
        livello hardware.
        Infatti le priorita' possono essere fisse o rotanti.
        Nell'ultimo  caso  il  canale appena  servito  diventa  quello  a 
        priorita' piu' bassa.
        La  lettura  del  registro  di stato e di  comando  (0x008)  puo' 
        indicare :


                        +---+---+---+---+---+---+---+---+
                        : 7 : 6 : 5 : 4 : 3 : 2 : 1 : 0 :
                        +---+---+---+---+---+---+---+---+
                          :   :   :   :   :   :   :   :
                          :   :   :   :   :   :   : terminato canale 0
                          :   :   :   :   :   : terminato canale 1
                          :   :   :   :   : terminato canale 2
                          :   :   :   : terminato canale 3
                          :   :   : richiesta canale 0
                          :   : richiesta canale 1
                          : richiesta canale 2
                        richiesta canale 3


        Come  dicevo prima la scrittura su questa porta costituisce anche 
        un modo per inviare un comando relativo al controller del DMA.
        Questo viene inizializzato a 0x00.






                                       189





        Linguaggio C per MS DOS - F. Bernardotti - 1987 Opus Free Soft




                        +---+---+---+---+---+---+---+---+
                        : 7 : 6 : 5 : 4 : 3 : 2 : 1 : 0 :
                        +---+---+---+---+---+---+---+---+
                          :   :   :   :   :   :   :   :
                          :   :   :   :   :   :   : Non usato
                          :   :   :   :   :   : Non usato
                          :   :   :   :   : Abilita il controllore
                          :   :   :   : Scansione del tempo (*)
                          :   :   : Priorita' (*)
                          :   : Ultima stampa
                          : DREQ alto
                        DACK basso

        (*) E' consigliato non modificarli

        E'  possibile abilitare o disabilitare i canali del DMA  settando 
        in modo opportuno il registro di maschera.
        La porta che si occupa di questo e' la 0x00A e la descrizione dei 
        sui bit e' la seguente :

                        +---+---+---+---+---+---+---+---+
                        : 7 : 6 : 5 : 4 : 3 : 2 : 1 : 0 :
                        +---+---+---+---+---+---+---+---+
                          :   :   :   :   :   :   :   :
                          + Non utilizzati+   :   0   0 = canale 0
                                              :   0   1 = canale 1
                                              :   1   0 = canale 2
                                              :   1   1 = canale 3
                                              1 = attiva bit di maschera
                                              0 = azzera bit di maschera

        Esistono altri registri che si interessano del DMA ad esempio :

                           0x0B Registro di modalita'

                        +---+---+---+---+---+---+---+---+
                        : 7 : 6 : 5 : 4 : 3 : 2 : 1 : 0 :
                        +---+---+---+---+---+---+---+---+
                          :   :   :   :   :   :   :   :
                          :   :   :   :   :   :   0   0 = canale 0
                          :   :   :   :   :   :   0   1 = canale 1
                          :   :   :   :   :   :   1   0 = canale 2
                          :   :   :   :   :   :   1   1 = canale 3  
                          :   :   :   :   0   0 = verifica
                          :   :   :   :   0   1 = scrittura
                          :   :   :   :   1   0 = lettura
                          :   :   :   1 = reinizializzazione auto.
                          :   :   0 = incremento indirizzo
                          :   :   1 = secremento indirizzo
                          0   0 = modalita' demand
                          0   1 =    "      singola
                          1   0 =    "      blocchi  
                          1   1 =    "      cascata


                                       190





        Linguaggio C per MS DOS - F. Bernardotti - 1987 Opus Free Soft





        Nel  caso  del PC viene utilizzata la modalita' singola per  ogni 
        canale.
        Come  vedremo  in seguito l'interrupt 21H del DOS ci  mettera'  a 
        disposizione  molti  servizi specifici per lavorare sui file  del 
        disco.



                          Gestione stampante (INT 17H)


        L'interrupt   che   ora  vedremo  e'  quello  che   gestisce   le 
        comunicazioni con la stampante.
        Le funzioni svolte sono esattamente tre.

        AH  = 0    Stampa il carattere presente in AL e ritorna in AH  lo 
                   stato del servizio.  In altre parole se di ritorno  AH 
                   contiene  1  significa che il carattere non  e'  stato 
                   stampato.

        AH  = 1    Inizializza  la porta della stampante.  AH ritorna  lo 
                   stato.

        AH  = 3    Il  servizio  tre riporta lo stato della stampante  in 
                   AH. L'interpretazione degli 8 bit e' la seguente.

                        +---+---+---+---+---+---+---+---+
                   AH   : 7 : 6 : 5 : 4 : 3 : 2 : 1 : 0 :
                        +---+---+---+---+---+---+---+---+
                          :   :   :   :   :   :   :   :
                          :   :   :   :   :   :   : Time out
                          :   :   :   :   :  Non usati
                          :   :   :   :   1 = I/O error
                          :   :   :   1 = select
                          :   :   1 = out of paper
                          :   1 = acknowledge
                          1 = not busy
                              
        Legate agli adattatori per stampanti parallele troviamo anche tre 
        porte.

               Stampante parallela                                       
          Prima      Seconda      Terza                Scopo             

          0x3BC      0x378        0x278   Dati in uscita dalla stampante
          0x3BD      0x379        0x279   Registro di stato 
          0x3BE      0x37A        0x27A   Registro di controllo   

        Le   porte   0x3BC/0x378/0x278   contengono  i   dati   leggibili 
        indirizzati alla stampante.
        Ogni  bit del registro equivale a uno degli otto bit del dato  in 
        uscita.


                                       191





        Linguaggio C per MS DOS - F. Bernardotti - 1987 Opus Free Soft





        Le  porte  0x3BD/0x379/0x279 corrispondono al registro  di  stato 
        della  stampante  mediante  le quali  e'  possibile  ricavare  le 
        condizioni di questa.
        Il significato di ogni bit del registro e' il seguente :


                        +---+---+---+---+---+---+---+---+
                        : 7 : 6 : 5 : 4 : 3 : 2 : 1 : 0 :
                        +---+---+---+---+---+---+---+---+
                          :   :   :   :   :   :   :   :
                          :   :   :   :   :   :   :   1 = Timeout
                          :   :   :   :   : Non usati
                          :   :   :   :   0 = Errore
                          :   :   :   :   1 = Normale
                          :   :   :   0 = Non in linea
                          :   :   :   1 = In linea
                          :   :   0 = Carta OK
                          :   :   1 = Fine della carta
                          :   0 = Segnale di riconoscimento
                          :   1 = Normale
                          0 = Busy (occupata)
                          1 = Libera


        Le porte 0x3BE e quelle relative al secondo e al terzo adattatore 
        stampante si incaricano del controllo della stampante.


                        +---+---+---+---+---+---+---+---+
                        : 7 : 6 : 5 : 4 : 3 : 2 : 1 : 0 :
                        +---+---+---+---+---+---+---+---+
                          :   :   :   :   :   :   :   :
                          Non usati   :   :   :   :   0 = Normale
                                      :   :   :   :   1 = Dati in uscita
                                      :   :   :   0 = Nessun cambio linea
                                      :   :   :       automatico
                                      :   :   :   1 =  Cambio linea aut.
                                      :   :   0 = Inizializza stampante
                                      :   :   1 = Impostazione normale
                                      :  Sempre a 1
                                      0 = Interrupt disabilitati
                                      1 = IRQ7 abilitato

        Come   nel  caso  delle  funzioni  di  controllo  legate  ad  una 
        determinata periferica, viste in precedenza, anche in questo caso 
        ne  esistono alcune legate all' INT 21H del Dos che permettono di 
        gestire i files che debbono essere stampati.
        Oltre  a queste esiste un ulteriore  interrupt,  precisamente  il 
        2FH, che si interessa della stampante.
        Vedremo tutti nei capitoli riguardanti le function calls del Dos.




                                       192





        Linguaggio C per MS DOS - F. Bernardotti - 1987 Opus Free Soft






        Prima  di  terminare l'argomento riguardante la stampante  ancora 
        due parole sui codici di controllo.
        In  Linguaggio C come per gli altri linguaggi potete utilizzare i 
        codici  di  comando  delle  stampanti  per  eseguire  determinati 
        settaggi.
        Riporto  i  seguenti  codici che  potranno  essere  inviati  alla 
        stampante mediante la macro SETPRINT.

        #define SETPRINT(x)   putc(x,stdprn)

        Ad ogni invio di un codice corrisponde una chiamata del tipo

        SETPRINT(27); ecc.


        Paper Movements


        10       Line feed
        11       Tab vertically
        12       Form feed
        13       Carriage return
        27,56    Ignore paper end
        27,57    Cancel ignor paper end
        27,66    Set vertical tabs
        27,78    Set skip perforation
        27,79    Cancel skip perforation


        Print Head Movements


        8        Backspace
        9        Tab horizontally
        27,60    Move print head to left
        27,68    Set horizontal tabs
        27,80    Proportional spacing ON/OFF
        27,85    Unidirectional print ON/OFF


        Line/Character Spacing


        27,48    1/8 inch line spacing
        27,49    7/72 "     "     "
        27,50    1/6  "     "     "
        27,51    Variable line feed (n/216)
        27,65    Variable line feed (n/72)
        27,67    Set page lenght




                                       193





        Linguaggio C per MS DOS - F. Bernardotti - 1987 Opus Free Soft






        Fonts


        11       15 char per inch ON
        14       Double width print ON
        15       Compressed print ON
        18       Compressed print OFF
        20       Double width print OFF
        27,45    Underline ON/OFF
        27,69    Emphasized print ON
        27,70    Emphasized print OFF
        27,71    Double strike print ON
        27,72    Double strike print OFF
        27,83    Subscript/superscript ON
        27,84    Subscript/superscript OFF


        Special character


        27,54    Select set 1
        27,55    Select set 2


        Graphics Modes


        27,75    480 dot bit image graphics
        27,76    960 dot bit image graphics
        27,89    960 dot normal speed
        27,90    1920 dot bit image graphics


        Miscellaneous


        7        Bell
        17       Select printer
        19       Deselect printer
        24       Clear buffer













                                       194





        Linguaggio C per MS DOS - F. Bernardotti - 1987 Opus Free Soft






                            Gestione MOUSE (INT 33H)


        Ed  eccoci  al  primo  degli  interrupts  non  documentati  dalla 
        Microsoft.
        L'interrupt 33H gestisce tutto quello che riguarda il mouse,  una 
        delle  periferiche  che  stanno avendo sempre  piu'  applicazioni 
        all'interno dei nuovi programmi.
        WINDOW (Tm) della Microsoft e' appunto uno di quei package in cui 
        l'uso del mouse e' importantissimo se non indispensabile.
        Le  coordinate  sul video del mouse possono  essere  calcolate  a 
        seconda del settaggio dello screen mediante i seguenti calcoli.

        Modo             Coordinate

        40x25 CO & BW    x = 16 * colonna, y = 8 * riga
        80x25 CO & BW    x = 8  * colonna, y = 8 * riga
        320x200          x = 2  * coordinata x, y = coordinata y
        640x200          x = coordinata x     , y = coordinata y
        Monocromatico    x = 8 * colonna, y = 8 * riga
        EGA & 3270       x = coordinata x, y = coordinata y

        Riporto i seguenti servizi relativi all'interrupt 33H interessati 
        nella gestione del mouse.
        Li ho riportati a tipo schede per una facile consultazione.

         
        Call      : 00H
        Scopo     : Check if mouse is installed

        In ingresso :
        AX = 00H
        In uscita   :
        AX = -1 se il mouse e' installato, 0 in caso negativo
        BX = Numero dei bottoni 


        Call      : 03H
        Scopo     : Get mouse position

        In ingresso :
        AX = 03H
        In uscita   :
        BX = Stato dei pulsanti
                     Bit 0 = 1 se pulsante sinistro premuto
                     Bit 1 = 1 se pulsante destro premuto
        CX = Coordinata X
        DX = Coordinata Y





                                       195





        Linguaggio C per MS DOS - F. Bernardotti - 1987 Opus Free Soft





        Call      : 04H
        Scopo     : Set mouse position

        In ingresso :
        AX = 04H
        CX = Nuova coordinata X
        DX = Nuova coordinata Y


        Call      : 07H
        Scopo     : Set mouse X bounds

        In ingresso :
        AX = 07H
        CX = Limite minimo X
        DX = Limite massimo X


        Call      : 08H
        Scopo     : Set mouse Y bounds
         
        In ingresso :
        AX = 08H
        CX = Limite minimo Y
        DX = Limite massimo Y


        Call      : 09H
        Scopo     : Set graphics cursor

        In ingresso :
        AX = 09H
        BX = Posizione centrale X
        CX = Posizione centrale Y
        ES:DX = Puntano alla maschera cursore.


        Call      : 0AH
        Scopo     : Set text cursor

        In ingresso :
        AX = 0AH
        BX = 0 per selezionare attributo cursore
             1 per settare tipo cursore
        CX = Maschera schermo o linea iniziale di scansione
        DX = Maschera cursore o linea finale   di scansione








                                       196





        Linguaggio C per MS DOS - F. Bernardotti - 1987 Opus Free Soft





        Call      : 01H
        Scopo     : Make mouse cursor displayed

        In ingresso :
        AX = 01H


        Call      : 02H
        Scopo     : Make mouse cursor not displayed

        In ingresso :
        AX = 02H


        Call      : 0BH
        Scopo     : Determine number of phisical positions moved.

        In ingresso :
        AX = 0BH
        In uscita   : 
        CX  =  Numero  di posizioni su X mosse dal ultima  chiamata  alla 
               funzione 0BH
        DX  =  Numero di posizioni su Y mosse dal  ultima  chiamata  alla 
               funzione 0BH


        Call      : 0FH
        Scopo     : Set physical to screen movement ratios.

        In ingresso :
        AX = 0FH
        CX = Numero di posizioni fisiche per indicare un cambio di 8 X
        DX = Numero di posizioni fisiche per indicare un cambio di 8 Y
        NOTA: I valori iniziali sono X=8 Y=16 


        Call      : 0DH
        Scopo     : Set light pen emulation

        In ingresso :
        AX = 0DH


        Call      : 0EH
        Scopo     : Stop light pen emulation

        In ingresso :
        AX = 0EH

        Mediante  questi  servizi potrete creare nei vostri programmi  le 
        apposite opzioni dedicate alla gestione video mediante mouse.



                                       197





        Linguaggio C per MS DOS - F. Bernardotti - 1987 Opus Free Soft





                      Gestione Memoria Estesa (EMM INT 67H)


        Un  altro interrupt non documentato dalla Microsoft  riguarda  la 
        gestione della memoria estesa.
        L'  AT Ibm puo' superare come quantita di memoria i 640 Kbytes in 
        cui era normalmente relegato il vecchio PC.
        Ultimamente anche per quanto riguarda quest' ultimo sono comparse 
        sul mercato delle schede per l'espansione a oltre 2 Mbytes.
        Personalmente  sul   PC  che ho utilizzato per  la  scrittura  di 
        questo  testo  ho  installato una scheda Flash Pack  AST  per  la 
        velocizzazione  dei  processi e un espansione, sempre AST, con su 
        2 Mbytes di memoria.
        L'interrupt che si interessa della gestione della memoria  estesa 
        e' il 67H.
        Anche in questo caso i servizi li riporto a tipo scheda.
        Ad  essere sinceri ho utilizzato questo modo per   rappresentarli 
        in quanto ho eseguito una lettura dai dati di un programma che ho 
        scritto per la documentazione di questi  interrupts.
        Per  non  riscriverli  ho optato per il  mantenimento  di  questo 
        formato  che dopo tutto non risulta neppure essere  malvagio  per 
        una facile consultazione.

        Call      : 40H
        Scopo     : Check expanded memory status

        In ingresso : 
        AH = 40H
        In uscita   :
        AH = Codice d'errore. (128 129 e 132), 0 se tutto OK.


        Call      : 41H
        Scopo     : Get window location

        In ingresso : 
        AH = 41H
        In uscita   :
        AH = Codice d'errore. (128 129 e 132)
        BX = Segmento dove parte la finestra.
        NOTA: La prima finestra e' all'offset 0, la seconda a 4000H ecc.


        Call      : 42H
        Scopo     : Determine free & total expanded memory pages 

        In ingresso : 
        AH = 42H
        In uscita   :
        AH = Codice d'errore. (128 129 e 132)
        BX = Numero di pagine libere
        DX = Numero totale di pagine


                                       198





        Linguaggio C per MS DOS - F. Bernardotti - 1987 Opus Free Soft




        Call      : 43H
        Scopo     : Allocate expanded memory pages

        In ingresso :
        AH = 43H
        BX = Numero pagine da allocare
        In uscita   :
        AH = Codice d'errore. (128 129 132 133 135 136 e 137)
        DX = Handle


        Call      : 44H
        Scopo     : Get expanded memory page

        In ingresso :
        AH = 44H
        AL = Numero window (0 - 3)
        BX = Pagina da prendere
        DX = Handle
        In uscita   :
        La   pagina  data  indirizzabile  mediante  la  locazione   della 
        finestra.
        AH = Codice d'errore. (128 129 131 132 o 134)


        Call      : 45H
        Scopo     : Free expanded memory

        In ingresso :
        AH = 45H
        DX = Handle del blocco da liberare
        In uscita   :
        AH = Codice d'errore. (128 129 131 132 o 134)


        Call      : 46H
        Scopo     : Get version number of EM software driver

        In ingresso :
        AH = 46H
        In uscita   :
        AH = Codice d'errore. (128 129 e 132)
        BX = Numero versione.


        Call      : 4BH
        Scopo     : Determine number of active handles.

        In ingresso :
        AH = 4BH
        In uscita   :
        AH = Codice d'errore. (128 129 131 e 132)
        BX = Numero di handles attivi. BH = 0


                                       199





        Linguaggio C per MS DOS - F. Bernardotti - 1987 Opus Free Soft






        Call      : 4CH
        Scopo     : Determine block size

        In ingresso :
        AH = 4CH
        DX = Handle
        In uscita   :
        AH = Codice d'errore. (218 129 131 e 132)
        BX = Numero di pagine allocate per l'handle


        Call      : 4DH
        Scopo     : Get array of all handle sizes

        In ingresso :
        AH = 4DH
        ES:DI = Puntano all'area dove   deve essere salvato il risultato.  
                La  grandezza deve essere (4 * num_handle_attivi)  bytes. 
                Mai piu' di 1 Kbyte.
        In uscita   :
        AH = Codice d'errore. (128 128 129 e 132)
        ES:DI = Puntano all'area con  le  informazioni.


        Call      : 47H
        Scopo     : Save expanded memory board status

        In ingresso :
        AH = 47H
        DX = Handle al quale si vuole associare  lo stato.
        In uscita   :
        AH = Codice d'errore. (128 129 131 132 e 140)


        Call      : 48H
        Scopo     : Restore expanded memory status

        In ingresso :
        AH = 48H
        DX = Handle con cui era stato salvato lo stato.
        In uscita   :
        AH = Codice d'errore. (128 129 131 132 e 142)

        Come  avrete  potuto  notare  ad  ogni  servizio  dell'  int  67H 
        corrispondono   alcuni  codici  d'errore  che  potrebbero  essere 
        restituiti dalla call stessa.
        L'elenco di questi e' il seguente.






                                       200





        Linguaggio C per MS DOS - F. Bernardotti - 1987 Opus Free Soft







        128 - Malfunction in EM softw.     129 - Malfunction in EM hard

        131 - Invalid handle               132 - Invalid function code

        133 - No available EMM handles     134 - Page  mapping   context 
                                                 error.

        135 - Not enough exp.memory pages  136 - Not enough free  memory
                                                 pages.

        137 - Can't allocate 0 pages       138 - Request greater than the
                                                 number      of     pages 
                                                 allocated to the handle.

        139 - The  phisichal memory page   140 - No  room   to  save  the 
              to which the handles  page         the   expanded    memory
              is mapped is invalid.              board status.

        141 - Expanded memory board status 142 - No status information is
              information already associa-       associated   with   this 
              ted with this handle number.       handle number.

        143 - Invalid subfunction.



        Nella  creazione  di software con la possibilita' di  vedere  una 
        memoria  estesa  testate  sempre prima  di  richiamare  qualsiasi 
        funzione  destinata a questa la call relativa alla verifica della 
        presenza di una scheda EMM.
        Potrete  trovare maggiori specifiche sul "Lotus  Intel  Microsoft 
        Expanded Memory Specification".
        In  alcuni  casi  la  memoria  estesa  puo'  assumere  dimensioni 
        notevoli.

        Sempre  portando ad esempio la scheda che utilizzo  personalmente 
        e' possibile installarne fino a 4 per un totale di oltre 8 Mbyte.
        Questa  potrebbe  essere configurata sia come EMM che  come  hard 
        disk RAM.
        Molti pacchetti software in commercio,  Symphony (Tm) per fare un 
        nome, vedono gia' la memoria estesa.
        Concludiamo con questo il discorso per passare all' interrupt del 
        Bios per la gestione dello schermo.

                             







                                       201





        Linguaggio C per MS DOS - F. Bernardotti - 1987 Opus Free Soft





                            Gestione video (INT 10H)


        Parlando  delle  sequenze  di escape per il controllo  del  video 
        avevo  rimandato il proseguimento del discorso  alla  trattazione 
        dell'interrupt 10H che e' quello che presiede a tutte le funzioni 
        BIOS relative alla gestione dello schermo.
        I servizi svolti dall'interrupt sono molti e lo stesso dicasi per 
        quanto  riguarda le porte che svolgono la gestione del controller 
        video.
        Questo per dire che sara' un paragrafo "intenso" di argomenti.
        La  gestione  del  video e' un argomento delicato  in  quanto  le 
        possibilita'  date  all'utente sono complesse e in  alcuni  casi, 
        dicono, anche pericolose.
        C'e' chi si chiedera' cosa significa "dicono".
        Mi  pare  di  aver  letto  una volta  qualche  cosa  relativa  al 
        settaggio di alcuni registri del controller.
        Si  diceva,  a  proposito,  che l'uso incauto di  questi  avrebbe 
        potuto danneggiare il video e il controller stesso.
        Sinceramente  posso  dire  di aver  provato  qualsiasi  sorta  di 
        settaggio  riguardante  lo schermo senza che mi sia mai  capitato 
        qualche  inconveniente grave se non quello di dover resettare  il 
        sistema per poter riiniziare il lavoro.
        Esistono  in  commercio  molti tipi di  controller  destinati  al  
        video.
        I piu' comuni,  quelli che sicuramente tutti conoscete,  sono  il 
        monocromatico,  la  CGA  (Color Graphics Adapter),  la EGA  e  la 
        Hercules.
        Originariamente  il  vecchio PC IBM nasceva con in  dotazione  la 
        scheda monocromatica.
        Questa  era  orientata  alla gestione dei testi  in  quanto,  pur 
        disponendo  di  un  ottima risoluzione per  quanto  riguardava  i 
        caratteri, non aveva la possibilita' di gestire la grafica.
        La Hercules e' possibile considerarla un estensione della  scheda 
        monocromatica  in quanto ha la possibilita' di gestire la grafica 
        ad una risoluzione di pixel maggiore di quella della CGA.
        Chiaramente   questa  differenza  di  risoluzione  porta  ad   un 
        incompatibilita' dei programmi destinati alla CGA con quelli  per 
        la Hercules.
        Personalmente,  sul  computer  che uso per  lavoro,  utilizzo  la 
        Hercules  in  quanto  non avendo l'abitudine di  usare  giochi  o 
        programmi grafici  i vantaggi offerti da questa sono notevoli.
        Il  discorso non e' poi' cosi' categorico per quanto riguarda  la 
        disponibilita' di programmi grafici che supportano la Hercules.
        I  maggiori  programmi reperibili in commercio  dispongono  della 
        possibilita'  di  essere  configurati su questa vedi  ad  esempio 
        ACAD, SYMPHONY, LOTUS ecc.
        Esistono schede installabili su PC dedicate alla grafica ad  alta 
        risoluzione.
        Purtroppo  dati  i costi relativi alla scheda,  al software e  al 
        monitor dedicato non sono di uso comune.



                                       202





        Linguaggio C per MS DOS - F. Bernardotti - 1987 Opus Free Soft





        Possedendo  una  scheda  CGA avremo a  disposizione  le  seguenti 
        possibilita' di configurazione :


                           40x25        Testo bw
                           40x25        Testo 16 colori
                           80x25        Testo bw
                           80x25        Testo 16 colori
                         320x200        Grafica bw
                         320x200        Grafica 4 colori
                         640x200        Grafica bw


        Una nota particolare la merita l' Olivetti M24.
        Questo oltre ai modi appena visti possiede un ulteriore modalita' 
        e precisamente il modo grafico 640x400.
        La  scheda  Hercules possiede,  oltre al  modo  testo  80x25,  la 
        modalita' grafica 720x348 pixel.
        Penso  che  non sia il caso di dilungarmi con la  spiegazione  di 
        termini come ad esempio pixel in quanto sicuramente sono tutti al 
        corrente del  significato.
        Secondo  la modalita' video selezionata il controller ci mette  a 
        disposizione  di un certo numero di buffer di schermo normalmente 
        definite pagine.
        Il numero di queste riferite alle caratteristiche del video  sono 
        le seguenti :


                     40x25    Testo BW e colore    8 pagine
                     80x25    Testo BW e colore    4 pagine
                   320x200    Grafica BW e colore  1 pagina
                   640x200    Grafica BW e colore  1 pagina
                   720x348    Hercules             2 pagine


        Penso  che  vi ricordiate che quando ho parlato del suffisso  far 
        avevo portato un esempio di come scrivere direttamente sul  video 
        della CGA.
        L'inizializzazione

                           char far *var = 0xB8000000;

        era relativa al buffer principale della scheda CGA.
        Nel caso del video monocromatico questo buffer e' posizionato nel
        segmento 0xB000.
        Parlando di buffer del video bisogna fare una precisazione.
        Si potrebbe anche pensare che scrivendo direttamente in locazione 
        consecutive  si possa ottenere come risultato la  visualizzazione 
        della stringa voluta.





                                       203





        Linguaggio C per MS DOS - F. Bernardotti - 1987 Opus Free Soft





        Questo  non e' vero in quanto le celle di memoria che fanno parte 
        del  buffer  di  schermo hanno fondamentalmente  due  compiti  ed 
        esattamente :

              +-----------+-----------+-----------+-----------+
              : carattere : attributo : carattere : attributo : ecc.
              +-----------+-----------+-----------+-----------+
                
        I  byte di numero pari contengono il codice del carattere  mentre 
        quelli di numero dispari gli attributi.
        I bytes di attributo vengono interpretati come segue :

                               Video monocromatico

                        +---+---+---+---+---+---+---+---+
                        : 7 : 6 : 5 : 4 : 3 : 2 : 1 : 0 :
                        +---+---+---+---+---+---+---+---+
                          :   :   :   :   :   :   :   :
                          :   :   :   :   :   R   G   B
                          :   :   :   :   :  Primo  piano  
                          :   :   :   :   1 = intensita' alta
                          :   R   G   B
                          :     Sfondo
                          1 = lampeggiante

        Le combinazioni possibili su RGB sono :

                        (1)  RGB bit 6,5,4 = Sfondo
                        (2)  RGB bit 2,1,0 = Primo piano

                    +---(1)---+    +---(2)---+
                    R    G    B    R    G    B
                    0    0    0    0    0    0  Nero su nero
                    0    0    0    0    0    1  Sottolineato
                    0    0    0    1    1    1  Normale
                    1    1    1    0    0    0  Reverse

        Nel  caso  dell'adattatore colore/grafica  l'interpretazione  del 
        byte di attributo e' sempre la stessa solo che valgono i seguenti 
        colori.

                           R    G    B
                           +----+----+
                           0    0    0      Nero
                           0    0    1      Blu
                           0    1    0      Verde
                           0    1    1      Blu chiaro
                           1    0    0      Rosso
                           1    0    1      Porpora
                           1    1    0      Arancio
                           1    1    1      Bianco



                                       204





        Linguaggio C per MS DOS - F. Bernardotti - 1987 Opus Free Soft




        Faccio   notare  che  RGB  sono  le  iniziali  dei   tre   colori 
        fondamentali che possono comporre i vari colori.
        Le  dimensioni  della  pagina video per ogni  modalita'  sono  le 
        seguenti :

                          40x25     Testo BW         800H
                          40x25     Testo 16 col.    800H
                          80x25     Testo BW        1000H
                          80x25     Testo 16 col.   1000H
                        320x200     Grafica BW      4000H
                        320x200     Grafica 4 col.  4000H
                        640x200     Grafica BW      4000H
                                    Hercules        8000H

        A questo punto iniziamo a vedere i servizi dell'interrupt 10H.
        Come  per  tutti gli altri il numero del servizio legato  ad  una 
        certa funzione si ottiene settando in AH il valore corrispondente 
        alla funzione stessa e precisamente :


        AH = 0  Setta il modo video

        Il valore relativo al tipo di schermo va' inserito in AL.

        AL = 0  40x25   BW               AL = 1  40x25   Colore
        AL = 2  80x25   BW               AL = 3  80x25   Colore
        AL = 4  320x200 Colore           AL = 5  320x200 BW
        AL = 6  640x200 BW               AL = 7  Monocromatico
        AL = 13 16 colori media ris.EGA  AL = 14 16 colori alta ris. EGA
        AL = 15 grafica monocrom.   EGA  AL = 16 Super high graphics EGA
        AL = 48 3270 graphics            AL = 72 640x400 Olivetti


        Un esempio di utilizzo :

        #include <dos.h>

        union REGS inregs, outregs;

        setta()
        {
             inregs.h.ah = 0x00;
             inregs.h.al = 0x01;   /* Setta a 40x25 colore */
             int86(0x10,&inregs,&outregs);
        }
          

        AH = 1  Setta il tipo di cursore

        Permette  di  settare  il  tipo di cursore  stabilendo  la  linea 
        d'inizio e quella di fine.
        Cosa si intende per riga ?



                                       205





        Linguaggio C per MS DOS - F. Bernardotti - 1987 Opus Free Soft





        Ogni  carattere  che compare sullo schermo e'  costruito  su  una 
        matrice di punti nel seguente modo :

                              0 1 2 3 4 5 6 7
                           0  . . . X . . . .
                           1  . . X X X . . .
                           2  . X X . X X . .
                           3  . X X . X X . .            
                           4  . X X X X X . .
                           5  . X X . X X . .
                           6  . X X . X X . .
                           7  . . . . . . . .

        Il cursore viene costruito sulla stessa matrice.
        Specificando in CH la posizione di partenza (riga) e in CL quella 
        di  arrivo  si puo' fare in modo che il cursore sia piu'  o  meno 
        evvidente  (al  limite  si puo' fare in modo che  non  compaia  a 
        video).

        #include <dos.h>

        union REGS inregs, outregs;

        set_cur()
        {
           inregs.h.ah=0x01;
           inregs.h.cl=0x13;
           inregs.h.ch=0x13;
           int86(0x10,&inregs,&outregs);
        }

        Nell'esempio   precedente   il   cursore  viene   fatto   sparire 
        specificando  una  linea di partenza e di arrivo in  effetti  non 
        esistente sulla matrice di costruzione del carattere.
        Se  utilizzate  una  funzione  del  genere  nei   Vs.   programmi 
        ricordatevi,  cosa  che in verita io mi dimentico sempre di fare, 
        in  uscita  di  resettare il cursore in  modo  visibile  per  non 
        ostacolare il normale lavoro a Dos.


        AH = 2  Setta la posizione del cursore

        Questo  servizio  permette  di creare delle  funzioni  simili  al 
        locate del Basic o al Gotoxy del Turbo Pascal.
        DH  e  DL contengono in ordine il numero di riga e  quello  della 
        colonna dove deve essere posizionato il cursore.
        BH  contiene il numero della pagina sulla quale si vuole eseguire 
        il posizionamento.
        Mediante  il  passaggio  di  argomenti e'  possibile  creare  una 
        funzione come nel seguente esempio.




                                       206





        Linguaggio C per MS DOS - F. Bernardotti - 1987 Opus Free Soft





         #include <dos.h>

         union REGS inregs, outregs;

         at(xpos,ypos)
         int xpos,ypos;
         {
                inregs.h.dh=xpos;
                inregs.h.dl=ypos;
                inregs.h.bh=0x00;
                int86(0x10,&inregs,&outregs);
         }


        AH = 3  Legge la posizione del cursore


        BH  in questo caso contiene il numero della pagina video a cui ci 
        si vuole riferire con il servizio.
        In uscita i registri DH e DL contengono la posizione del  cursore 
        e precisamente, in ordine, riga e colonna.
        Il servizio restituisce anche il settaggio del cursore.
        I registri CH e CL conterranno i valori relativi al settaggio del 
        cursore  che  sono  praticamente  quelli  utilizzati dal servizio 
        AH = 1.


        AH = 4  Riporta la posizione della penna ottica


        Come  avrete capito questo e' un servizio particolare  in  quanto 
        serve a leggere la posizione della penna ottica.
        Un  valore  restituito in AH pari a 0 indica che la penna  ottica 
        non e' stata attivata.
        Nel caso in cui la penna sia attivata allora DH e DL  conterranno 
        precisamente  la riga e la colonna,  CH la linea di raster mentre 
        BX il numero del pixel (0-319, 0-639).


        AH = 5  Seleziona la pagina attiva


        Parlando dei vari modi video avevamo detto che in modo testo  era 
        possibile indirizzare piu' pagine.
        Questo  servizio ci permette di selezionare il numero di pagina a 
        da rendere attiva.
        Chiaramente  in  modo grafico,  avendo a  disposizione  solo  una 
        pagina, non possiamo sfruttare questo servizio.
        AL  conterra' il numero della pagina desiderata e precisamente da 
        0 a 7 per i modi 40x25 mentre da 0 a 3 per quelli 80x25.




                                       207





        Linguaggio C per MS DOS - F. Bernardotti - 1987 Opus Free Soft





        AH = 6  Esegue lo scroll in alto


        Una  funzione utile per eseguire delle cancellazioni  di  schermo 
        parziali o totali ci e' fornito dai due servizi che vedremo.
        Il  servizio  AH  = 6 e' uno dei due ed esegue  lo  scroll  verso 
        l'alto della parte di video specificata dalle coordinate relative 
        all'angolo superiore a sinistra e quello inferiore a destra.   
        AL in questo caso conterra' il numero di righe che devono  essere 
        fatte scorrere verso l'alto.
        Un  valore  pari a 0 in AL fara' si che tutta la  finestra  venga 
        "scrollata".
        CH e CL conterranno le coordinate dell'angolo in alto a sinistra, 
        riga  e  colonna,  mentre DH e DL quelle relative  all'angolo  in 
        basso a destra.
        BH conterra' il valore dell'attributo da visualizzare nelle righe 
        nuove vuote.
        Vediamo  come  esempio  una funzione che  permetta  il  passaggio 
        come argomenti dei valori appena visti.

        #include <dos.h>

        #define SCREEN      0x10

        union REGS inregs, outregs;

        clear_up(x_u,y_u,x_d,y_d,n_r)
        int x_u,y_u,x_d,y_d,n_r;
        {
            inregs.h.ah=0x06;
            inregs.h.ch=y_u;  /* Riga    angolo in alto a sinistra    */
            inregs.h.cl=x_u;  /* Colonna    "    "   "  "    "        */
            inregs.h.dh=y_d;  /* Riga    angolo in basso a destra     */ 
            inregs.h.dl=x_d;  /* Colonna    "    "   "   "   "        */ 
            inregs.h.al=n_r;  /* Numero di righe da scorrere          */
            inregs.h.bh=0x00; /* Attributo NERO                       */
            int86(SCREEN,&inregs,&outregs);
        }

        Un  esempio in cui il numero di righe su cui eseguire  lo  scroll 
        non  corrisponde  a tutta la finestra video lo riportero' con  la 
        descrizione del servizio AH = 8.


        AH = 7  Esegue lo scroll in basso


        Mentre  AH  =  6  faceva scorrere  il  contenuto  della  finestra 
        specificata in alto questo esegue la stessa funzione ma con verso 
        di scorrimento opposto e cioe' verso il basso.
        I  registri  utilizzati dal servizio sono gli  stessi  di  quello 
        precedente.


                                       208





        Linguaggio C per MS DOS - F. Bernardotti - 1987 Opus Free Soft





        Anche  se inutile in quanto di fatto e' diverso solo il settaggio 
        del registro AH riporto un esempio di utilizzo.

        #include <dos.h>

        #define SCREEN      0x10

        union REGS inregs, outregs;

        clear_dw(x_u,y_u,x_d,y_d,n_r)
        int x_u,y_u,x_d,y_d,n_r;
        {
            inregs.h.ah=0x07;
            inregs.h.ch=y_u;
            inregs.h.cl=x_u;
            inregs.h.dh=y_d;
            inregs.h.dl=x_d;
            inregs.h.al=n_r;
            inregs.h.bh=0x00;
            int86(SCREEN,&inregs,&outregs);
        }

        Mediante  le due funzione dell' int 10H appena viste e' possibile 
        fare  degli scherzetti allo scopo di  simulare,  ad  esempio,  lo 
        scroll  laterale  a  sinistra  o a destra  cosa  normalmente  non 
        facilitata dal BIOS.
        Il main del programma ha uno scopo solo dimostrativo.
        Guardate il seguente esempio.

        #include <dos.h>

        char far *scr1 = 0xB0000000; /* B8000000 Se su scheda CGA */
        char far *scr2 = 0xB0000000; /* Idem come sopra           */
         
        union REGS inregs, outregs;

        main()
        {
           int c,b;
           for(c=0;c!=79;c++) {
              scrolleft(1);
              b = getch();
           }
        }

        scrolleft(x)
        int x;
        {
           int c;
           x *= 2;
           scr2 += x;
                                                            Segue ....


                                       209





        Linguaggio C per MS DOS - F. Bernardotti - 1987 Opus Free Soft





           for(c=0;c!=4000-x;c++) {
              *scr1 = *scr2;
              ++scr1;
              ++scr2;
           }
           scr1 -= 4000-x;
           scr2 -= 4000;
           clear(x);
        }

        clear(x_u)
        int x_u;
        {
           inregs.h.ah=0x06;
           inregs.h.ch=0;
           inregs.h.cl=80-x_u;
           inregs.h.dh=24;
           inregs.h.dl=80;
           inregs.h.al=0x00;
           inregs.h.bh=0x00;

           int86(0x10,&inregs,&outregs);
        }


        AH = 8  Riporta il carattere alla posizione del cursore



        Questo  servizio  si  mostra particolarmente utile  in  tutte  le 
        situazioni  in  cui serve sapere quale carattere  e'  memorizzato 
        nella posizione in cui si trova il cursore.
        L'unico  parametro  in  ingresso e' il  valore,  settato  in  BH, 
        relativo alla pagina a cui ci si vuole riferire.
        Anche  in questo caso BH potra' contenere da 0 a 3 nel caso di un 
        modo video 80x25 mentre da 0 a 7 in modo 40x25.
        In  uscita  AL  contiene  il  codice  del  carattere  mentre   AH 
        l'attributo.
        L'utilizzo  di  questo servizio e' indispensabile nel momento  in 
        cui  si vogliono,  ad esempio,  gestire delle finestre sul  video 
        facendo in modo che il vecchio contenuto dello schermo non  venga 
        perso  ma  al contrario ripristinato nell'istante in cui si  esce 
        dalla procedura di gestione della finestra stessa.
        Quali sono le applicazioni ?
        Ad  esempio  si potrebbe abbinare ad un tasto il richiamo  di  un 
        help che invece di comparire sullo schermo cancellando il vecchio 
        testo  presente  faccia  il  tutto in  una  finestra  che  verra' 
        ricostruita con il testo memorizzato precedentemente.
        Un  esempio  di programma per gestire una finestra  video  e'  il 
        seguente.




                                       210





        Linguaggio C per MS DOS - F. Bernardotti - 1987 Opus Free Soft






        /*
         *  Window.c salva in matrice tutti i caratteri  presenti
         *  nella finestra specificata nei parametri passati alla
         *  funzione wind(x_up,y_up,x_dw,y_dw) dove :
         *
         *  x_up e y_up  sono le coordinate dell'angolo in alto a
         *               sinistra della finestra
         *  
         *  x_dw e y_dw  sono le coordinate dell'angolo in  basso
         *               a destra della finestra
         *
         *  Dopo il richiamo di wind() la finestra compresa nelle
         *  coordinate  specificate viene cancellata.
         *  La riscrittura del testo memorizzato viene   eseguita
         *  mediante il richiamo della funzione scrivi().
         *  La funzione main() e' messa solo a scopo dimostrativo
         *  e non esegue alcun controllo sull'esattezza dei  dati
         *  passati come coordinate.
         */


        #include <stdio.h>

        #include <dos.h>

        #define SCREEN      0x10                     /* Int 10H      */

        #define AT(x,y)     printf("\33[%d;%dH",x,y) /* Macro        */

        union REGS inregs,outregs;

        int  flag, riga, xu, yu;

        char matrice[25][80];

        main()     /* Solo dimostrativo. */
        {
           int risp;
           flag=0;
           set_cur();
           wind(1,1,20,20);
           AT(11,8);
           puts("ESEMPIO");  /* Scrive ESEMPIO nella finestra e  */
           risp=getchar();   /* aver premuto un tasto ripristina */
           scrivi();         /* il vecchio contenuto             */
        }



                                                             Segue.....



                                       211





        Linguaggio C per MS DOS - F. Bernardotti - 1987 Opus Free Soft







        scrivi()     /* Riscrive il contenuto della finestra          */
        { 
            register indice1, indice2;
            indice2=0;
            if(flag==0)
            {
                printf("\n\nNon c'e' nulla da stampare\n\n");
                return;
            }

           for(indice1=yu;indice1!=yu+riga;indice1++)
           {
              AT(indice1,xu);
              printf("%s", matrice[indice2]);
              ++indice2;
              ;
           }
           printf("\n\n");
        }

        wind(x_up,y_up,x_dw,y_dw)    /* Cicli di lettura finestra     */
        int x_up,y_up,x_dw,y_dw;
        {
            register indice1, indice2;
           int colonna;
           riga=0;

           xu=x_up;
           yu=y_up;

           for(indice1=y_up;indice1 != y_dw+2;indice1++)
           {
              colonna=0;
              for(indice2=x_up;indice2 != x_dw+2;indice2++)
              {
                 AT(indice1,indice2); /* Posiziona curs */    
                 matrice[riga][colonna]=legge();
                 ++colonna;
              }
              matrice[riga][colonna+1] = '\0';
              ++riga;
           }
           flag=1;
           clear_up(x_up,y_up,x_dw,y_dw);
        }



                                                              Segue....



                                       212





        Linguaggio C per MS DOS - F. Bernardotti - 1987 Opus Free Soft





        set_cur()   /* Setta il cursore in modo che non si veda      */
        {
           inregs.h.ah=0x01;
           inregs.h.cl=0x13;
           inregs.h.ch=0x13;
           int86(0x10,&inregs,&outregs);
        }

        clear_up(x_u,y_u,x_d,y_d) /* Cancella zona video specificata */
        int x_u,y_u,x_d,y_d;
        {
           inregs.h.ah=0x06;
           inregs.h.ch=y_u;
           inregs.h.cl=x_u;
           inregs.h.dh=y_d;
           inregs.h.dl=x_d;
           inregs.h.al=0x00;
           inregs.h.bh=0x00;
           int86(SCREEN,&inregs,&outregs);
        }

        legge()   /* Riporta il carattere letto alla posizione curs  */
        {
           inregs.h.ah=0x08;
           inregs.h.bh=0x00;
           int86(SCREEN,&inregs,&outregs);
           return(outregs.h.al);
        }

        La   maggior   parte  delle  funzioni   utilizzate   nell'esempio 
        precedente  le  avevamo  gia'  viste  precedentemente  con  altri 
        servizi.
        Il funzionamento del programma e' molto semplice.
        Esistono    due   cicli   for   annidati   che   si   interessano 
        rispettivamente della colonna e della linea.
        La  macro AT(x,y) servira' a posizionare il  cursore  utilizzando 
        come  argomenti  relativi  ad  x e a y  i  valori  relativi  alle 
        variabili utilizzate all'interno dei cicli for.
        Ad  ogni  posizionamento del cursore corrisponde una lettura  del 
        carattere mediante la funzione leggi() che e' quella in cui viene 
        sfruttato il servizio di cui stiamo parlando.
        La matrice (matrice[25][80]) e' dimensionata per poter  contenere 
        al limite tutto lo schermo (80 colonne per 25 righe).
        La  fase di meorizzazione del contenuto di una finestra,  come ad 
        esempio  quella  utilizzata  nel  programma  appena   visto,   e' 
        abbastanza lenta.
        Un  miglioramento,  dal punto di vista della velocita',  potrebbe 
        essere  ottenuto  mediante la scrittura delle funzione  wind()  e 
        legge() in assembler.
        Senza doverle scrivere e' possibile fare produrre al  compilatore 
        il testo relativo al codice e ottimizzarlo manualmente.
        Sicuramente  il  fatto  di riportare nuovamente  il  listato  del 


                                       213





        Linguaggio C per MS DOS - F. Bernardotti - 1987 Opus Free Soft





        programma precedente con le due funzioni legge() e wind() scritte 
        in  assembler appesantira' le dimensioni gia' eccessive di questo 
        file  ma  sicuramente chiarira' le idee a riguardo  del  discorso 
        fatto  nei capitoli precedenti a sulla fase di link di un  modulo 
        in assembler con uno in linguaggio C.

        #include <stdio.h>
        #include <dos.h>

        #define SCREEN      0x10                     /* Int 10H      */

        #define AT(x,y)     printf("\33[%d;%dH",x,y) /* Macro        */

        extern legge(), wind();   /* Legge() e wind() sono esterne   */

        union REGS inregs,outregs;

        int  flag, riga, xu, yu;
        char matrice[25][80];

        main()     /* Solo dimostrativo. */
        {
           int risp;
           flag=0;
           set_cur();
           wind(1,1,20,20);
           clear_up(1,1,20,20);
           AT(11,8);
           puts("ESEMPIO");       /* Scrive ESEMPIO nella finestra e  */
           risp=getchar();        /* aver premuto un tasto ripristina */
           scrivi();              /* il vecchio contenuto             */
        }

        scrivi()     /* Riscrive il contenuto della finestra          */
        { 
            register indice1, indice2;
            indice2=0;
            if(flag==0)
            {
                printf("\n\nNon c'e' nulla da stampare\n\n");
                return;
            }

           for(indice1=yu;indice1!=yu+riga;indice1++)
           {
              AT(indice1,xu);
              printf("%s", matrice[indice2]);
              ++indice2;
              ;
           }
           printf("\n\n");
        }


                                       214





        Linguaggio C per MS DOS - F. Bernardotti - 1987 Opus Free Soft





        set_cur()   /* Setta il cursore in modo che non si veda      */
        {
           inregs.h.ah=0x01;
           inregs.h.cl=0x13;
           inregs.h.ch=0x13;
           int86(0x10,&inregs,&outregs);
        }

        clear_up(x_u,y_u,x_d,y_d) /* Cancella zona video specificata */
        int x_u,y_u,x_d,y_d;
        {
           inregs.h.ah=0x06;
           inregs.h.ch=y_u;
           inregs.h.cl=x_u;
           inregs.h.dh=y_d;
           inregs.h.dl=x_d;
           inregs.h.al=0x00;
           inregs.h.bh=0x00;
           int86(SCREEN,&inregs,&outregs);
        }

        Le due funzioni in assembler invece sono :

           TITLE   wind
        ;  NAME    wind.asm

              .287
        _TEXT      SEGMENT  BYTE PUBLIC 'CODE'
        _TEXT      ENDS
        _DATA      SEGMENT  WORD PUBLIC 'DATA'
        _DATA      ENDS
        CONST      SEGMENT  WORD PUBLIC 'CONST'
        CONST      ENDS
        _BSS       SEGMENT  WORD PUBLIC 'BSS'
        _BSS       ENDS
        DGROUP     GROUP   CONST,   _BSS,   _DATA
                   ASSUME  CS: _TEXT, DS: DGROUP, SS: DGROUP, ES: DGROUP
        EXTRN      _printf:NEAR
        EXTRN      _flag:WORD
        EXTRN      _riga:WORD
        EXTRN      _xu:WORD
        EXTRN      _yu:WORD
        EXTRN      _matrice:BYTE
        ;
        ;   Data Segment    (DS)
        ;
        _DATA         SEGMENT
        ESCAPE        DB   1BH, '[%d;%dH',   00H
        _DATA         ENDS





                                       215





        Linguaggio C per MS DOS - F. Bernardotti - 1987 Opus Free Soft





        ;
        ;   Code Segment    (CS)
        ;
        _TEXT         SEGMENT
        ;
        ; Funzione  wind()
        ;
        PUBLIC         _wind
        _wind          PROC    NEAR
              push     bp
              mov      bp,sp
              push     di
              push     si
              mov      _riga,0
              mov      ax,[bp+4]                 ;x_up
              mov      _xu,ax
              mov      ax,[bp+6]                 ;y_up
              mov      _yu,ax
              mov      si,ax
              jmp      SHORT LAB2
        L60:
              mov      WORD PTR [bp-2],0         ;colonna
              mov      di,[bp+4]                 ;x_up
              jmp      SHORT LAB1
        L64:
              push     di
              push     si
              mov      ax,OFFSET   DGROUP:ESCAPE ; macro AT(x,y)
              push     ax
              call     _printf
              add      sp,6
              call     _legge
              mov      cx,ax
              mov      ax,80
              imul     _riga
              mov      bx,ax
              add      bx,[bp-2]                 ;colonna
              mov      BYTE PTR _matrice[bx],cl
              inc      WORD PTR [bp-2]           ;colonna
              inc      di
        LAB1:
              mov      ax,[bp+8]                 ;x_dw
              add      ax,2
              cmp      ax,di
              jne      L64
              mov      ax,80
              imul     _riga
              mov      bx,ax
              add      bx,[bp-2]                 ;colonna
              mov      BYTE PTR _matrice[bx+1],0
              inc      _riga
              inc      si


                                       216





        Linguaggio C per MS DOS - F. Bernardotti - 1987 Opus Free Soft






        LAB2:
              mov      ax,[bp+10]                ;y_dw
              add      ax,2
              cmp      ax,si
              jne      L60
              mov      _flag,1
              pop      si
              pop      di
              mov      sp,bp
              pop      bp
              ret   
        _wind   ENDP
        ;
        ; Funzione legge()
        ;
        PUBLIC         _legge
        _legge         PROC   NEAR
              push     bp
              mov      bp,sp
              mov      ah,08H
              mov      bh,00H
              int      10H
              add      sp,6
              sub      ah,ah
              mov      sp,bp
              pop      bp
              ret   
        _legge        ENDP
        _TEXT         ENDS
                      END


        In  questo  caso  le  funzioni in linguaggio  C  potranno  essere 
        compilate con il comando

                                MSC /Ox window.c

        Verra'  in  questo modo prodotto un file con  il  codice  oggetto 
        chiamato window.obj.
        La compilazione del source assembler avverra' invece con

                                  MASM wind.asm

        In questo caso il file prodotto sara' chiamato wind.obj.
        Ora non resta che unire i due moduli utilizzando il link.

                     LINK window.obj wind.obj , window.exe;

        Il prodotto sara' il file eseguibile window.exe.




                                       217





        Linguaggio C per MS DOS - F. Bernardotti - 1987 Opus Free Soft





        A seguito di un analisi obbiettiva del programma, compreso quello 
        con  la  funzione in assembler,  mettera' alla luce una  notevole 
        lentezza  in fase di meorizzazione del contenuto  della  finestra 
        specificata.
        Il  seguente  programma  mostra  come la  velocita'  puo'  essere 
        incrementata  in  modo notevole mediante la  lettura  diretta  di 
        tutto lo schermo video senza l'utilizzo di interrupt.
        Sostituendo  ???  con  le iniziali della scheda CGA oppure  della 
        Hercules  (HER)  si  fa' in modo che  il  programma  funzioni  su 
        ambedue senza nessuna modifica.

         
        /*
           window.c                  
           Gestione finestra virtuale mediante memorizzazione
           conenuto screen con lettura diretta della memoria
           video.
        */

        #include <stdio.h>
        #include <dos.h>

        #define  AT(x,y)   printf("\33[%d;%dH", x, y)

        #define ???      /* ??? =  CGA o HER         */

        #ifdef HER
           char far *screen = 0xB0000000;
        #endif

        #ifdef CGA
           char far *screen = 0xB8000000;
        #endif

        char matrix[25][80];
        char attrib[25][80];

        union REGS inregs, outregs;

        main()
        {
           int c;
           register riga, colonna;
           set_cur();
           for(riga=0;riga != 25;riga++)
              for(colonna=0;colonna != 80;colonna++) {
                 matrix[riga][colonna] = *screen;
                 ++screen;
                 attrib[riga][colonna] = *screen;
                 ++screen;
              }
                                                            Segue....


                                       218





        Linguaggio C per MS DOS - F. Bernardotti - 1987 Opus Free Soft






           clear();
           AT(14,25);
           puts(" Hello! ");
           c = getch();
           screen -= 4000;
           for(riga=0;riga != 25;riga++)
              for(colonna=0;colonna != 80;colonna++) {
                 *screen = matrix[riga][colonna];
                 ++screen;
                 *screen = attrib[riga][colonna];
                 ++screen;
              }
           AT(24,1);
        }

        clear()
        {
           inregs.h.ah = 0x07;
           inregs.h.ch = 0x08;
           inregs.h.cl = 0x08;
           inregs.h.dh = 0x12;
           inregs.h.dl = 0x30;
           inregs.h.al = 0x00;
           inregs.h.bh = 112;
           int86(0x10, &inregs, &outregs);
        }

        set_cur()
        {
           inregs.h.ah=0x01;
           inregs.h.cl=0x13;
           inregs.h.ch=0x13;
           int86(0x10,&inregs,&outregs);
        }


        L'istruzione  screen -= 4000 riposiziona il puntatore all'origine 
        prima di riutilizzarlo per riscrivere il vecchio contenuto  dello 
        schermo. 
        Elaborate la funzione e adattatela per i vostri scopi specifici.
        Anche in questo caso un miglioramento potrebbe derivare dal fatto 
        di  scrivere  in  assembler alcune parti dello  stesso  anche  se 
        sinceramente,  essendo gia' la velocita' notevole,  penso che non 
        sia il caso.
        Come  ho  gia'  detto precedentemente,  l'uso  di  macro  per  il 
        controllo dello schermo possiede il vantaggio di essere comoda da 
        scrivere  ma  ha  anche lo svantaggio  di  pretendere  l'ansi.sys 
        specificato come device nel config.sys.
        Con  questo ho concluso il discorso relativo alla funzione svolta 
        dal  servizio  8  dell'interrupt  10H  sperando  di  non  essermi 



                                       219





        Linguaggio C per MS DOS - F. Bernardotti - 1987 Opus Free Soft





        dilungato eccessivamente.
        Vediamo un altro servizio.


        AH = 9  Scrive un carattere nella posizione del cursore


        La funzione scrive a partire dalla posizione corrente del cursore 
        un numero n di volte il carattere specificato nel registro AL.
        AH  conterra'  il  numero  del  servizio  e  precisamente  9,  BL 
        l'attributo del carattere che deve essere scritto,  BH il  numero 
        della  pagina  e  CX il numero di volte che  questo  deve  essere 
        stampato.
        Il cursore,  di fatto,  non viene spostato ma il carattere, se in 
        CX viene specificato un numero maggiore di 1, viene scritto tante 
        volte,  a  partire dalla posizione attuale,   quante sono  quelle 
        indicate da CX.
        Ripeto che il servizio pur stampando in posizioni consecutive non 
        muove il cursore.
        Il  seguente  esempio e' abbastanza banale in quanto richiede  da 
        tastiera  il carattere e il numero di volte che deve ripetere  la 
        stampa.
        Un  applicazione piu' utile potrebbe essere,  ad esempio,  per la 
        stampa  ripetuta di caratteri che devono comporre  la cornice  di 
        una maschera.

        #include <stdio.h>
        #include <dos.h>

        union REGS inregs, outregs;

        main()
        {
             int car, num;
             printf("\n\n\nQuale carattere vuoi : ");
             car = getche();
             printf("\nQuante volte lo vuoi : ");
             scanf("%d", &num);
             puts("\n\n");
             st_car(car,num);
        }

        st_car(c,n)
        int c, n;
        {
             inregs.h.ah = 0x09;  /* Servizio           */
             inregs.h.bh = 0x00;  /* Pagina             */
             inregs.x.cx = n;     /* Numero volte       */
             inregs.h.al = c;     /* Carattere          */
             inregs.h.bl = 0x03;  /* Attributo          */
             int86(0x10, &inregs, &outregs);
        }


                                       220





        Linguaggio C per MS DOS - F. Bernardotti - 1987 Opus Free Soft





        L'attributo   specificato   in  BL  e'  calcolato   mediante   le 
        combinazioni  che avevamo visto parlando dei bytes  di  attributo 
        nei paragrafi precedenti.
        Nel  caso che lo screen sia settato in modo grafico il valore  in 
        BL corrispondera' al colore del o dei caratteri.


        AH = 0AH  Scrive un carattere alla posizione del cursore 


        E'  praticamente  identico  al servizio precedente  solo  che  in 
        questo caso non e' possibile settare l'attributo in BL.


        AH = 0BH  Setta la tavolozza dei colori


        Mediante  questo  servizio e' possibile selezionare la  tavolozza 
        dei  colori  dai  cui verranno presi quelli  da  utilizzare  come 
        background e come colore carattere.
        BH contiene l' ID della tavolozza (0 - 127,  0 - 1 per la grafica 
        320x200).
        BL invece specifica il colore da utilizzare con l' ID specificato 
        in BH.
        Di fatto il Technical Reference avverte che con l'attuale  scheda 
        CGA   l'ultimo  settaggio  ha  significato  solo  in  risoluzione 
        320x200.
        Selezionando come ID la tavolozza 0,  in BH, i colori disponibili 
        settando in BL 0 sono verde, rosso e giallo.
        Un  valore  pari  a  1 in BL invece ci  mettera'  a  disposizione 
        azzurro, magenta e bianco.


        AH = 0CH  Scrive un punto (pixel).


        Il  registro DX contiene in questo servizio il numero della  riga 
        mentre  CX  il numero della colonna dove deve essere stampato  il 
        pixel.
        AL contiene il valore del colore.
        Se il bit piu' significativo  di AL,  il numero 7,  e' a 1 allora 
        il  colore  specificato si combina mediante un' operazione di  or 
        esclusivo (XOR) con il colore gia' presente.


        AH = 0DH  Legge la posizione di un pixel


        Mentre il servizio precedente stampava un punto questo ne riporta 
        la posizione.
        In ingresso DL contiene la riga mentre CX la colonna del punto di 
        cui si vuole riportato il colore in AL.


                                       221





        Linguaggio C per MS DOS - F. Bernardotti - 1987 Opus Free Soft





        AH = 0EH  Scrive un carattere in modo teletype


        Il  servizio 0EH scrive scrive in modo TTY dei singoli  caratteri 
        sullo schermo.
        Il codice del carattere e' specificato nel registro AL mentre  BL 
        contiene il valore del colore.
        Quest' ultimo valore deve essere specificato se si lavora in modo 
        grafico.
        Oltre  a  stampare  il carattere viene fatto  anche  avanzare  il 
        cursore.


        AH = 0FH  Riporta il settaggio corrente dello schermo


        AL riporta il valore relativo al settaggio del video.
        Per  l'identificazione del tipo guardate i valori utilizzati  per 
        la funzione di selezione del modo video che abbiamo visto con  il 
        servizio 00H di questo interrupt.
        BH  restituisce il numero della pagina attiva mentre AH il numero 
        di   caratteri  per  riga  posseduto  dallo  specifico   tipo  di 
        settaggio screen.
        Con  questo  abbiamo terminato il discorso  relativo  ai  servizi 
        offerti dall'interrupt 10H.
        Nel  caso  del  BIOS dell' AT IBM esistono  vari  interrupts  che 
        possiedono delle funzioni aggiuntive rispetto a quelli del PC.
        In  questo  caso so' che legata all'INT 10H esiste  un  ulteriore 
        funzione che permette di stampare una stringa.
        Purtroppo  il Technical Reference di cui sono in possesso non fa' 
        nessun   riferimento   a  questa  e  quindi  non   saprei   darne 
        informazioni.  
        Come  nel  caso  degli  interrupts  visti  precedentemente  colgo 
        l'occasione  fornitami  dall'  int 10H per  parlare  anche  delle 
        locazioni  di  memoria  e  dei registri  del  controller  che  si 
        interessano del video.
        Ho  utilizzato gli interrupts del BIOS per fare un raggruppamento 
        di tutti gli argomenti che riguardano determinate periferiche.

        La locazione 449H contiene la modalita' CRT del BIOS.
        Le  funzioni dell'int 10H (00H e 0FH) per settare un  determinato 
        modo  video  o per avere di ritorno l'attuale  utilizzano  questa 
        locazione dove :

                                 0   =  40x25 BW
                                 1   =  40x25 C
                                 2   =  80x25 BW
                                 3   =  80x25 C
                                 4   =  320x200 C
                                 5   =  320x200 BW
                                 6   =  640x200 BW
                                 7   =  Monocromatico


                                       222





        Linguaggio C per MS DOS - F. Bernardotti - 1987 Opus Free Soft





        La locazione 44AH contiene il numero di colonne

                             28H    =    40 colonne
                             50H    =    80 colonne

        Le  dimensioni del buffer del video sono contenute alla locazione 
        44CH.
        Le   dimensioni  possibili  sono  quelle  che  abbiamo  riportato 
        precedentemente  e cioe' 800H per il modo testo a  colori,  4000H 
        per la grafica a colori ecc. 
        La locazione 44EH contiene l'offset della pagina video attiva che 
        viene  calcolato  aggiungendo  all'offset 0H  un  multiplo  della 
        lunghezza video contenuta in 44CH.
        La  locazione  dalla 450H alla 45FH si occupano del  mantenimento 
        della posizione del cursore per ogni pagina video.
        Il  formato  e'  di due byte che  contengono  rispettivamente  la 
        colonna e la riga.
        Ad esempio le locazioni 450H e 451H sono relative alla pagina  0, 
        le  452H e 453H alla pagina 1 ecc.  fino ad arrivare alle 45EH  e 
        45FH relative alla pagina 7.
        Il servizio 01H dell'interrupt 10H (Set Cursor Type) utilizza  le 
        locazioni 460H e 461H per determinare il tipo di cursore.
        Il contenuto e' il seguente :

                         460H = Linea finale del cursore
                         461H = bit 5   se 0 il cursore e' visualizzato
                                bit 4-0 linea iniziale cursore 

        I servizi per settare la pagina attiva dell'interrupt 10H (05H) e 
        per conoscerla (OFH) utilizzano la locazione 462H.
        Il  chip del controller video e cioe' 6845 mediante l'utilizzo di 
        vari registri permette di eseguire i vari settaggi dei  parametri 
        screen senza doversi supportare al BIOS.
        L'esistenza e l'utilizzo da parte di un programma di questi rende 
        insormontabile  l'incompatibilita'  del software scritto per  CGA 
        con quello per Hercules.
        Se un programma si supportasse per il settaggio dei modi video  e 
        per  il controllo di questo sull'interrupt 10H allora non sarebbe 
        un   problema  eccessivamente  grosso  l'adattamento  su   scheda 
        Hercules  in quanto basterebbe,  in questo  caso,  modificare  la 
        routine di servizio dell'interrupt stesso per rendere compatibile 
        il software per CGA con la scheda Hercules.
        Che io sappia solo le routine grafiche del Lisp si supportano per 
        tutte le funzioni sull'int 10H.
        Incominciamo a vedere l'utilizzo che viene fatto dei registri del 
        controller video.
        I registri 3B4H,  relativo al controller monocromatico, e il 3D4H 
        permettono  la  selezione di uno dei registri a cui e'  possibile 
        accedere mediante la porta 3B5H (monocromatico) e 3D5H (CGA).





                                       223





        Linguaggio C per MS DOS - F. Bernardotti - 1987 Opus Free Soft






        Infatti  le porte 3B5H e 3D5H permettono di controllare  mediante 
        un registro o l'altro varie caratteristiche video e  precisamente 
        le seguenti :


                  Registro      Scopo
                  ---------------------------------------------
                     0-3        Caratteristiche orizzontali
                                del video quali caratteri/linea
                     4-9        Caratteristiche verticali quali
                                linee visualizzate ecc.
                     10         Linea iniziale cursore
                     11         Linea finale cursore

                     

        I seguenti registri sono sempre accessibili mediante le porte 3B5 
        e 3D5 ma sono solo leggibili.

                  
                  Registro      Scopo
                  ---------------------------------------------
                     12         Indirizzo alto della memoria
                                dell'adattatore
                     13         Indirizzo basso della memoria
                                dell'adattatore
                     14         Indirizzo alto della posizione
                                del cursore
                     15         Indirizzo basso della posizione
                                del cursore


        Ad  esempio de volessimo settare un valore nel registro 10  delle 
        porte 3B5H o 3D5H dovremmo specificare 10 in 3B4H o in 3D4H.
        Il registro 3B8H,  nel caso del video monocromatico,  costituisce 
        il registro di controllo delle modalita'.

                                      0x3B8 

                        +---+---+---+---+---+---+---+---+
                        : 7 : 6 : 5 : 4 : 3 : 2 : 1 : 0 :
                        +---+---+---+---+---+---+---+---+
                                  :       :           :
                                  :       :         80x25 Testo
                                  :     Abilita segnale video
                                Abilita lampeggiamento

        Come  avrete potuto osservare non tutti i bit della porta vengono 
        utilizzati.




                                       224





        Linguaggio C per MS DOS - F. Bernardotti - 1987 Opus Free Soft





        Nel  caso  della  porta con uguale  significato  ma  riferita  al 
        controller della CGA, la 3D8, i bit utilizzati sono i seguenti :

                                      0x3D8

                        +---+---+---+---+---+---+---+---+
                        : 7 : 6 : 5 : 4 : 3 : 2 : 1 : 0 :
                        +---+---+---+---+---+---+---+---+
                                  :   :   :   :   :   :
                                  :   :   :   :   : Testo 80x25
                                  :   :   :   : Selezione modalita'
                                  :   :   :   : grafica
                                  :   :   : Selezione modalita' BW
                                  :   : Abilita segnale video
                                  : 640x200
                                  1 = lampeggiamento
                                  0 = sfondo per 16 colori

        I  registri  3BAH  e  3DAH corrispondono  ai  registri  di  stato 
        relativi alla scheda monocromatica e a quella della CGA.
        Il  bit 3 a stato 1 indica la scansione verticale,  il bit 0 a  0 
        indica   l'abilitazione  del  video  mentre  a  1  la   scansione 
        orizzontale.
        Per  ora  concludo l'argomento relativo alla gestione  del  video 
        riproponendomi di riportare qualche esempio piu' avanti.
        Parlando  dei  vari interrupts del BIOS tralasciero'  il  15H  in 
        quanto  e' relativo al controllo del registratore a cassette  che 
        avrebbe  dovuto  essere disponibile con le prime versioni del  PC 
        IBM  ma di cui,  sinceramente,  non ho mai avuto  alcuna  notizia 
        sulla possibilita' o meno di reperirlo in commercio.

        Esistono  particolari situazioni in cui e' necessario sapere  con 
        quale tipo di scheda si ha a che fare.
        L'esempio  seguente mostra un programma completo che puo'  essere 
        adattato  alle  vostre  esigenze mediante  l'opportuna  rimozione 
        della funzione main.

        /* Ritorna :            1 = EGA
         *                      2 = Monocromatico
         *                      3 = CGA
         */

         
        #include <stdio.h>


        char far *ega = 0x00400087;
        char far *alt = 0x00400010;



                                                         Segue....


                                       225





        Linguaggio C per MS DOS - F. Bernardotti - 1987 Opus Free Soft






        main()
        {
           int c;
           puts("\n\n\n");
           c = scheda();
           switch(c) {
              case 1:
                 puts("Scheda EGA");
                 break;
              case 2:
                 puts("Monocromatico");
                 break;
              default:
                 puts("CGA");
                 break;
           }
        }

        scheda()
        {
           if(*ega != 0)
              return(1);
           else
              if((*alt &= 48) == 48)
                 return(2);
              else
                 return(3);
        }


        Giocando  su  alcuni registri o mediante l'accesso  diretto  alla 
        memoria e' possibile creare routines particolari.

        Nel  seguente  esempio  il contenuto dello  schermo  viene  fatto 
        scivolare  a  tipo  di  "serpente" sulle schermo  fino  alla  sua 
        completa sparizione.


        char far *scr1 = 0xB0000000;   /* B8000000 se su scheda CGA */
        char far *scr2 = 0xB0000002;   /* B8000002 se su scheda CGA */
         
        union REGS inregs, outregs;

        main()
        {
              serp();
        }



                                                             Segue ....


                                       226





        Linguaggio C per MS DOS - F. Bernardotti - 1987 Opus Free Soft





        serp()
        {
           register c, b;
           int d,n;
           d = 2;
           for(n=0;n!=25;n++) {
              for(b=0;b!=80;b++) {
                 for(c=0;c!=4000-d;c++) {
                    *scr1 = *scr2;
                    ++scr1;
                    ++scr2;
                 }
                 scr1 -= 4000-d;
                 scr2 -= 4000-d;
              }
              d += 160;
           }
        }

        Ho detto prima dell'esempio "giocando su alcuni registri".
        Sul video colore grafica in modo testo abbiamo a disposizione 4 o 
        8  pagine  video  che possono essere attivate  anche  mediante  i 
        servizi dell'interrupt 10H visti precedentemente.
        Potremmo  anche  scrivere  un testo distribuendolo  su  tutte  le 
        pagine  a nostra disposizione e,   modificando mediante la  porta 
        0x3D4  l'indirizzo  di  partenza del buffer  video,  eseguire  un 
        scroll su queste.
        Basterebbe incrementare l'indirizzo di partenza del buffer di una 
        riga per volta ovvero di 80 o 40 caratteri (bytes).
        Le varie pagine video sono infatti consecutive come locazioni  di 
        memoria. 
        Gli offset a partire dal segmento video sono i seguenti.

                         Pagina  40 Colonne  80 Colonne

                           0        0000H      0000H
                           1        0400H      0800H
                           2        0800H      1000H
                           3        0C00H      1800H
                           4        1000H
                           5        1400H
                           6        1800H
                           7        1C00H 

        Una  routine  in  assembler,  facilmente traducibile  in  C,  per 
        eseguire lo scroll di una riga sarebbe :

                               mov bx,b800H
                               add bx,80        ;incremento 1 linea
                               mov dx,3d4H      ;porta 3d4 in DX
                               mov al,12        ;indirizzo registro 12
                               out dx,al


                                       227





        Linguaggio C per MS DOS - F. Bernardotti - 1987 Opus Free Soft





                               inc dx,          ;porta 3d5H
                               mov al,bh        ;MSB indirizzo partenza
                               out dx,al
                               dec dx           ;porta 3d4H
                               mov al,13        ;indirizzo registro 13
                               out dx,al
                               inc dx           ;porta 3d5H
                               mov al,bl        ;LSB indirizzo partenza
                               out dx,al

        Una schematizzazione dello scroll e' il seguente.

                      Buffer
                      Video
                   +---------+     Schermo visualizzato
                   :   Riga 1: - - +---------+
                   :   Riga 2:     :         :
                   :   Ecc.  :     :         :
        Pagina 0   +---------+     :         :
                   :   Riga 1: - - +---------+
                   :   Riga 2: 
                   :   Ecc.  :
                   +---------+
                   :         :

        Potrete  utilizzare una routine del tipo visto per  applicazioni, 
        ad esempio, in word processor o editor.
        Per la scrittura in altre pagine diverse da quella attiva  vedete 
        i  servizi del BIOS anche se non sarebbe scorretta una  scrittura 
        diretta nella memoria di cui conoscete gli offset.
          


                     Determina dimensione memoria (INT 12H)



        Questo  interrupt permette di avere di ritorno in AX il numero di 
        blocchi da 1 K di memoria disponibile.
        Un esempio :

        #include <stdio.h>
        #include <dos.h>

        union REGS inregs, outregs;

        main()
        {
           int86(0x12, &inregs, &outregs);
           printf("\n\nMemoria  vista  nel  sistema  :   %d  KBytes\n\n", 
                   outregs.x.ax);
        }


                                       228





        Linguaggio C per MS DOS - F. Bernardotti - 1987 Opus Free Soft





        Il  valore potrebbe essere anche letto dalla locazione di memoria 
        413H.
        Questa  locazione  contiene  anch'essa il numero  di  blocchi  da 
        1 Kbytes.



               Determinazione dei dispositivi installati (INT 11H)



        Il servizio svolto dall'interrupt 11H e' quello di restituire nel 
        registro AX il numero delle periferiche installate sul PC.
        I sedici bit sono interpretabili nel seguente modo :


        +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
        :15 :14 :13 :12 :11 :10 : 9 : 8 : 7 : 6 : 5 : 4 : 3 : 2 : 1 : 0 :
        +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
          :   :   :   :   :   :   :   :   :   :   :   :   :   :   :   :
          :   :   :   :   :   :   :   :   :   :   :   :   :   :   :  (*)
          :   :   :   :   :   :   :   :   :   :   :   :   :   :  NU
          :   :   :   :   :   :   :   :   :   :   :   : RAM piastra sist.
          :   :   :   :   :   :   :   :   :   :   :   :   0   0 = 16 K
          :   :   :   :   :   :   :   :   :   :   :   :   0   1 = 32 K
          :   :   :   :   :   :   :   :   :   :   :   :   1   0 = 48 K
          :   :   :   :   :   :   :   :   :   :   :   :   1   1 = 64 K
          :   :   :   :   :   :   :   :   :   : Modo video iniziale
          :   :   :   :   :   :   :   :   :   :   0   0 = NU
          :   :   :   :   :   :   :   :   :   :   0   1 = 40x25 CGA
          :   :   :   :   :   :   :   :   :   :   1   0 = 80x25 CGA
          :   :   :   :   :   :   :   :   :   :   1   1 = 80x25 Monocrome
          :   :   :   :   :   :   :   : Numero dischetti se (*) = 1
          :   :   :   :   :   :   :   :   0   0 = 1
          :   :   :   :   :   :   :   :   0   1 = 2
          :   :   :   :   :   :   :   :   1   0 = 3
          :   :   :   :   :   :   :   :   1   1 = 4
          :   :   :   :   :   :   :  NU
          :   :   :   : Numero di RS 232 collegate (bit 9,10,11)
          :   :   : Porta giochi collegata    
          :   :  NU
        Numero di stampanti collegate (bit 14,15)

        Il  primo bit,  quello contrassegnato da (*),  e' a 1 se ci  sono 
        collegate al sistema delle unita' a disco.
        E'  possibile,  dopo aver richiamato l'interrupt,  eseguire delle 
        operazioni  di  AND per testare ogni singolo bit  allo  scopo  di 
        vedere  se esistono collegate le periferiche di cui ci  interessa 
        verificare l'esistenza.
        Ad esempio,  nel caso di un programma di comunicazione,  potrebbe 
        rivelarsi utile, prima di rendere attive le sue funzioni, testare 
        la  presenza  della porta a cui il programma stesso  tentera'  di 


                                       229





        Linguaggio C per MS DOS - F. Bernardotti - 1987 Opus Free Soft





        riferirsi.
        Nel  caso che una determinata opzione permetta di configurare  il 
        tutto sulla porta COM2,  sarebbe inutile proseguire se questa non 
        fosse presente nel sistema.
        Il seguente esempio si riferisce appunto al caso appena riportato 
        in  quanto  sfruttando l'int 11H determina il numero  di  seriali 
        collegate al PC.
        Dato  che il registro AX puo' essere suddiviso in parte alta (AH) 
        e  parte  bassa  (AL) ho eseguito un operazione di shift  di  una 
        posizione  a destra del contenuto di AH, mediante l'operatore >>, 
        e  poi mediante un operazione di AND ho isolato i primi  tre  bit 
        che  sono  appunto  quelli che indicano,  dopo lo  shift  di  una 
        posizione, il numero di porte RS 232 collegate al sistema.


        #include <stdio.h>
        #include <dos.h>

        #define INT_RS_232       0x11

        union REGS inregs, outregs;

        main()
        {
            int porte;
            porte = rs_232();
            printf("\n\nNumero seriali = %d", porte);
        }

        rs_232()
        { 
            int num_porte;
            int86(INT_RS_232,&inregs,&outregs);

            num_porte=(outregs.h.ah >> 1) & 7;
            return(num_porte);
        }

        Alcuni dei bit che sono stati segnati come NU (Non Utilizzati) in 
        effetti   non  hanno  alcun  significato  per  il  PC  mentre  lo 
        acquistano in caso di un AT.
        L'elenco completo dell' int 11H e' il seguente:

        Bit             Significato
        -----------------------------------------------------------------
        0               Settato se ci sono floppy installati
        1               Non usato (PC)
                        Coprocessore matematico installato (AT)
        4 - 5           Settaggio iniziale video
                        1 = 40x25 CGA
                        2 = 80x25 CGA
                        3 = 80x25 Monocromatico


                                       230





        Linguaggio C per MS DOS - F. Bernardotti - 1987 Opus Free Soft




        Bit             Significato
        -----------------------------------------------------------------
        6 - 7           Numero di dischetti (Aggiungere 1)
        9 - 11          Numero RS 232
        12              Settato se c'e' la porta games (PC)
                        Non usato (AT)
        13              Non usato (PC)
                        Modem interno installato (AT)
        14 - 15         Numero stampanti

        Per  scrivere software in base al tipo di sistema  utilizzato  e' 
        possibile vedere alla locazione FFFF:000E il modello.
        Il  seguente esempio mostra come sia possibile individuare se  il 
        sistema su cui gira un programma e' un PC, un XT o un AT.

        /*
         * TYPEPC.C
         */

        #include <stdio.h>

        unsigned char far *var = 0xFFFF000E;

        main()
        {
           switch(*var) {
              case 252:
                 puts("AT o compatibile");
                 break;
              case 254:
                 puts("XT o compatibile");
                 break;
              case 255:
                 puts("PC o compatibile");
                 break;
              default:
                 break;
           }
        }


                  Setta e legge l'orologio di sistema (INT 1AH)



        Durante  la  trattazione delle funzioni del  compilatore  avevamo 
        visto alcune funzioni che riportavano informazioni sul tempo.
        L'interrupt  1AH  permette di settare l'orologio di sistema o  di 
        leggerlo.
        I  servizi  svolti,   selezionabili  sempre  mediante  il  solito 
        registro AH, sono due.




                                       231





        Linguaggio C per MS DOS - F. Bernardotti - 1987 Opus Free Soft





        AH = 0  Legge l'orologio

        CX contiene, dopo l'interrupt, la parte alta del conteggio mentre 
        DX quella bassa.
        AL riporta 0 se non sono passate 24 ore dall'ultima lettura.
        Il Technical Reference specifica che l'orologio ticchetta ad  una 
        frequenza  pari  a 1.193.180/65.536 e cioe' circa 18.2  volte  al 
        secondo.
        Le  ore,  i  minuti  e  i secondi possono  essere  calcolati  nel 
        seguente modo :
                            ORE     =   CONTEGGIO/65543
                            RESTO   =   CONTEGGIO mod 65543
                            MINUTI  =   RESTO/1092
                            RESTO   =   RESTO mod 1092
                            SECONDI =   RESTO/18.21

        Ora,  dato  che  i  valori del clock si trovano in  due  registri 
        separati,  si presenta il problema di unirli per avere il  valore 
        del  conteggio  all'interno  di  una  variabile  long  per  poter 
        eseguire i calcoli indicati.
        Per   eseguire  questa  funzione  ho  trasformato,   nell'esempio 
        seguente,  la parte alta e quella bassa del valore in stringhe in 
        modo di potergli fare un operazione di concatenamento.
        Successivamente  la  stringa  cosi'  ottenuta  viene  trasformata 
        nuovamente in long.

        #include <stdio.h>
        #include <math.h>
        #include <dos.h>

        union REGS inregs, outregs;

        main()
        {
               int ore, minuti, secondi, resto;
               unsigned long hight, low, result;
               char  lo[8], all[16];
               inregs.h.ah = 0x00;
               int86(0x1A,&inregs,&outregs);
               hight = outregs.x.cx;
               low   = outregs.x.dx;
               ltoa(hight,all,10);
               ltoa(low,lo,10);
               strcat(all,lo);
               result = atol(all);
               ore    = result/65543;
               resto  = result % 65543;
               minuti = resto/1092;
               resto %= 1092;
               secondi= resto/18;
               printf("%02d:%02d:%02d", ore, minuti, secondi);
        }


                                       232





        Linguaggio C per MS DOS - F. Bernardotti - 1987 Opus Free Soft





        La  funzione  apparira'  ostica e non sensata in  quanto  con  il 
        Microsoft C esistono,  come abbiamo visto,  funzioni che svolgono 
        questo compito senza il bisogno di fare una cosa del genere.
        La  lettura dei cicli di orologio potrebbe verificarsi utile  per 
        altre funzioni.


        AH = 1  Setta il conteggio del clock


        Mentre nella funzione precedente CX e DX riportavano in uscita il 
        valore  del  contatore di clock in questo  caso  accetteranno  in 
        ingresso  i valori settati dall'utente prima che venga richiamato 
        l'interrupt.



                          Stampa dello schermo (INT 5H)



        Il  richiamo  di questo interrupt fa si che quello che  e'  sullo 
        schermo  venga stampato allo stesso modo come se si  battesse  da 
        tastiera Shift-PrtSc.


                           Boot strap loader (INT 19H)



        La fase di bootstrap e' costituita dall'esecuzione della seguente 
        sequenza.

        1  - Il  sistema  cerca di leggere il dischetto  e  se  trova  il 
             sistema   operativo  lo  carica  a  partire   dall'indirizzo 
             0000:7C00.
             Nel caso che il dischetto non sia presente :

        2  - Cerca di leggere dal disco fisso.
             Se anche su questo la ricerca risulta negativa passa a:

        3  - Il  controllo e' passato,  se presenti le ROM del basic,  al 
             basic residente.

        Anche in questo caso poco da dire.
        Basta richiamare l'interrupt con la funzione int86().

        Con  questo  ritengo  conclusa la  parte  relativa  al  controllo 
        dell'hardware e al BIOS.
        Nella seconda parte vedro' di esporre le funzioni svolte dai vari 
        interrupt  del Dos e quindi di approfondire concetti non trattati 
        qui come ad esempio la FAT, il PSP e altre cose del genere.


                                       233


