



        Linguaggio C per MS DOS - F. Bernardotti - 1987 Opus Free Soft





                                 Interrupts DOS



        Durante  la trattazione precedente avevo suddiviso i vari tipi di 
        interrupts in harware, del BIOS e del DOS.
        Gli interrupts hardware sono costituiti da precise richieste  che 
        vengono  fatte  dalle  varie periferiche affacciate  sul  bus  di 
        controllo.
        Quelli  del  BIOS  si  incaricano  invece  della  gestione  dell' 
        hardware mediante richieste software.
        Gli interrupt che vedremo ora sono quelli del DOS.
        Il  primo tipo di interrupts,  come abbiamo visto,  possono  solo 
        essere  mascherati  in modo di farli ignorare  al  processore.
        Con gli ultimi due invece possiamo modificare le routine software 
        di servizio in modo da adattarli ai nostri scopi.  
        Gli  interrupt del DOS sono dedicati a scopi orientati piu'  alla 
        gestione  dei  file  e  dei programmi che  verso  l'hardware  del 
        sistema.
        Durante  la  trattazione  di questi interrupts  vedremo  anche  i 
        concetti legati agli argomenti a cui questi si interessano.
        Vedremo  i concetti realtivi alla FAT,  al PSP,  al FCB e al  Dos 
        Critical Flag, solo per portare alcuni esempi.
        Nei paragrafi precedenti avevo utilizzato i vari interrupt che si 
        interessavano  a  determinate periferiche per  raggruppare  sotto 
        questi  anche le porte e le locazioni di memoria  che  svolgevano 
        particolari  compiti  o che contenevano informazioni  relative  a 
        queste.
        Nei capitoli seguenti utilizzero' lo stesso metodo per trattare i 
        concetti  legati  alle argomentazioni relative ai  servizi  degli 
        interrupts stessi.
        Sono da considerarsi interrupts del DOS i seguenti :

                           20H - Program terminate
                           21H - Function request
                           22H - Terminate address
                           23H - Ctrl-break exit address
                           24H - Critical error handler vector
                           25H - Absolute disk read
                           26H - Absolute disk write
                           27H - Terminate but stay resident
                           2FH - Printer

        L'interrupt piu' importante,  quello che tratteremo per primo, e' 
        il  21H  al  quale  sono collegati un grosso  numero  di  servizi 
        svolti.
        Due sole parole prima di iniziare a descrivere le varie  funzioni 
        svolte da questo.
        Come nel caso degli interrupts del Bios che svolgono piu' servizi 
        anche  in  questo  caso la selezione della funzione  viene  fatta 
        mediante il registro AH.
        Ricordo  che  le  funzioni del compilatore  Microsoft  C  che  si 


                                       234





        Linguaggio C per MS DOS - F. Bernardotti - 1987 Opus Free Soft






        interessano all'interrupt 21H sono esattamente bdos(), intdos() e 
        intdosx().


                               Servizi interrupt 21H          
          


        00H - Program terminate

        Questa  call esegue la stessa funzione  dell'interrupt  20H,  che 
        vedremo piu' avanti.
        Fate  attenzione  in  quanto una chiamata a questo  servizio  non 
        chiude  automaticamente  gli eventuali files che  avevate  aperto 
        durante l'esecuzione del programma.
        Il servizio non restituisce alcun valore.


        01H - Keyboard input

        La  funzione  legge un carattere in input e lo  visualizza  sullo 
        standard di output.
        Il codice del carattere viene restituito in AL a patto che questo 
        sia un codice ASCII.
        Nel  caso  che  invece  il valore restituito da AL  sia  0  sara' 
        necessaria una successiva chiamata al servizio per la lettura del 
        codice secondario.
        Infatti  AL  = 0 significa che il carattere battuto  e'  speciale 
        (vedi paragrafo relativo ai codici secondari).


        02H - Display output

        In questo sevizio il carattere inserito in DL viene  visualizzato 
        sullo schermo.


        03H - Auxiliary Input

        Il  servizio  inputa  un carattere da un  dispositivo  ausiliario 
        (AUX, COM1, COM2).
        I  parametri  relativi  possono essere  settati  mediante  alcune 
        funzioni di interrupt che abbiamo visto precedentemente.
        Il carattere e' ritornato nel registro AL.


        04H - Auxiliary Ooutput

        Mentre   il   servizio  precedente  inputava   (termine   inglese 
        italianizzato)  questo manda in uscita sulla porta ausiliaria  il 
        carattere specificato in DL.


                                       235





        Linguaggio C per MS DOS - F. Bernardotti - 1987 Opus Free Soft






        Non ci sono registri che riportano valori di ritorno.
        Il  discorso relativo al settaggio della porta e' lo stesso fatto 
        per la funzione precedente.


        05H - Printer Output


        Invia il carattere specificato in DL sulla porta della stampante.


        06H - Direct console I/O


        In questo servizio i registri svolgono i seguenti compiti.
        AH,  come  al solito,  contiene l'identificatore del  servizio  e 
        precisamente 6.
        Se DL contiene 0xFF allora AL ritorna il flag di zero che se e' a 
        0 indica la presenza di un dato pronto in ingresso.
        Nel  caso che il flag di zero sia a 1 allora significa che non e' 
        pronto nessun dato.
        Se  DL non e' 0xFF allora il codice sara' relativo a un dato  che 
        deve essere inviato in uscita (caratteri da 0x00 a 0xFE).
        Durante l'esecuzione di questo servizio il break e' sospeso.


        07H - Direct Console Input Without Echo


        Attende un carattere in input e lo restituisce in AL.
        Come  nel  caso della call 01H anche in questo  servizio   se  il 
        valore  ritornato e' 0 significa che e' necessaria una successiva 
        lettura per avere il codice secondario del carattere.


        08H - Console Input Without Echo


        AL ritorna il carattere letto dalla tastiera senza  visualizzarlo 
        sullo schermo.


        09H - Print String


        Fino a questo punto non ho riportato esempi in quanto le funzioni 
        dei servizi erano banali.
        Anche  in questo caso non e' che il tutto sia piu' complicato  ma 
        e'  in ogni caso meglio indicare come possano essere passati  gli 
        indirizzi delle stringhe da stampare a DS:DX.



                                       236





        Linguaggio C per MS DOS - F. Bernardotti - 1987 Opus Free Soft






        Prima  di vedere l'esempio riporto l'utilizzo che viene fatto dai 
        registri in questo servizio.
        Dicevo prima DS:DX.
        DS conterra' il segmento in cui e' allocata la stringa mentre  DX 
        il suo offset.
        Un esempio simile lo avevo gia' riportato parlando delle funzioni 
        del linguaggio C per il richiamo dell'interrupt 21H.



        #include <dos.h>

        union REGS inregs, outregs;

        struct SREGS segregs;

        char var[] = "Pippo$";

        char far *var_2 = var;

        main()
        {
             inregs.h.ah = 0x09;
             segregs.ds  = FP_SEG(var_2);
             inregs.x.dx = FP_OFF(var_2);
             intdosx(&inregs,&outregs,&segregs);
        }

        La stringa che deve essere stampata a video deve terminare con il 
        carattere '$' (codice ASCII 24H).


        0AH - Buffered Keyboard Input


        La   call   0AH  permette  di  eseguire  un  input  da   tastiera 
        bufferizzato.
        DS:DX in questo caso puntano al buffer.
        Il  primo  byte  del buffer indica al  DOS  quanti  bytes  dovra' 
        accettare  in  input  mentre  il secondo  verra'  utilizzato  per 
        ritornare,  dopo che e' stato battuto il tasto CR (ASCII 13),  il 
        numero di caratteri effettivamente letti.
        In  questo ultimo valore non e' incluso il carattere  CR  benche' 
        questo venga collocato all'interno del buffer.


        0BH - Check Standard Input Status


        Questo  servizio  serve solo a testare se l'input da tastiera  e' 
        pronto o meno.


                                       237





        Linguaggio C per MS DOS - F. Bernardotti - 1987 Opus Free Soft





        AL  ritorna  0xFF se un carattere e' disponibile mentre  0x00  in 
        caso contrario.


        0CH - Clear Keyboard Buffer and Invoke a Keyboard Function


        La funzione svuota il buffer di tastiera e chiama una funzione.
        AL contiene il numero della funzione da chiamare.
        Fate attenzione in quanto i valori ammessi,  relativi alle  call, 
        sono solo 01H, 06H, 07H, 08H e 0AH.



        0DH - Disk Reset


        Vengono chiusi tutti i buffer dei file.
        Anche  per  questo servizio bisogna fare attenzione in quanto  un 
        eventuale   file   modificato   e   non   chiuso   non   verrebbe 
        salvato automaticamente.
        Prima  di eseguire la call e' conveniente chiudere tutti i  files 
        aperti.


        0EH - Select Disk


        DL contiene il numero di riferimento del drive selezionato (0=A:, 
        1=B:, ecc.)
        AL riporta in uscita il numero dei drive presenti.


        0FH - Open File


        In questa funzione salta fuori,  per la prima volta, un argomento 
        che  non  avevamo  trattato  prima d'ora  e  precisamente  quello 
        relativo al FCB (File Control Block).
        Il file control block e' un area di 44 bytes che il DOS  utilizza 
        per contenere le informazioni relative al file utilizzato.
        Possiamo  suddividere il FCB in due blocchi uno di 7  e uno di 37 
        bytes.
        Il primo blocco, quello di 7 bytes, viene utilizzato solo in casi 
        particolari  come  ad esempio in quello in cui lavoriamo su  file 
        hidden o di sistema.
        Il blocco piu' lungo, quello da 37 bytes, viene invece utilizzato 
        tutte  le  volte per mantenere dati quali il nome  del  file,  le 
        dimensioni e altri che ora vedremo mediante una schematizzazione.
        Il primo blocco viene normalmente chiamato Extended File Controll 
        Block mentre il secondo Standard File Controll Block.



                                       238





        Linguaggio C per MS DOS - F. Bernardotti - 1987 Opus Free Soft






        Vediamo lo schema  schema riportato dal Technical Reference :

                 +---------+----------------------------------+---------+
                 :   FFH   :               Zeri               :Attributi:
        +--------+---------+----------------------------------+---------+
        :  Drive :           Nome file (8 bytes) o nome device          :
        +--------+---------------------------------+----------+---------+
        :        :           Estensione            :Curr.block: Dimens. :
        +--------+---+--------------+--------------+----------+---------+
        :Dimen. low  :Dimens. hight :    Data      :                    :
        +------------+--------------+--------------+                    :
        :                    Riservato per uso del DOS                  :
        +------------+--------------+----------------+------------------+
        :Curr.Record :Random rec low:Random rec hight:
        +------------+--------------+----------------+



        Vediamo ora di descrivere ogni campo del FCB.

         Spiazzamento     Dimensione                   Note
        --------------+----------------+---------------------------------
             -7               1         Flag di presenza extended FCB.
                                        E' presente se contiene FFH.
             -6               5         Contiene tutti 0 (00000).
             -1               1         Attributo del file
              0               1         (*1*) Numero del drive
              1               8         Nome del file giustificato a
                                        sinistra o nome device.
              9               3         Estensione del file giustificata
                                        a sinistra.
             12               2         Numero blocco corrente
             14               2         Dimensioni record
             16               4         Dimensione del file
             20               2         (*2*) Data del file
             22              10         Riservati al DOS
             32               1         Numero del record (0-127)
             33               4         Numero record casuale

        Come  avrete  notato  ho contrassegnato due campi con  (*x*)  per 
        potergli aggiungere qualche nota.
        A  riguardo  del numero del drive (*1*) e'  necessaria  fare  una 
        precisazione.
        Il numero di riferimento al drive prima dell'apertura e' 

                              0 - Drive di default
                              1 - Drive A
                              2 - Drive B
                              ecc.




                                       239





        Linguaggio C per MS DOS - F. Bernardotti - 1987 Opus Free Soft





        Dopo l'apertura i riferimenti possono essere

                              1 - Drive A
                              2 - Drive B
                              ecc.

        Parlando  della  data  (*2*) bisogna specificare  il  formato  di 
        questa all'interno dei due bytes.

        +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
        :15 :14 :13 :12 :11 :10 : 9 : 8 : 7 : 6 : 5 : 4 : 3 : 2 : 1 : 0 :
        +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
          :   :   :   :   :   :   :   :   :   :   :   :   :   :   :   :
          a   a   a   a   a   a   a   m   m   m   m   g   g   g   g   g

        dove 
                 a = anno   (1980-2099)
                 m = mese   (1-12)
                 g = giorno (1-31)




        Un  discorso si puo' fare anche a riguardo degli attributi di  un 
        file.

               00H - File normale
               01H - Indica che il file e' marcato in sola lettura
               02H - Indica un file hidden ovvero nascosto
               04H - Indica un file di sistema
               08H - Etichetta di volume
               10H - E' una sub-directory
               20H - Archivio. E' usato da BACKUP e RESTORE.

        In linguaggio C il FCB potrebbe essere dichiarato come 

                                  char fcb[44];

        Sull'argomento  ritorneremo  in seguito portando  alcuni  esempio 
        d'uso.
        Ritornando al discorso relativo alla call 0FH possiamo dire che i 
        registri DS:DX devono puntare a un  FCB non aperto.
        In che modo possiamo settare questi registri ?
        Una soluzione ci e' offerta dalle macro FP_OFF e FP_SEG.
        La  seconad soluzione e' invece quella di utilizzare la  funzione 
        del compilatore Microsoft bdos().
        Se vi ricordate questa utilizzava come argomenti il numero  della 
        call, il valore del registro DX e quello del registro AL.






                                       240





        Linguaggio C per MS DOS - F. Bernardotti - 1987 Opus Free Soft





        In  questo caso AL,  in ingresso,  non ci serve a nulla e  quindi 
        potremo sfruttare la funzione nel seguente modo.

        char fcb[44];

        funz()
        {
             .......
             .......
             bdos(call,fcb);
        }

        Il  registro  AL  conterra' di ritorno 00H se il  file  e'  stato 
        aperto  con  successo mentre FFH se il tentativo di  apertura  e' 
        fallito.


        10H - Close File


        Mentre  la funzione precedente apriva un file questa funzione  lo 
        chiude.
        DS:DX in questo caso puntano a un FCB aperto.
        Il  registro AL ritorna dopo la chiamata della funzione 00H se il 
        file e' stato trovato mentre FFH in caso contrario.


        11H - Search for First Entry


        La funzione cerca nella directory la prima corrispondenza al file 
        specificato.
        La funzione se trova il file corrispondente restituisce in AL 00H 
        e piazza i dati relativi al file all'interno del FCB.
        L'esempio  che  ora  riportero' utilizza anche  la  funzione  12H 
        (Search for Next Entry) che vedremo tra poco.
        Il  programma e' una combinazione di varie funzioni  che  abbiamo 
        visto fino ad ora nei capitoli precedenti.
        BYTEDIR2.C  e'  un piccolo file che provvede a  mostrare  in  una 
        finestra il contenuto delle dir specificate.
        Oltre  a  cio' calcola  il numero dei files presenti  e  la  loro 
        dimensione in bytes.
        E'   possibile  quindi  sapere  sempre  le  dimensioni   di  ogni 
        directory presente sul disco di deafult.

                 Sintassi :            bytearea \path [opzione]

                 Opzioni  :            nessuna, A

        Nessuna  > Il risultato e' mostrato solo a video.
                   Viene  segnalato  errore se il  path  specificato  non 
                   esiste.


                                       241





        Linguaggio C per MS DOS - F. Bernardotti - 1987 Opus Free Soft





                   Se  si  desidera  operare sulla dir  presente  non  e' 
                   necessario specificare il percorso.


        A        > Il   risultato oltre che su video viene scritto su  un 
                   file denominato AREA.STA. 
                   Nel   file  AREA.STA  verra'  aggiunto  alla  fine  il 
                   risultato.

                   Esempio : Path \bin : 1 files per un totale di 2 bytes


        #include <stdio.h>
        #include <dos.h>
        #include <types.h>
        #include <stat.h>
        #include <direct.h>
        #include <time.h>

        #define SCREEN       0x10
        #define BELL         putchar('\007')

        #define ???                       /* ??? =  CGA o HER         */

        #ifdef HER
           char far *screen = 0xB0000000;
        #endif

        #ifdef CGA
           char far *screen = 0xB8000000;
        #endif

        char matrix[25][80];
        char attrib[25][80];

        union REGS inregs, outregs;
        struct stat files;

        FILE *stream;
        long total, k_byte;
        int  tot;
        char dir_c[80];
        char dir[300][14];
        char bfr[135];
        char fcb[44];
        char buffer[64],buf_ret[64];








                                       242





        Linguaggio C per MS DOS - F. Bernardotti - 1987 Opus Free Soft





        main(argc,argv)
        int argc;
        char *argv[];
        {
           int i, ch_d;
           int risp;
           tot=1;
           total=0;
           set_cur();
           getcwd(buf_ret,64);
           if(argc>1)
              ch_d=chdir(argv[1]);
           wind();
           cur_mv(1,0);
           printf("BYTEDIR  by F. Bernardotti\n");
           printf("(C) Copyright 1987 Opus AL\n\n\n");
           if(ch_d== -1)
           {
              BELL;
              printf("\n\n\n\n\n\n\n  ERRORE : Path errato\33[1A");
              goto end_pr;
           }
           getcwd(buffer,64);
           printf("Path  :  %s",buffer);
           cur_mv(9,0);
           puts("------[DIRECTORY]------");
           cur_mv(24,0);
           puts("-----------------------\33[1A");
           while(fi(dir[tot++],0,"????????","???",16) != NULL);
           --tot;
           for(i=1;i!=tot;i++)
           {
              clear(11,1,22,25,0,1);
              cur_mv(6,0);
              stat(dir[i],&files);
              total += files.st_size;
              printf("Files :  %3d \nBytes :  %ld", i, total);
              cur_mv(22,0);
              printf(" %s >%8ld",dir[i],files.st_size);
           }
           if(argc>2)
           {
              switch(*argv[2])
              {
              case 'A':
              case 'a':
                 chdir(buf_ret);
                 sta();
                 stream=fopen("area.sta","a");
                 fprintf(stream,"\nPath %-48s : %03d files %08ld 
                                  bytes",buffer,tot,total);
                 break;


                                       243





        Linguaggio C per MS DOS - F. Bernardotti - 1987 Opus Free Soft





              default:
                 BELL;
                 break;
              }
              }
        end_pr:
           cur_mv(24,8);
           puts("[PREMI]\33[1A");
           chdir(buf_ret);
           risp=getc(stdin);
           scrivi();
        }

        fi(b,drive,name,ext,tipo)
        char *b;
        char drive;
        char *name;
        char *ext;
        char tipo;

        {
           int y;
           register unsigned int regax;
           register int i;
           static int first_entry = 0;
           y=0;
           fcb[0] = 255;
           strncpy(&fcb[1], "\0\0\0\0\0", 5);
           fcb[6] = tipo;
           fcb[7] = drive;
           strncpy(&fcb[8], name, 8);
           strncpy(&fcb[16], ext, 3);
           if (first_entry == 0)
           {
              first_entry = 1;
              bdos(0x1A, bfr);
              regax = bdos(0x11, fcb);
           }
           else
              regax = bdos(0x12, fcb);
           if ((regax & 0x00FF) == 0xff)
           {
              first_entry = 0;
              return(NULL);
           }
           if(bfr[19] == 16)   
           {
              b[13] = 1;
              y=1;
           }
           else 



                                       244





        Linguaggio C per MS DOS - F. Bernardotti - 1987 Opus Free Soft






           b[13] = 0;
           for(i = 0; i < 12;++i) b[i] = ' ';
           for(i = 0; i < 8;++i) b[i] = bfr[i+8];
           b[8] = '.';
           if(y==0)for(i = 0;i < 3;++i) b[i+9] = bfr[i+16];
           else
           {
              strcpy(&b[9],"<D>",3);
              y=0;
           }
        }

        clear(y_u,x_u,y_d,x_d,att,n_r)

        int y_u,x_u,y_d,x_d,att,n_r;
        {
           inregs.h.ah=0x06;
           inregs.h.ch=y_u;
           inregs.h.cl=x_u;
           inregs.h.dh=y_d;
           inregs.h.dl=x_d;
           inregs.h.al=n_r;
           inregs.h.bh=att;
           int86(SCREEN,&inregs,&outregs);
        }

        sta()
        {
           long ltime;
           time(&ltime);
           if((stream=fopen("area.sta","r")) == NULL)
           {
              fcloseall();
              stream=fopen("area.sta","w");
              fprintf(stream,"\nFile(s)  e  bytes nelle dir  al  %s\n\n", 
                             ctime(&ltime));
              fclose(stream);
           }
        }

        set_cur()
        {
           inregs.h.ah=0x01;
           inregs.h.cl=0x13;
           inregs.h.ch=0x13;
           int86(SCREEN,&inregs,&outregs);
        }






                                       245





        Linguaggio C per MS DOS - F. Bernardotti - 1987 Opus Free Soft





        cur_mv(x,y)
        int x,y;
        {
           inregs.h.dh=x;
           inregs.h.dl=y;
           inregs.h.ah=0x02;
           int86(SCREEN,&inregs,&outregs);
        }

        wind()
        {
           register riga, colonna;
           for(riga=0;riga != 25;riga++)
              for(colonna=0;colonna != 80;colonna++) {
                 matrix[riga][colonna] = *screen;
                 ++screen;
                 attrib[riga][colonna] = *screen;
                 ++screen;
              }
           clear(0,0,25,26,0,0);
        }

        scrivi()
        {
           register riga, colonna;
           screen -= 4000;
           for(riga=0;riga != 25;riga++)
              for(colonna=0;colonna != 80;colonna++) {
                 *screen = matrix[riga][colonna];
                 ++screen;
                 *screen = attrib[riga][colonna];
                 ++screen;
              }
           cur_mv(23,1);
        }


        Come   avrete  notato  al  programma  vengono  applicate   alcune 
        funzioni,  ad esempio per gestire la finestra video,  che avevamo 
        visto precedentemente.
        La  funzione con maggior importanza al fine delle call 11H e  12H 
        e' in ogni caso fi().
        Vediamo, a discapito dello spazio di questo file, di commentarlo.
        Come  compariva  dal remark del programma precedente la  chiamata 
        alla  funzione  che  cerca  la  corrispondenza  del  file   nella 
        directory era :

        while(fi(dir[tot++],0,"????????","???",16);

        dove dir[tot] e' l'elemento della matrice che conterra' i dati di 
        un certo file.
        0 indica il drive (0 = default).


                                       246





        Linguaggio C per MS DOS - F. Bernardotti - 1987 Opus Free Soft





        "????????","???"  sono  un utilizzo dei caratteri jolly per  dire 
        che il file cercato corrisponde al primo,  al secondo ecc.  senza 
        fare riferimento ad un nome di file specifico.
        16 corrisponde all'attributo.

        fi(b,drive,name,ext,tipo)
        char *b;                          /* Indirizzo di DIR[TOT]     */ 
        char drive;                       /* Drive                     */
        char *name;                       /* "????????"                */
        char *ext;                        /* "???"                     */
        char tipo;                        /* Tipo                      */

        {
               int y;
               register unsigned int regax;
               register int i;
               static int first_entry = 0;
               y=0;

        Tutte   le   seguenti  operazioni  di  assegnazione  settano   le 
        specifiche del file  che deve essere cercato nella directory.

               fcb[0] = 255;              /* FFH 1 byte Extended FCB   */
               strncpy(&fcb[1], "\0\0\0\0\0", 5); /* 5 zeri            */
               fcb[6] = tipo;              
               fcb[7] = drive;
               strncpy(&fcb[8], name, 8);
               strncpy(&fcb[16], ext, 3);

        La  prima ricerca di file deve essere fatta mediante la call  11H 
        (Search  For  First  Entry) e quindi la condizione  if  testa  se 
        effettivamente  e'  la  prima  volta che  la  funzione  e'  stata 
        chiamata.
        Nel caso che first_entry sia uguale a 0 potrete notare l'utilizzo 
        di una call di cui non abbiamo ancora accennato nulla.
        Si tratta della 1AH (Set Disk Transfer Address).
        Per ora datela per scontata. 
        Ne parleremo tra un po'.
          
               if (first_entry == 0)
               {
                first_entry = 1;
                bdos(0x1A, bfr);
                regax = bdos(0x11, fcb);
               }
               else

        Nel  caso che non sia la prima chiamata alla funzione  allora  la 
        call da utilizzare e' la 12H (Search for Next Entry).

               regax = bdos(0x12, fcb);



                                       247





        Linguaggio C per MS DOS - F. Bernardotti - 1987 Opus Free Soft





        Se la funzione restituisce FFH allora significa che la ricerca ha 
        avuto un esito negativo.
        Restituendo NULL il ciclo while che chiamava fi() si interrompe.

               if ((regax & 0x00FF) == 0xff)
               {
                first_entry = 0;
                return(NULL);
               }

        Se  il  valore e' 16 allora significa che il file trovato e'  una 
        directory.
        In questo caso setta y=1 che viene utilizzato come flag per delle 
        funzioni puramente estetiche che seguono.

               if(bfr[19] == 16)   
               {
                b[13] = 1;
                y=1;
               }
               else 
               b[13] = 0;

        Il  nome del file viene copiato all' indirizzo di  dir[tot].

               for(i = 0; i < 12;++i) b[i] = ' ';
               for(i = 0; i < 8;++i) b[i] = bfr[i+8];

        Se il flag e' uguale a uno allora e' una directory.
        Nel  caso che si tratti di un file nella posizione tra il nome  e 
        l'estensione viene messo un punto.

             if(y==0) b[8] = '.';
               else

        Nel caso invece che sia una directory viene messo il segno '>'.

               b[8] = '>';
               if(y==0)for(i = 0;i < 3;++i) b[i+9] = bfr[i+16];
               else

        Anche  in  questo  caso,  se  si tratta  di  una  dir,  al  posto 
        dell'estensione viene copiata la stringa "DIR".

               {
                strcpy(&b[9],"DIR",3);
                y=0;
               }
        }





                                       248





        Linguaggio C per MS DOS - F. Bernardotti - 1987 Opus Free Soft





        Il metodo applicato per la memorizzazione del contenuto del video 
        allo  scopo di gestire una finestra sul video e' quello  relativo 
        alla lettura diretta della memoria screen.
        Questo  porta  all'incompatibilita' del programma  compilato  per 
        scheda Hercules con quello per scheda CGA.
        La  compilazione  in  funzione  di una  o  dell'altra  si  esegue 
        mediante la sostituzione nella direttiva #define ???  dei ??? con 
        le iniziali della scheda voluta.
        Come  avrete  potuto notare negli esempi compaiono funzioni  gia' 
        viste molte volte precedentemente.
        Questo conferma una delle notevoli potenzialita' del linguaggio C 
        e  cioe' quella di poter creare e gestire librerie contenenti  le 
        routine  di  cui facciamo sovente uso senza  bisogno  di  doverle 
        riscrivere continuamente.


        12H - Search for Next Entry


        DS:DX, come nel caso del servizio precedente, puntano al FCB.
        L'uso  della  call  e'  stato  gia'  discusso  in  parte  durante 
        l'esempio precedente.
        AL ritorna 00H se il file cercato e' stato reperito mentre FFH in 
        caso contrario.
        La  funzione 12H puo' essere utilizzata dopo che una chiamata  al 
        11H ha dato frutti positivi.
        La modalita' d'uso e' in pratica la stessa del 11H.


        13H - Delete File


        I registri DS:DX puntano al FCB del file che si vuole cancellare.
        AL  restituisce 00H se il file e' stato cancellato mentre FFH  se 
        non e' stato reperito.


        14H - Sequential Read 


        Il  servizio  legge un record indicato dal FCB nella memoria  del 
        DTA (Disk Transfer Area).
        DS:DX   puntano  al  FCB  mentre  AL  restituisce  il   risultato 
        dell'operazione e precisamente :

                      00H - Lettura eseguita positivamente
                      01H - Nessun data letto (EOF)
                      02H - DTA troppo piccolo
                      03H - EOF con lettura parziale

        Del  DTA  parleremo  con  la  funzione  1AH  (Set  Disk  Transfer 
        Address).


                                       249





        Linguaggio C per MS DOS - F. Bernardotti - 1987 Opus Free Soft





        15H - Sequential Write


        DS:DX puntano come al solito al FCB.
        In  questo  caso la funzione si interessa della scrittura  di  un 
        record sequenziale su disco.
        I valori riportati da AL sono :

                     00H - Scrittura eseguita positivamente
                     01H - Dischetto pieno
                     02H - DTA troppo piccolo


        16H - Create File


        La funzione crea un file sul disco.
        DS:DX puntano al FCB.
        I valori restituiti in AL sono :

                     00H - Operazione eseguita correttamente
                     01H - Dischetto pieno
                     02H - DTA troppo piccolo


        17H - Rename File


        In questa funzione il FCB e' modificato in un modo strano.
        Il nome del file occupa la solita posizione all'interno di questo 
        mentre il nome del nuovo file e' all' indirizzo 16 del FCB (DS:DX 
        + 11).
        Come avrete capito DS:DX puntano al FCB.
        L'utilizzo  di caratteri jolly all'interno del nuovo nome  indica 
        che  quella parte indicata e' uguale alla precedente situata  nel 
        nome da convertire.
        Es.

             Originale               Nuovo nome           Risultato
             --------------------------------------------------------
             OPUSCTL.EXE             ????VCR.EXE          OPUSVCR.EXE

        Noterete  in seguito (fino ad ora non e' capitato) che ci saranno 
        degli intervalli numerici nei servizi del DOS.
        Questi mancanti sono contrassegnati sul Technical Reference  come 
        "Used Internally by DOS".
        Di   molte   sono   riuscito   a   trovare,   faticosamente,   la 
        documentazione non messa in circolazione dalla Microsoft.
        Sinceramente non capisco come mai possano capitare queste cose.
        Si  dice che alcune funzioni non sono state documentate in quanto 
        non viene garantito il mantenimento di queste nelle varie  relase 
        del Dos.


                                       250





        Linguaggio C per MS DOS - F. Bernardotti - 1987 Opus Free Soft





        Sara'  anche  cosi  ma  sinceramente ho notato  che  alcune  sono 
        presenti in tutte le edizioni apparse fino ad ora.


        19H - Current Disk


        AL  ritorna il numero del lettore in uso e cioe' 0 = A:,  1 =  B: 
        ecc.


        1AH - Set Disk Transfer Address


        Eccoci  finalmente giunti alla funzione che setta l'indirizzo  di 
        trasferimento del disco.
        Di  default  questo  si  trova al offset 80H   del  prefisso  del 
        segmento del programma ed e' lungo 128 byte.
        Questa  area di memoria viene utilizzata dal DOS per l'  I/O  dei 
        file.
        DS:DX  si  interessano  di  puntare  a  quest'area  nel  caso  di 
        settaggio mediante la call 1AH.
        Questa funzione e' stata utilizzata precedentemente nella routine 
        che  leggeva  la directory del disco mediante le funzioni  Search 
        for First Entry e Search for Next Entry.



        1BH - Allocation Table Information



        Con   questo  servizio  diventa  necessaria  un'  estensione  del 
        discorso relativo a quella definita FAT (File Allocation Table).
        Il  servizio  riporta  infatti  informazioni  riguardanti  questa 
        ultima.
        Che cosa e' la FAT ?
        La  FAT viene utilizzata dal Dos per allocare lo spazio su  disco 
        per un file, un cluster alla volta.
        Trattando  dischetti  floppy e hard disk possiamo  ritrovarci  di 
        fronte a due formati diversi di questa.
        Nel caso dei floppy ogni voce relativa ad un cluster e' di 12 bit 
        ovvero 1.5 byte.
        I clusters possono essere, in questo caso, 4086.
        Nel  caso di un disco fisso con piu' di 10 Mbytes ogni voce della 
        FAT e' di 16 bit (2 bytes).
        Vediamo i significati delle voci di questa.







                                       251





        Linguaggio C per MS DOS - F. Bernardotti - 1987 Opus Free Soft





        La prima voce indica il tipo di disco ed esattamente :

                    Valore HEX      Significato
                    -----------------------------------------
                        FF          Doppia faccia, 8 settori
                        FE          Singola faccia, 8 settori
                        FD          Doppia faccia, 9 settori
                        FC          Singola faccia, 9 settori
                        F9          Doppia faccia, 15 settori
                        F8          Disco fisso
          
        Il secondo, il terzo e il quarto bytes contiene FFFFH.
        Ogni successiva voce della FAT contiene il successivo cluster del 
        file con due particolari significati.
        Un  valore  pari  a  000H  indica che  il  cluster  e'  libero  e 
        disponibile.
        Nel  caso  che  si esegua la cancellazione di un   file  si  puo' 
        notare  che le voci della FAT relative a questo vengono  messe  a 
        zero.
        Nel caso di occupazione si puo' ricostruire la catena del file.
        Es.

                    Voce FAT      Valore     Descrizione
                    -----------------------------------------
                        .          ...       ................
                        5            7       Next cluster = 7
                        6          FF7       Avariato
                        7            8       Next cluster = 8
                        8          FFF       Fine file
                        ecc.

        Nell'esempio  precedente avrete notato la presenza di due  valori 
        particolari.
        Nel  caso  che una voce della FAT contenga FF7H significa che  il 
        cluster e' stato marcato come avariato in fase di formattazione.
        Questo chiaramente non sara' disponibile.
        FFFH indica la fine della catena relativa a un file.
        In altre parole significa che il file e' terminato.
        Il  Dos gestisce due copie della FAT sul dischetto nel  caso  che 
        una venga rovinata.
        La  prima occupa il settore immediatamente successivo al  settore 
        di boot.
        Il  discorso  fatto  fino ad ora sulla FAT  risulta  estremamente 
        semplice.
        Purtroppo questa e' solo la teoria in quanto il metodo utilizzato 
        fisicamente dal Dos per gestire la FAT e' un po' piu' complicato.
        L'organizzazione  fisica della FAT viene fatta con un  metodo  di 
        memorizzazione a rovescio.
        Nel  caso  di una FAT a 12 bit ogni valore relativo  a  una  voce 
        della  stessa e' organizzato in modo che questo risulti essere un 
        valore  di tre cifre (000H-FFFH) e cioe' rappresentabile  appunto 
        con 12 bit.


                                       252





        Linguaggio C per MS DOS - F. Bernardotti - 1987 Opus Free Soft






        L' organizzazione avviene a coppie di tre bytes ciascuna.
        Se questa coppia di voci risulta essere 


                          ABC DEF  (in bytes AB CD EF)


        ribaltando il tutto i valori relativi a ogni voce saranno


                                     DAB EFC


        Per  calcolare  ogni successivo cluster di un file  partendo  dal 
        primo   segnato  nei campi della  directory,  che  vedremo,  sono 
        necessari i seguenti calcoli (relativi a una FAT da 12 bit).
        Si moltiplica il numero del cluster appena usato per 1.5.
        La  parte  intera  del  risultato  del  prodotto  e'  un   offset 
        all'interno  della  FAT  che contiene il  numero  del  successivo 
        cluster del file.
        Se il numero del  cluster era un numero pari allora si valutano i 
        12 bits di ordine piu' basso del valore a 16 bit ottenuto.
        In caso contrario i bits da considerare sono i 12 di ordine  piu' 
        alto.
        Come  e' gia' stato detto se il contenuto di un cluster e' FF8H o 
        FFFH allora si e' giunti alla fine del file.
        Per  convertire il cluster nel settore logico sono necessarie  le 
        seguenti operazioni.
        Si sottrae 2 dal numero del cluster e si moltiplica questo per il 
        numero di settori per cluster.
        Successivamente  si  addiziona  il  numero  del  settore  in  cui 
        incomincia l'area data del disco.
        Una  FAT a 16 bits mantiene gli stessi riferimenti solo  che,  ad 
        esempio,  la  fine del file viene segnata da FFFFH anziche'  FFFH 
        mentre un cluster errato e' FFF7H invece di FF7H.
        Nel  caso  di  una  FAT a 16 bit i  calcoli  da  fare  sono  piu' 
        semplici.
        Si  moltiplica  il numero del cluster contenuto in uno dei  campi 
        della directory per due.
        Se  il  contenuto  e' FFFFH significa che il  file  e'  terminato 
        altrimenti il valore corrisponde al successivo cluster del file.

        Sembrera'  fuori  luogo la descrizione dell'organizzazione  della 
        directory  sul  disco ma penso che sia utile trattarla  a  questo 
        punto  visto che parlando della FAT ho accennato a un  campo  che 
        conteneva il primo cluster di un file.







                                       253





        Linguaggio C per MS DOS - F. Bernardotti - 1987 Opus Free Soft






        Ogni  ingresso  della  directory  e' composto da  32  bytes  cosi 
        suddivisi :

        Bytes 0-7

        Il primo bytes potrebbe essere la prima lettera del nome del file 
        oppure uno dei seguenti valori :
              
                00H  - File  non usato.  Viene inserito per  limitare  la 
                       ricerca sulla directory.
                E5H  - Indica che il file e' stato cancellato.
                2EH  - Indica che si tratta di una subdirectory.

        Nel  caso  che il nome di un file non sia lungo  8  caratteri  il 
        campo viene completato mediante degli spazi (ASCII 32).

        Bytes 8-10

        Indica l'estensione del file.

        Bytes 11

        Contiene l'attributo del file (1 byte).
        I  codici  relativi  ai  vari  tipi  possibili  sono  gia'  stati 
        riportati  parzialmente  nel programma d'esempio che  leggeva  la 
        directory e la mostrava in una finestra video.
        L'elenco completo e' il seguente :

                 01H - File marcato come read-only.
                 02H - Hidden file (file nascosto)
                 04H - System file
                 08H - Volume label
                 10H - Sub directory
                 20H - Bit archivio (Usato da BACKUP e RESTORE)

        Per  semplificare  si  puo' immaginare il byte di  attributo  nel 
        seguente modo :

                        +---+---+---+---+---+---+---+---+
                        : 7 : 6 : 5 : 4 : 3 : 2 : 1 : 0 :
                        +---+---+---+---+---+---+---+---+
                          :   :   :   :   :   :   :   :
                        Non usati :   :   :   :   :   1 = read only
                                  :   :   :   :   1 = Hidden
                                  :   :   :   1 = System
                                  :   :   1 = Volume label
                                  :   1 = Subdirectory
                                  1 = Archivio di bit





                                       254





        Linguaggio C per MS DOS - F. Bernardotti - 1987 Opus Free Soft





        Bytes 12-21

        Riservati al Dos.


        Bytes 22-23

        Questi bytes contengono l' ora di quando il file e' stato  creato 
        o quella relativa all'ultima modifica.
        L'interpretazione dei due bytes e' la seguente :

        :---------- Byte 23 ------------:---------- Byte 22 ------------:

        +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
        :15 :14 :13 :12 :11 :10 : 9 : 8 : 7 : 6 : 5 : 4 : 3 : 2 : 1 : 0 :
        +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
          :   :   :   :   :   :   :   :   :   :   :   :   :   :   :   :
          h   h   h   h   h   m   m   m   m   m   m   x   x   x   x   x

        dove

                   h e' il numero delle ore  (0-23)
                   m e' il numero dei minuti (0-59) 
                   x e' il numero di incrementi di due secondi


        Bytes 24-25

        Mentre nei precedenti due bytes veniva conservata l'ora in questi 
        ritroviamo  la  data  della  creazione  del  file  o  dell'ultima 
        modifica.

        :---------- Byte 25 ------------:---------- Byte 24 ------------:

        +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
        :15 :14 :13 :12 :11 :10 : 9 : 8 : 7 : 6 : 5 : 4 : 3 : 2 : 1 : 0 :
        +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
          :   :   :   :   :   :   :   :   :   :   :   :   :   :   :   :
          y   y   y   y   y   y   y   m   m   m   m   d   d   d   d   d

        dove

                   y e' l'anno    (0-119)
                   d e' il giorno (1-31)
                   m e' il mese   (1-12)


        Bytes 26-27


        Ecco finalmente il valore che indica dove inizia il file.
        Parlando  precedentemente  della FAT avevamo accennato  a  questo 


                                       255





        Linguaggio C per MS DOS - F. Bernardotti - 1987 Opus Free Soft






        campo della directory dicendo che da questo iniziava la catena di 
        assegnazione dello spazio della FAT.
        Il  technical reference riporta che il primo cluster per i  dati, 
        sia  nel  caso del disco fisso che in quello  dei  dischetti,  e' 
        sempre il cluster 002.


        Bytes 28-31


        In questi due bytes viene conservata la dimensione del file.
        La prima word (2 bytes) contiene la parte bassa del valore mentre 
        la seconda la parte alta.
        Il  discorso  partito dal servizio 1BH e' un po'  degenerato  ma, 
        come  avevo  detto  prima,  era necessario  per  chiarire  alcuni 
        concetti fondamentali che il servizio stesso tratta.
        Sarebbe possibile leggere direttamente su disco il settore in cui 
        sono  conservati  questi dati relativi alla FAT e alla  directory 
        mediante il gia' citato int 25H.
        Mediante  la  call  1BH e' possibile  avere  comodamente  i  dati 
        basilari  della  FAT senza dover eseguire operazione  di  lettura 
        diretta.
        I valori riportati sono i seguenti.
        DS:BX puntano al byte di identificazione della FAT (ID) del drive 
        di default.
        DX contiene il numero totale di cluster su disco mentre AL indica 
        quanti settori sono riservati per ogni unita' di allocazione.
        In  genere  questo  valore e' uno nel caso di  dischetti  singola 
        faccia mentre e' due nel caso di doppia faccia.
        In ultimo CX contiene il numero di bytes per ogni settore.
         

        1CH -  Allocation Table Information for Specific Device


        Il  servizio e' in pratica uguale al 1BH solo che in questo  caso 
        non  e' piu' relativo al disco di default ma mediante il registro 
        DL,  in  ingresso,  e' possibile specificare il numero del  drive 
        interessato (0 = default, 1 = A:, ecc.).


        21H - Random Read


        Il servizio legge un blocco casuale da un file.
        Il  numero  del  blocco deve essere specificato nel  FCB  che  e' 
        puntato da DS:DX alla chiamata della funzione.






                                       256





        Linguaggio C per MS DOS - F. Bernardotti - 1987 Opus Free Soft






        I  valori  restituiti  sono contenuti in  AL  e  precisamente  si 
        possono avere le seguenti condizioni.


                       00H - Lettura eseguita con successo
                       01H - Lettura fallita (EOF)
                       02H - DTA troppo piccolo
                       03H - Lettura parziale (EOF)



        22H -  Random Write


        All'opposto del servizio 21H che legge questo scrive un record in 
        un file casuale.
        Anche in questo caso, come per la funzione precedente,  il numero 
        del  blocco  deve essere settato all'interno dell'apposito  campo 
        del FCB che viene puntato dai registri DS:DX.
        I valori riportati in AL dal servizio sono :


                       00H - Scrittura eseguita con successo
                       01H - Disco pieno
                       02H - DTA troppo piccolo



        23H -  File Size


        Il servizio 23H riporta le dimensioni di un determinato file.
        Il registro AL puo' restituire due diversi valori

                       00H - il file e' stato trovato
                       FFH - il file non e' stato trovato

        La   dimensione   del  file  non  viene  riportata   direttamente 
        all'interno di qualche registro ma bensi' piazzata  nell'apposito 
        campo del FCB (Bytes 16-19).


        24H -  Set Realtive Record Field


        Setta  il  campo  del  record casuale  in  modo  che  corrisponda 
        agli attuali campi dei record del FCB.
        Si  deve,  in genere,  chiamare questa funzione prima di eseguire 
        una lettura o una scrittura random.




                                       257





        Linguaggio C per MS DOS - F. Bernardotti - 1987 Opus Free Soft






        25H -  Set Interrupt Vector


        Questa  call non risultera' nuova in quanto l'ho gia'  utilizzata 
        in un esempio precedente accennando soltanto al suo scopo.
        Mediante questa funzione e' possibile settare l'indirizzo di  una 
        routine di servizio di un interrupt.
        Piu'  avanti  vedremo   la  funzione opposta  ovvero  quella  che 
        riporta il segmento e l'offset di un interrupt specificato (anche 
        questa   e'  gia'  stata  utilizzata  precedentemente  in  alcuni 
        esempi).
        In  quali casi ritorna utile scriversi delle particolari funzioni 
        di servizio degli interrupts o modificare quelle esistenti ?
        Rispondere  in  modo  preciso alla domanda non  e'  possibile  in 
        quanto  esistono  un  infinita' di  situazioni  in  cui  potrebbe 
        rivelarsi  utile modificare o addirittura scrivere le routine  di 
        servizio.
        Un  esempio potrebbe essere portato da un programma residente  in 
        memoria.
        Le vie da seguire, in questo caso, potrebbero essere svariate.
        Uno  dei  metodi potrebbe essere la scrittura di una  routine  da 
        collegare   all'interrupt  di  timer  (INT  1CH)  che  esegua  un 
        controllo  periodico  sul  buffer  di  tastiera  per  individuare 
        eventuali tasti premuti.
        Un'altro  metodo,   gia'  visto  precedentemente,  e'  quello  di 
        modificare  il servizio di interrupt che serve la  tastiera  allo 
        scopo di fare eseguire un controllo sui codici dei caratteri.
        Un  altro esempio di scrittura integrale  potrebbe essere  quello 
        relativo alla gestione delle porte di comunicazione.
        In  alcuni  programmi di questo tipo si potrebbe  sostituire  una 
        routine di polling con una funzione di interrupt.
        In  altre parole al posto di testare mediante cicli ripetitivi lo 
        stato  del modem e della linea si potrebbe fare in modo  che  sia 
        una  chiamata  di  interrupt,  eseguita in  modo  automatico,  ad 
        assolvere al compito desiderato.
        La scrittura in linguaggio C di una routine di interrupt presenta 
        alcuni problemi eliminabili mediante alcune funzioni, da abbinare 
        al modulo principale, scritte in assembler.
        In  ogni caso preferisco rimandare l'argomentazione  all'apposito 
        capitolo  riguardante  la  scrittura di  programmi  residenti  in 
        memoria.
        Proprio  ultimamente  sono riuscito a reperire la  documentazione 
        riguardante  gli  interrupts  non documentati dalla  Microsoft  e 
        cioe' quelli definiti "strategici".
        Il  discorso penso che sara' abbastanza lungo ed e'  proprio  per 
        questo   motivo  che  ho  optato  per  una  trattazione  separata 
        dell'argomento.
        Per ora limitiamoci a ripetere la sintassi di utilizzo di  questo 
        servizio.




                                       258





        Linguaggio C per MS DOS - F. Bernardotti - 1987 Opus Free Soft






        AH contiene quindi 25H che e' il numero della call.
        DS:DX   puntano   al   segmento  e   all'offset   della   routine  
        dell'interrupt.  
        AL,  infine,  contiene  il numero dell'interrupt di cui si  vuole 
        settare l'indirizzo della funzione di servizio.
        La  call  25H  non  restituisce alcun  valore  dopo  la  chiamata 
        dell'interrupt 21H.


        26H -  Create New Program Segment


        Lo  scopo  della call e' quello di creare un  nuovo  segmento  di 
        programma per l'esecuzione di un processo caricato separatamente.
        Un esempio e' relativo al caricamento di un file di overlay.
        Il  registro  DX viene utilizzato per passare  alla  funzione  il 
        valore del paragrafo di segmento per il nuovo processo.
        Il  servizio  copia nel nuovo segmento creato il PSP relativo  al 
        programma chiamante ed esegue su questo alcune modifiche. 
        E' inutile dire che anche in questo caso il valore relativo  alla 
        call e' settato in AH.
        Non viene restituito alcun valore.
        Andando anche in questo caso  fuori dall'argomento e'  necessario 
        aprire  una parentesi riguardante il significato del PSP (Program 
        Segment Prefix).
        Quando  il Dos carica per l'esecuzione un programma  crea  quello 
        definito PSP.
        Si  tratta di un area di memoria collocata in testa al  programma 
        dove  vengono  conservati molti dati utilizzati dallo stesso  Dos 
        per l'esecuzione di questo.
        Il PSP viene sempre piazzato all'offset 0 nel segmento di codice.
        Il programma , se .COM, viene collocato all'offset 100H.
        In  caso  di  un programma .EXE  questo  valore  potrebbe  essere 
        diverso.
        Infatti  nel caso di un programma .EXE,  dopo il  caricamento,  i 
        regsitri DS e ES puntano al PSP mentre i registri CS, IP, SP e SS 
        sono settati al valore passato dal linker.
        A  differenza,  nei .COM,  tutti i registri di  segmento  puntano 
        inizialmente al PSP.
        Il registro IP,  in quest' ultimo caso,  punta sempre a 100H  nel 
        segmento di codice.
        Come  vedremo nei seguenti capitoli esistono alcune funzioni  che 
        permettono  di avere di ritorno il segmento in cui e' piazzato il 
        PSP o di settarlo.
        Un  discorso di questo tipo diventa importante nel momento in cui 
        si vuole scrivere un programma residente in memoria.
        Un  idea  piu'  chiara a riguardo del PSP  e'  possibile  farsela 
        guardando la sua struttura.





                                       259





        Linguaggio C per MS DOS - F. Bernardotti - 1987 Opus Free Soft






              0 +---------+--------+--------+-------------------+
                : INT 20H :Dim.Mem.: Riserv.: Dispacciatore  DOS:
              8 +---------+--------+--------+-------+-----------+
                :         :Terminate address:(IP,CS): CTRLC  IP :
             10 +---------+-----------------+---+---------------+
                :CTRLC CS :Critical Error IP,CS :               :
                +---------+---------------------+               :
                :                  Used by Dos        2C        :
                :                   5C +------------------------+
                :                      :  Formatted   Parameter :
                +----------------------+  Area 1  formatted  as :
                :                         standard unopened FCB :
                :                   6C +------------------------+
                :                      :  Formatted   Parameter :
                +----------------------+  Area 2  formatted  as :
                : unopened FCB (overlaid if FCB at 5C is opened):
             80 +-----------------------------------------------+
                :    Unformatted parameter area      (DTA)      :
            100 +-----------------------------------------------+


        Vediamo ora singolarmente ogni campo del PSP.
        Il primo campo inizia all'offset 00H ed e' lungo 2 bytes.
        Contiene  l'istruzione INT 20H che come vedremo e' uno dei metodi 
        per terminare un programma.
        Come  e' facile capire se il programma deve terminare  basta  che 
        punti a questo campo.
        Il secondo campo inizia all'offset 02H ed e' lungo 2 bytes.
        In  questo  viene  conservata  la  dimensione  della  memoria  in 
        paragrafi.
        Come  avevamo gia' detto,  parlando dei registri di segmento,  un 
        paragrafo e' lungo 10H bytes (16 in decimale).
        Da   questo   risulta  facile  calcolare  il  numero   di   bytes 
        disponibili.  (NUMERO PARAGRAFI x 16 = MEMORIA)
        In alcuni casi si  potrebbe  verificare che il  numero  di  bytes 
        riportati  non  corrispondano effettivamente all'ammontare  della 
        memoria rimasta libera.
        Alcuni  programmi  eseguono  delle  particolari  scritture  nelle 
        tabelle  del  Dos al fine di modificare l'indicatore  della  fine 
        della memoria disponibile.
        Saltando  il  terzo  campo che e' riservato al Dos  arriviamo  al 
        quarto ovvero a quello definito come dispacciatore delle funzioni 
        del Dos.
        Il campo si trova all'offset 05H ed e' lungo 5 bytes.
        Il suo scopo e' quello di contenere l'indirizzo della routine  di 
        controllo delle funzioni Dos (INT 21H).
        Il sesto campo, offset 0AH, e' lungo 4 byte e contiene  una copia 
        dell'indirizzo della routine di terminazione del programma.
        Questo infatti punta alla routine che deve essere eseguita quando 
        il programma termina.
        Un  altro campo inizia all'offset 0EH ed e' lungo 4 byte come  il 


                                       260





        Linguaggio C per MS DOS - F. Bernardotti - 1987 Opus Free Soft






        precedente.
        Viene  contenuta in questa locazione una copia dell'indirizzo  di 
        ctrl-break.
        A  partire  dall'offset  12H  per 4 byte  ritroviamo  il  vettore 
        d'errore (Critical error exit).
        All'offset 16H troviamo un'area di lavoro del Dos lunga 22 bytes.
        Il puntatore alle variabili d'ambiente sono all'offset 2CH. 
        Nei  due  bytes da questo offset sono scritti segmento  e  offset 
        dell'area in cui sono conservate le variabili di sistema.
        Per variabili di sistema intendo dire,  ad esempio,  il PATH,  il 
        PROMPT e variabili come quelle che avevamo settato per l'utilizzo 
        del compilatore.
        Il  successivo campo all'offset 2EH,  lungo 34  bytes,  e'  anche 
        questo destinato come area di lavoro del Dos.  

        All'offset  50H  ritroviamo  3  bytes  contenenti  le  istruzioni 
        assembler

                                     int 21H
                                     retf

        Costituisce un metodo per chiamare un int 21H senza farlo in modo 
        diretto.
        Si  setta  nel  registro  AH il numero della call  che  si  vuole 
        eseguire e si esegue un salto di programma a questo offset.
        All'offset  55H ritroviamo 43 bytes occupati dall'area  destinata 
        al FCB.
        Avevo  detto precedentemente parlando del passaggio di  argomenti 
        al  main()  di un programma in linguaggio C che  potevano  essere 
        utilizzate argc e argv per  indicare rispettivamente il numero di 
        argomenti  passati e la matrice contenente la stringa con i  vari 
        argomenti.
        Questi valori sono conservati all'offset 80H per quanto  riguarda 
        il  numero di argomenti e al 81H (lungo 127 byte) per la  stringa 
        con i vari parametri.
        Questi  ultimi  128 bytes vengono anche utilizzati come  area  di 
        trasferimento del disco (DTA).
        Il   programma  lanciato   processa  le  informazioni  che   sono 
        conservate  nell'area  degli argomenti passati e utilizza  questa 
        come DTA.
        Se  si  desidera  conservarli  e'  possibile  salvarli  in  altre 
        zone di memoria  oppure settare, mediante una delle call dell'int 
        21H appena viste, una differente area di trasferimento del disco.



        27H -  Random Block Read


        Questo servizio legge uno o piu' record da una posizione  casuale 
        all'interno del file.


                                       261





        Linguaggio C per MS DOS - F. Bernardotti - 1987 Opus Free Soft






        DS:DX  puntano  al  FCB aperto mentre CX contiene il  numero  dei 
        record da leggere.
        AL  restituisce l'esito dell'operazione (vedi servizio 21H) e  CX 
        il numero di blocchi effettivamente letti.



        28H -  Random Block Write


        Mentre il servizio precedente leggeva un certo numero di  blocchi 
        questo li scrive.
        DS:DX  puntano a un FCB aperto e CX contiene il numero di records 
        che devono essere scritti.
        Per i valori di ritorno restituiti in AL vedi il servizio 22H che 
        e'  simile  a  questo  con l'unica  differenza  che  permette  di 
        scrivere un solo record.
        CX   anche  in  questo  caso  conterra'  il  numero   di   record 
        effettivamente scritti.



        29H -  Parse Filename


        Il  servizio analizza una riga di comando alla ricerca di un file 
        espresso nella forma

                                 d:filename.ext

        e  se  trovato crea un FCB non aperto nella  memoria  puntata  da 
        ES:DI.
        DS:SI puntano alla stringa di comando da analizzare.
        Mediante  appositi settaggi dei bit del registro AL e'  possibile 
        specificare  il  modo in cui deve essere analizzata la  linea  di 
        comando.
        I  bit  da  4 a 7 sono ignorati mentre quelli da 0 a  3  hanno  i 
        seguenti significati :

        Bit  0  = 1  La specifica del file viene ricercata al di la'  dei 
                     separatori.

        Bit  1  = 1  L' identificatore del drive viene cambiato  nel  FCB 
                     soltanto  se questo viene specificato nella linea di 
                     comando che viene analizzata.

        Bit  2  = 1  Il  nome  del file nel FCB viene  cambiato  solo  se 
                     nella  linea di comando viene specificato un nome di 
                     file valido.
                     In   questo   modo  e'   possibile   nei   programmi 
                     specificare   un   nome  di  file  di   default   ed 


                                       262





        Linguaggio C per MS DOS - F. Bernardotti - 1987 Opus Free Soft


                     



                     eventualmente   modificarlo   mediante  un   comando 
                     diretto.

        Bit  3  = 1  L'estensione del file viene cambiata nel FCB solo se
                     nella linea di comando viene specificata.

        Le  informazioni  necessarie sono  salvate,  come  abbiamo  visto 
        prima, all' offset 80H del PSP (128 Bytes).
        Un esempio di utilizzo in assembler e' il seguente :

        ;Controlla la linea di comando e setta un FCB
        ;all'offset 5CH nel PSP

               mov    ah,29H
               mov    si,81H
               mov    di,5CH
               mov    al,1111b       ; bit value controls parsing
               int    21H
               

        Il servizio 29H restituisce i seguenti valori.

        AL  = 00H  Non ci sono caratteri jolly all'interno della linea di 
                   comando.
              01H  Ci sono caratteri jolly (* o ?) nella linea.
              FFH  Operazione fallita.

        DS:SI      Puntano  al  primo  carattere dopo  il  nome  di  file 
                   analizzato.
        ES:DI      Puntano al primo byte del FCB.

        Questa call non e' utilizzata con linee di comando che contengono 
        il path completo del file.
           


        2AH -  Get Date


        Il servizio acquisisce la data.
        In  ingresso  solo il registro AH conterra' il numero  dell  call 
        (2AH).
        In uscita si avranno i seguenti valori :

        AL =  Giorno della settimana (0 = Domenica, ...., 6 = Sabato)
        CX =  Anno (1980-2099)
        DH =  Mese (1 - 12)
        DL =  Giorno (1 - 31)





                                       263





        Linguaggio C per MS DOS - F. Bernardotti - 1987 Opus Free Soft






        Un esempio in linguaggio C.


        #include <stdio.h>
        #include <dos.h>

        union REGS inregs, outregs;

        static char *date[] = {
        "Domenica",
        "Lunedi",
        "Martedi",
        "Mercoledi",
        "Giovedi",
        "Venerdi",
        "Sabato"
        } ;

        main()
        {
           int var3, var4, var5, var6;
           inregs.h.ah = 0x2A;
           intdos ( &inregs, &outregs );
           var3 = outregs.h.al;
           var4 = outregs.x.cx;
           var5 = outregs.h.dh;
           var6 = outregs.h.dl;
           printf("di %s %ld:%ld:%ld\n", date[var3], var6, var5, var4);
        }



        2BH =  Set Date



        In questo caso la funzione serve a settare la data del Dos.
        I registri in ingresso devono contenere :

        AH  =  Numero call  (2BH)
        CX  =  Anno   (1980 - 2099)
        DH  =  Mese   (1 - 12)
        DL  =  Giorno (1 - 31)

        AL  viene  utilizzato per restituire l'esito  dell'operazione  di 
        settaggio e precisamente :

        00H  =  Data settata
        FFH  =  Data non settata.

        Un altro esempio :


                                       264





        Linguaggio C per MS DOS - F. Bernardotti - 1987 Opus Free Soft






        #include <stdio.h>
        #include <dos.h>

        union REGS inregs, outregs;

        main()
        {
           int var3, var4, var5;
           inregs.h.ah = 0x2B;
           printf("Giorno            : ");
           scanf("%d", &var3);
           inregs.h.dl = var3;
           printf("Mese              : ");
           scanf("%d", &var4);
           inregs.h.dh = var4;
           printf("Anno    1980-2000 : ");
           scanf("%d", &var5);
           inregs.x.cx = var5;
           intdos( &inregs, &outregs);
           if( outregs.h.al == 0xFF) {
              puts("\nData non valida");
              exit();
           }
        }



        2CH -  Get Time


        Riporta l'ora, minuti, secondi e centesimi di secondo.

        I registri interessati in uscita sono :

        CH = Ora       (0 - 23)
        CL = Minuti    (0 - 59)
        DH = Secondi   (0 - 59)
        DL = Centesimi (0 - 99)



        2DH -  Set Time


        Setta ora, minuti, secondi e centesimi.
        In  questo  caso i registri interessati sono uguali a quelli  del 
        servizio  precedente  solo  che devono essere  settati  prima  di 
        chiamare la funzione.





                                       265





        Linguaggio C per MS DOS - F. Bernardotti - 1987 Opus Free Soft





        2EH -  Set/Reset Verify Switch


        Il servizio se messo a stato attivo (ON) fa' in modo che ad  ogni 
        operazione  di  scrittura su disco corrisponda un  controllo  del 
        CRC.
        AL   conterra'   i  valori  relativi   all'attivazione   e   alla 
        disattivazione del servizio di verifica ovvero :

                                00H = Verify OFF
                                01H = Verify ON



        2FH -  Get Disk Transfer Address (DTA)


        Il  servizio  1AH serviva a settare l'area di  trasferimento  del 
        disco.
        Mediante  il servizio 2FH questa viene restituita mediante  ES:BX 
        che puntano alla zona di memoria utilizzata per questo scopo.



        30H -  Get DOS Version Number



        Il  servizio  30H riporta il numero della versione Dos su cui  si 
        lavora.
        Possono  verificarsi  dei  casi  in  cui  un  nostro  particolare 
        programma faccia riferimento a delle chiamate presenti solo nelle 
        versioni superiori a un certo numero di relase del Dos.
        In  questo caso e' necessario eseguire una verifica  relativa  al 
        numero di questa.
        Il numero di versione viene restituito suddiviso in due parti.
        Il  registro  AL  contiene  la parte maggiore  mentre  AH  quella 
        minore.

        Esempio : 
                           Vers.     3.20
                                     - --
                         +-----------+  +-----------+
                         :                          :
                    Parte maggiore           Parte  minore


        Nel seguente esempio viene controllata la versione del Dos.
        Se questa e' minore alla 3.00 il programma abortisce.





                                       266





        Linguaggio C per MS DOS - F. Bernardotti - 1987 Opus Free Soft






        #include <stdio.h>
        #include <dos.h>

        #define FROMVERS   3

        union REGS inregs,outregs;

        main()
        {
           inregs.h.ah = 0x30;
           intdos(&inregs,&outregs);
           printf("Dos Version %d.%d", outregs.h.al, outregs.h.ah);
           if(outregs.h.al < FROMVERS) {
              puts("Versione Dos non corretta");
              puts("Deve essere dalla 3.00 in poi");
              abort();
           }
        }


        31H -  Terminate Process and Remain Resident


        Il  servizio permette ad un programma di terminare ma di rimanere 
        allo stesso tempo residente in memoria.
        Esistono  altri  servizi che eseguono lo stesso compito  come  ad 
        esempio l' int 27H.
        Vedremo questi parlando dei programmi residenti in memoria.
        Il  servizio  31H  permette di restituire  in  uscita  un  codice 
        testabile mediante il sottocomando dos ERRORLEVEL.
        Questo  numero di codice viene passato come argomento in ingresso 
        nel servizio mediante il registro AL.
        Sempre in ingresso deve essere specificato il numero di paragrafi 
        che devono essere conservati residenti.
        Il registro che conservera' questo valore e' DX.



        32H -  Get Disk Information


        Questo servizio non e' stato documentato dalla Microsoft.
        Guardando  il  Technical Reference si nota che il  servzio  viene 
        definito come "Used Internally by DOS".
        In ogni caso il servizio restituisce informazioni riguardanti  il 
        lettore specificato nel registro DL. (0 = Default, 1 = A:, ecc.)
        In uscita vengono riportate le seguenti informazioni.
        AL contiene 00H se il drive specificato esiste.
        In caso contrario AL contiene FFH.
        DS:BX puntano al blocco di informazioni del disco che contiene le 
        notizie viste parlando dell'interrupt relativo ai floppy.


                                       267





        Linguaggio C per MS DOS - F. Bernardotti - 1987 Opus Free Soft





        Fate  attenzione  ad  utilizzare  questa funzione  in  quanto  il 
        registro DS viene cambiato.
        Questo  significa  che prima di eseguire la  call  e'  necessario 
        salvare   il   contenuto  di  questo  registro  allo   scopo   di 
        ripristinarlo dopo la chiamata stessa.


        33H -  Ctrl-Break Check


        Il servizio testa o setta lo stato del Ctrl-Break.
        AL contiene il codice dell'operazione da eseguire e precisamente

                           00H - Restituisce lo stato 
                           01H - Setta lo stato

        Lo stato viene specificato nel registro DL

                           00H - OFF
                           01H - ON

        Nel  caso che venga richiesta la funzione per avere di ritorno lo 
        stato del Ctrl-Break DL contiene in uscita

                           00H - Se in stato OFF
                           01H - Se in stato ON



        34H -  Find Active Byte


        Ed ecco un altra funzione non documentata.
        Questa  assume  una  notevole  importanza  per  la  scrittura  di 
        programmi  residenti  in  memoria  in  quanto  uno  dei  peggiori 
        ostacoli  per la scrittura di questi ultimi e'  costituita  dalle 
        funzioni non rientranti.
        Tutte le call del Dos non sono rientranti.
        Il  "byte attivo" conta il numero delle chiamate al Dos che  sono 
        processate al momento della call.
        Il  registro  ES restituisce il segmento del byte  attivo  mentre 
        l'offset e' contenuto in BX.
        Anche  in questo caso bisogna prestare attenzione al fatto che la 
        call cambia il registro ES.



        35H -  Get Vector


        Di  questa  call  e'  gia'  stato  fatto  uso  in  alcuni  esempi 
        precedenti.


                                       268





        Linguaggio C per MS DOS - F. Bernardotti - 1987 Opus Free Soft





        Il servizio restituisce in ES:BX  segmento e offset della routine 
        di  servizio di un determinato interrupt specificato in  ingresso 
        mediante il registro AL.
        Nel  momento in cui si modifica un vettore di interrupt  mediante 
        il  servizio  25H  e' conveniente salvare  il  vecchio  indirizzo 
        mediante  questa  call allo scopo di poterlo  ripristinare  prima 
        della fine del nostro programma.


        36H -  Get Disk Free Space


        Il   servizio  restituisce  un  certo  numero   di   informazioni 
        riguardanti  il  disco  specificato in ingresso nel  registro  DL 
        (0 = default, 1 = A:, ecc.).
        I registri in uscita specificano :

        BX = Cluster disponibili
        DX = Numero totale di cluster
        CX = Bytes per settore
        AX = Restituisce FFFFH se si e' verificato un errore.

        E'  possibile  mediante  alcuni calcoli  risalire  alle  seguenti 
        informazioni :

        CX*AX*DX     =  Spazio totale disco
        CX*AX*BX     =  Spazio libero
        CX*AX        =  Bytes per cluster
        (BX*100)/DX  =  Percentuale libera su disco

        Un esempio in linguaggio C.

        #include <stdio.h>
        #include <dos.h>

        union REGS inregs, outregs;
        long val_bx, val_dx, val_cx, val_ax;

        main()
        {
           inregs.h.ah = 0x36;
           inregs.h.dl = 0x00;
           intdos(&inregs, &outregs);
           val_bx = outregs.x.bx;
           val_dx = outregs.x.dx;
           val_cx = outregs.x.cx;
           val_ax = outregs.x.ax;
           printf("\n%8ld bytes per cluster",val_cx*val_ax);
           printf("\n%8ld bytes totali disco",val_cx*val_ax*val_dx);
           printf("\n%8ld bytes liberi", val_cx*val_ax*val_bx);
           printf("\n%8d %% libero", (val_bx*100) / val_dx);
         }


                                       269





        Linguaggio C per MS DOS - F. Bernardotti - 1987 Opus Free Soft





        37H -  Determine or set DOS switch character


        Si  tratta  anche in questo caso di una funzione normalmente  non 
        documentata dal Technical Reference.
        Il carattere di switch normalmente utilizzato dal Dos e' /.
        Si  tratta  del carattere utilizzato per separare  gli  argomenti 
        sulla linea di comando.
        Esempio:

                         FORMAT A: /S   oppure    DIR /W

        E'   possibile   mediante  un  opportuno  settaggio   di   valore 
        all'interno  del  registro  AL  settare  o  avere  restituito  il 
        carattere di switch.

                     AL = 0  Restituisce il carattere in DL
                     AL = 1  Setta il carattere inserito in DL

        Anche in questo caso un esempio in linguaggio C.

        #include <stdio.h>
        #include <dos.h>

        union REGS inregs, outregs;

        main()
        {
           int c;
           puts("\n\na .. Set switch character");
           puts("b .. Determine switch character");
           c = getch();
           if(c == 'a' ||c == 'A') set();
           inregs.h.ah = 0x37;
           inregs.h.al = 0x00;
           intdos(&inregs, &outregs);
           printf("\n\nActual switch character is %c", outregs.h.dl);
        }

        set()
        {
           int c;
           printf("\n\nEnter new switch character : ");
           c = getche();
           inregs.h.ah = 0x37;
           inregs.h.al = 0x01;
           inregs.h.dl = c;
           intdos(&inregs, &outregs);
        }

        Dopo  aver  compilato  il  programma  usate  la  funzione  set  e 
        passategli come argomento, ad esempio, il carattere '%'.


                                       270





        Linguaggio C per MS DOS - F. Bernardotti - 1987 Opus Free Soft






        Provate a questo punto a fare DIR %W invece di DIR /W.



        38H -  Get or Set Country Dependent


        Il servizio permette ai programmi di adattarsi automaticamente ai 
        formati relativi alla zona specificata.
        Nel  caso che si vogliano restituiti i dati relativi a  un  certo 
        paese  DS:DX  puntano a un area di memoria in cui  devono  essere 
        salvate le informazioni.
        I campi di questa zona di memoria sono i seguenti :


        Campo   Lunghezza  Descrizione
        -----------------------------------------------------------------
          1     2 Bytes    Formato data
          2     5 Bytes    Simbolo valuta (Esempio USA $)
          3     2 Bytes    Separatore migliaia (. , spazio)
          4     2 Bytes    Separatore decimali (. ,)
          5     2 Bytes    Separatore data
          6     2 Bytes    Separatore ora
          7     1 Byte     Collocazione simbolo valuta 1 = prima,0 = dopo 
          8     1 Byte     Posizioni decimali valuta
          9     1 Byte     Formato ora 0 = clock 12 ore 1 = clock 24 ore
         10     4 Bytes    Indirizzo subroutine per determinazione    uso
                           lettere minuscole e maiuscole
         11     2 Bytes    Carattere separazione liste (Es. A, B, ecc.)
         

        Il  primo  campo,  quello relativo al formato  della  data,  puo' 
        assumere uno dei seguenti valori:

                            0 = USA      mese giorno anno
                            1 = Europa   giorno mese anno
                            2 = Giappone anno mese giorno

        In ingresso e' possibile specificare in AL 255 codici di paese.
        Se il numero e' maggiore di 255 in AL si settera' FFH e il codice 
        del paese verra' messo nel registro BX.
        In caso che si passi un codice di paese errato allora il servizio 
        setta il flag di carry e restituisce in AL il codice d'errore.
        Se si vogliono invece settare i parametri il registro DX contiene 
        FFFFH e AL il codice del paese.
        Anche in questo caso vale il discorso fatto prima per la funzione 
        che  restituisce  le  informazioni e cioe' che se il  numero  del 
        paese  e' superiore a 255 allora AL contiene FFH e il codice  va' 
        messo in BX.




                                       271





        Linguaggio C per MS DOS - F. Bernardotti - 1987 Opus Free Soft






        39H -  Create Subdirectory (MKDIR)


        Il servizio crea una subdirectory.
        DS:DX puntano a una stringa ASCII in cui deve essere  specificato 
        il path.
        In  caso  di errore il flag di carry viene settato e in AX  viene 
        restituito il codice d'errore.


        3AH -  Remove Subdirectory (RMDIR)


        Anche in questo caso DS:DX puntano a una stringa ASCII contenente 
        il path della subdirectory da rimuovere.
        In  caso  di  errore il comportamento del flag  di  carry  e  del 
        registro AX e' lo stesso di quello della funzione precedente.


        3BH -  Change the Currebt Directory (CHDIR)


        Vale  per  questo  servizio lo stesso discorso fatto per  le  due 
        funzioni precedenti.


        3CH -  Create a File


        Il servizio crea un nuovo file oppure tronca uno gia' esistente a 
        lunghezza 0.
        In  ingresso DS:DX puntano alla stringa ASCII contenente il  path 
        del file da creare.
        CX contiene l'attributo.
        Dopo  la chiamata AX potrebbe contenere il codice  d'errore,  nel 
        caso che il flag di carry sia settato,  oppure l'handle di 16 bit 
        del file creato, nel caso che non sia settato il flag di carry.
        Se   l'operazione  ha   successo  il  file  viene   aperto   come 
        read/write.
         

        3DH -  Open a File


        DS:DX puntano a una stringa ASCII contenente il path del file che 
        deve essere aperto mentre AL il codice relativo al modo.
        Il  registro  AX,  come  per  il  servizio  precedente,  potrebbe 
        ritornare o il codice d'errore oppure l'handle del file.
        In caso d'errore il flag di carry viene settato.
        Il codice relativo al modo contenuto in AL e' costituito da campi 
        bit oriented e precisamente i seguenti.


                                       272





        Linguaggio C per MS DOS - F. Bernardotti - 1987 Opus Free Soft





                    I - Flag di eredita' (Inheritance flag)
                    R - Campi riservati
                    A - Campi d'accesso (Access field)
                    S - Campi di condivisione (Sharing mode field)

        La mappatura e' la seguente

                        +---+---+---+---+---+---+---+---+
                  AL    : 7 : 6 : 5 : 4 : 3 : 2 : 1 : 0 :
                        +---+---+---+---+---+---+---+---+
                          :   :   :   :   :   :   :   :
                          I   S   S   S   R   A   A   A

        Il  flag  I specifica' se il file aperto puo' essere lasciato  in 
        "eredita'"  a  un  processo  secondario  lanciato  dal  programma 
        principale.
        Se questo viene messo a 1 significa che il file aperto e' privato 
        e quindi non puo' essere utilizzato senza opportuna operazione di 
        riapertura da parte di un processo minore.
        Chiaramente  se  questo  flag e' a 0  il  significato  e'  quello 
        contrario.
        Le  combinazioni  dei  bit del campo  S,  quelli  riservati  alle 
        specifiche relative alla condivisione, sono :

                         0 0 0 : Modo di compatibilita'
                         0 0 1 : Modo inibizione lettura/scrittura
                         0 1 0 : Modo inibizione scrittura
                         0 1 1 : Modo inibizione lettura
                         1 0 0 : Modo nessuna inibizione

        Il bit indicato come riservato deve essere messo a 0.
        Gli ultimi bit indicano il modo di accesso al file e precisamente

                         0 0 0 : Read
                         0 0 1 : Write
                         0 1 0 : Read/Write

        Il concetto di multitasking e' introdotto dalla versione 3.00 del 
        Dos  e quindi se la funzione viene richiamata da un programma che 
        gira sotto una versione precedente gli accessi permessi sono solo 
        quelli relativi ai bit del settaggio del modo.
        Nel  caso in cui il vostro programma pretenda il settaggio  anche 
        degli  altri  campi potete utilizzare una delle  funzioni  appena
        viste (Get DOS Version Number) per accertarvi che la versione Dos 
        sia corretta.


        3EH -  Close a File Handle


        Il  servizio  chiude un file  legato  all'handle  precedentemente 
        ritornato da una funzione creat o open.


                                       273





        Linguaggio C per MS DOS - F. Bernardotti - 1987 Opus Free Soft





        Il numero dell'handle e' specificato nel registro BX.
        Di ritorno, se il flag di carry e' settato, AX contiene il codice 
        d'errore.


        3FH -  Read from a File or Device


        Il servizio e' molto simile alla funzione read del linguaggio C.
        BX  contiene il numero relativo all' handle del file o del device 
        su cui si vuole leggere.
        DS:DX puntano al buffer che dovra' contenere i dati letti.
        CX contiene infine il numero di byte che devono essere letti.
        Di  ritorno  AX conterra',  se il flag di carry  e'  settato,  il 
        codice  d'errore oppure,  in caso contrario,  il numero di  bytes 
        effettivamente letti.
        Se i byte ritornati da AX sono maggiori di 0 ma minori di  quelli 
        richiesti  in  CX significa che e' stata incontrata la  fine  del 
        file.


        40H -  Write to a File or Device


        Simile  al  servizio precedente con la differenza che  in  questo 
        caso la funzione svolta e' di scrittura.
        BX  si  riferisce  all'handle del file su cui si  vuole  eseguire 
        l'operazione.
        DS:DX puntano ai dati che devono essere scritti.
        CX contiene il numero di bytes.
        AX,   come  nella  call  precedente,  puo'  contenere  il  codice 
        d'errore,  se  il flag di carry e' settato,  oppure il numero  di 
        bytes effettivamente scritti.



        41H -  Delete a File from a Specified Directory


        La call 41H cancella un file dalla directory specificata.
        DS:DX  puntano alla stringa ASCII contenente il path con il  nome 
        del file da eliminare.
        Se  il flag di carry e' settato AX contiene in uscita  il  codice 
        d'errore.


        42H -  Move File Read/Write Pointer


        In   pratica   il   servizio  svolge  un   operazione   di   SEEK 
        (posizionamento) su di un file.
        In  tutto  simile alle funzioni del linguaggio C lseek e fseek  i 


                                       274





        Linguaggio C per MS DOS - F. Bernardotti - 1987 Opus Free Soft





        parametri passati mediante i registri sono i seguenti.
        CX:DX contengono il nuovo offset ovvero la distanza da muovere in 
        bytes considerando che CX contiene la parte piu' significativa.
        AL contiene il riferimento da cui contare l'offset ossia

                     0  Il puntatore e' mosso di CX:DX bytes 
                        dall'inizio del file.
             
                     1  Il puntatore e' mosso di CX:DX bytes
                        dalla posizione attuale.

                     2  Il puntatore e' mosso alla fine del file.

        Di ritorno, se il flag di carry e' settato, AX contiene il codice 
        d'errore.
        In  caso  negativo  DX:AX  contengono  la  nuova  locazione   del 
        puntatore.


        43H -  Change File Mode (CHMOD)


        A  riguardo  degli attributi di un file abbiamo gia'  parlato  in 
        molti casi.
        Riguardate ad esempio il paragrafo in cui erano descritti i campi 
        della directory.
        Il servzio serve appunto a cambiare questi attributi.
        DS:DX  puntano alla stringa ASCII con il path del file di cui  si 
        vuole cambiare il modo.
        CX contiene l'attributo.
        AL contiene il codice della funzione.
        Se  in  AL  si  setta 00H allora il servizio  restituisce  in  CX 
        l'attributo del file specificato.
        Nel caso che AL contenga 01H la funzione da eseguire e' quella di 
        settaggio dell'attributo.
        Nel seguente esempio il file specificato alla richiesta di  input 
        viene settato come "file nascosto".
              
        /* 
         * HIDDEN.C - F. Bernardotti
         */

        #include <stdio.h>
        #include <dos.h>

        union REGS inregs, outregs;

        struct SREGS segregs;

        char path[50];

        char far *var = path;


                                       275





        Linguaggio C per MS DOS - F. Bernardotti - 1987 Opus Free Soft





        main()
        {
           puts("Hidden File");
           printf("\nFile : ");
           gets(path);
           segregs.ds  = FP_SEG(var);
           inregs.x.dx = FP_OFF(var);
           inregs.h.ah = 0x43;
           inregs.h.al = 0x00;
           intdosx(&inregs,&outregs,&segregs);
           inregs.h.cl = outregs.h.cl | 2;
           inregs.h.ah = 0x43;
           inregs.h.al = 0x01;
           intdosx(&inregs,&outregs,&segregs);
        }


        Vengono  utilizzate tutte e due le funzioni del servizio 43H (Get 
        e Set).
        La prima (Get) riporta gli attributi attuali del file.
        A  questi,  mediante un operazione di OR,  viene forzato  il  bit 
        relativo all' attributo HIDDEN.
        Successivamente viene riscritto mediante la funzione set.


        44H -  I/O Control for Devices (IOCTL)


        Il servizio esegue alcune funzioni per il controllo dell' I/O sui 
        devices.
        DS:DX puntano, a seconda dell'operazione che si intende svolgere, 
        a un area data oppure a un buffer.
        In  caso  di operazioni di lettura o di scrittura CX contiene  il 
        numero  di  bytes  che  devono  essere,per  l'appunto,   letti  o 
        scritti.
        Il servizio viene selezionato mediante il registro AL.

        AL = 00H  Riporta informazioni su un device (DX)
        AL = 01H  Setta  informazione su un device.  DH deve essere 0 per 
                  questo servizio.
        AL = 02H  Legge il numero di byte specificato in CX  all' interno
                  del buffer puntato da DS:DX.
        AL = 03H  Scrive il numero di byte specificato  in  CX. L'area di
                  memoria con i dati per l'operazione e' puntata da DS:DX
        AL = 04H  Uguale ad AL = 02H ma solo che qui e' possibile settare
                  il numero del drive (0 = default, 1 = A: ecc.)
        AL = 05H  Uguale ad AL = 03H ma anche in questo caso e' possibile 
                  specificare il drive.
        AL = 06H  Riporta lo stato dell'input.
        AL = 07H  Riporta lo stato dell'output.
        AL = 08H  Nelle  versioni  successive alla relase  3.00  del  Dos 
                  questo riporta se il device e' fisso o rimovibile.


                                       276





        Linguaggio C per MS DOS - F. Bernardotti - 1987 Opus Free Soft





        AL = 0BH  Anche questo servizio e' disponibile dalla relase  3.00
                  del  Dos.  Specifica il numero di tentativi che il  Dos 
                  deve effettuare per tentare di accedere a un file.
                  Riguarda problemi di condivisione di un file.

        Di ritorno dal servizio AX riporta, nel caso che il flag di carry 
        non sia settato, il numero di bytes trasferiti (in riferimento ai 
        servizi AL = 2,  3,  4 e 5) oppure FFH = ready,  00H = Not  Ready 
        (funzioni 6 e 7).
        In caso contrario AX contiene un codice d'errore.
        I bits del registro DX nel caso delle calls 00H e 01H valgono :

        +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
        :15 :14 :13 :12 :11 :10 : 9 : 8 : 7 : 6 : 5 : 4 : 3 : 2 : 1 : 0 :
        +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
          :   :   :   :   :   :   :   :   :   :   :   :   :   :   :   :
          R   C   +---- RISERVATI ----+   I   E   B   R   I   I   I   I
          I   T                           S   O   I   I   S   S   S   S
          S   R                           D   F   N   S   C   N   C   C
          *   L       *                   E       A       L   U   O   I
                                          V       R       K   L   T   N

        Se il bit ISDEV e' a 1 significa che ci si riferisce a un device.
        Se ISDEV,  in caso contrario,  e' a 0 allora si ha a che fare con 
        un file su disco.
        In questo ultimo caso tutti i bit contrassegnati da 8 a 15 devono 
        essere a 0.
        I  bit,  nel  caso  di  un device  (ISDEV=1),  hanno  i  seguenti 
        significati.
                     EOF    = 0 Fine del file.
                     BINARY = 1 Se si opera in modo binario
                                Il carattere CTRL Z e' ignorato.
                              0 Si opera in modo ASCII.
                                CTRL Z ha significato di fine file.
                     ISCLK  = 1 Indica che il device e' il clock.
                     ISNUL  = 1 Indica il device NUL
                     ISCOT  = 1 Il device di output e' la console.
                     ISCIN  = 1 Il device di input  e' la console.
                     CTRL   = 0 Il device non elabora stringhe di
                                controllo durante lettura/scrittura.
                     
        Riporto  ora alcuni servizi legati a questa call non  documentati 
        dal Technical Reference del Dos.
        Il numero del servizio,  come per i precedenti,  sono selezionati 
        mediante l'opportuno settaggio del registro AL.

        AL = 09H  Testa se il device e' locale o remoto.
                  BL  contiene il numero del drive (0 = default,  1 =  A: 
                  ecc.).
                  Il bit 12 del registro DX e' settato in uscita nel caso 
                  che il device sia remoto.



                                       277





        Linguaggio C per MS DOS - F. Bernardotti - 1987 Opus Free Soft




        AL = 0AH  Testa se l'handle e' remoto o locale.
                  BX contiene l'handle del file.
                  Il bit 15 del registro DX viene settato nel caso che si 
                  tratti di un handle remoto.

        AL = 0EH  Testa il numero di lettere assegnate a un certo device.
                  Mediante   un  operazione  di  ASSIGN  da  Dos  sarebbe 
                  possibile indicare con piu' lettere lo stesso drive.
                  BL  contiene  il  numero del drive a cui  ci  si  vuole 
                  riferire.
                  In  uscita  AL  riportera'  0 se solo  una  lettera  e'  
                  riferita al drive.
                  Se  il  numero  di lettere  e'  maggiore  questo  sara' 
                  contenuto sempre in AL.
                  Nel  caso  che si verifichi un errore il flag di  carry 
                  viene settato e il codice di errore viene restituito in
                  AX.

        AL = 0DH  Questo servizio riporta molte informazioni suplementari
                  sul device specificato.
                  AL contiene 13 (0DH).
                  BL il numero del drive a cui ci si vuole riferire.
                  CL viene settato con 96 (60H) e CH con 8.
                  Di ritorno DS:DX puntano al blocco di parametri.
                  ATTENZIONE: DS viene cambiato dal servizio.

        Il  blocco  di parametri a cui puntano di ritorno DS:DX  hanno  i 
        seguenti significati.

        BYTE      DESCRIZIONE

        0         0 se  e' un  BPB  (BIOS parameter Block)  costruito  e' 
                    stato riportato.
                  1 se e' un BPB di default che e' stato restituito.

        1         A   seconda del valore contenuto in questo  byte  e' 
                  possibile risalire alle seguenti informazioni.
                  0  5.25'' double density disk             
                  1  5.25'' high density disk
                  2  3.5'' disk
                  3  8'' single density disk
                  4  8'' double density disk
                  5  Fixed disk
                  6  Tape driver
                  7  Other

        2         Contiene gli attributi del device
                  0  Se il device e' un disco fisso
                  1  Se il device e' rimovibile

        3-4       Numero di tracce

        5         Tipo nel drive. 0 = default


                                       278





        Linguaggio C per MS DOS - F. Bernardotti - 1987 Opus Free Soft





        BYTE      DESCRIZIONE

        6-7       Bytes per settore

        8         Settori per cluster

        9-10      Settori riservati (boot)

        11        Numero delle FAT'S

        12-13     Numero di ingressi nella root directory

        14-15     Numero di settori

        16        Disk type byte

        17-18     Settori per FAT

        19-20     Settori per traccia

        21-22     Facce

        23-26     Settori nascosti (HIDDEN)

        Con  questo  ho concluso la descrizione di  questo  servizio  che 
        tutto sommato offre molte caratteristiche utilizzabili nei nostri 
        programmi.



        45H -  Duplicate a File Handle (DUP)


        BX  contiene  il  numero  dell'handle del file  che  deve  essere 
        duplicato.
        Di ritorno,  se il flag di carry non e' settato,  AX contiene  un 
        nuovo handle del file.
        In caso contrario AX contiene il codice d'errore.
        Fate attenzione che ogni operazione eseguita con il nuovo  handle 
        sono riflesse su quello vecchio.



        46H -  Force a Duplicate of a Handle (CDUP)


        Il servizio e' simile a quello precedente solo che in questo caso 
        viene fornito il numero del secondo handle.
        Questo deve essere gia' esistente.
        In  altre parole nel servizio 45H il secondo handle viene  creato 
        automaticamente  dal  Dos  mentre  in  questo  viene  passato  in 
        ingresso mediante il registro CX. 


                                       279





        Linguaggio C per MS DOS - F. Bernardotti - 1987 Opus Free Soft





        BX contiene l'handle originale.
        Il secondo handle potrebbe essere uno non in uso per cui si vuole 
        ridefinire lo scopo.
        AX  potrebbe ritornare,  sempre nel caso che il flag di carry sia 
        settato, il codice d'errore.



        47H -  Get Current Directory


        Il  servizio restituisce nella zona di memoria di 64 byte puntata 
        da  DS:SI  il  path attuale relativo  al  drive  specificato  nel 
        registro DL (0 = default, 1 = A: ecc.)
        AX  restituisce,  nel caso che il flag di carry sia  settato,  il 
        codice d'errore.
        Vediamo un esempio.

        /*
         * GETDIR.C
         */

        #include <stdio.h>
        #include <dos.h>

        union REGS inregs,outregs;
        struct SREGS segregs;

        unsigned char directory[64];

        char far *var = directory;

        main(argc,argv)
        int argc;
        char *argv[];
        {
           int drive = 0;
           if(argc > 1) {
              switch(*argv[1]) {
                 case 'a':
                 case 'A':
                    drive = 1;
                    break;
                 case 'b':
                 case 'B':
                    drive = 2;
                    break;
                 case 'c':
                 case 'C':
                    drive = 3;
                    break;
                                                            Segue ....


                                       280





        Linguaggio C per MS DOS - F. Bernardotti - 1987 Opus Free Soft





                 case 'D':
                 case 'd':
                    drive = 4;
                    break;
                 default:
                    break;
              }
           }
           inregs.h.ah = 0x47;
           inregs.h.dl = drive;
           inregs.x.si = FP_OFF(var);
           segregs.ds  = FP_SEG(var);
           intdosx(&inregs,&outregs,&segregs);
           if(outregs.x.cflag == 1) {
              puts("Fatal error");
              abort();
           }
           printf("\n\nActual directory is \\%s\n\n", directory);
        }



        48H -  Allocate memory


        Il servizio alloca il numero di paragrafi specificati in ingresso 
        nel registro BX.
        Di  ritorno  AX:0 (segmento in AX,  offset 0) punta al blocco  di 
        memoria allocato.
        In caso di errore,  indicato sempre dal flag di carry settato, AX 
        restituisce il codice d'errore.
        Un errore possibile e' dovuto al fatto di richiedere piu' memoria
        di quanta ne sia disponibile.
        In  questo  caso  BX ritorna la  grandezza  massima  che  sarebbe 
        possibile allocare per un blocco.



        49H -  Free Allocated Memory


        La call libera la memoria allocata dal servizio precedente.
        ES punta al segmento del blocco che deve essere liberato.
        AX restituisce, eventualmente, il codice d'errore.



        4AH -  Modify Allocated Memory Blocks (SETBLOCK)


        Nel  caso  che  la memoria allocata dalla call 48H  debba  essere 
        modificata, aumentata o diminuita, e' possibile utilizzare questo 


                                       281





        Linguaggio C per MS DOS - F. Bernardotti - 1987 Opus Free Soft





        servizio per farlo.
        ES punta al blocco di memoria.
        BX contiene la dimensione del nuovo blocco in paragrafi.
        AX  ritorna il codice d'errore nel caso che il flag di carry  sia 
        settato.
        BX,  come per il servizio 48H,  riporta la dimensione massima che 
        potrebbe essere allocata.


        4BH -  Load or Execute a Program (EXEC)


        Questa funzione permette a un programma di caricare in memoria un 
        altro programma e di eseguirlo.
        DS:DX puntano a una stringa ASCII contenente il drive,  il path e 
        il nome del file che deve essere eseguito.
        AL  contiene  il codice relativo alla funzione  che  deve  essere 
        eseguita.

        AL  =  00H   Il programma e' letto e viene per questo  creato  un 
                     nuovo PSP.
                     L'esecuzione del programma e' automatico.

        AL  =  01H   Il programma e'letto ma non viene creato nessun PSP.
                     L'esecuzione  in  questo caso non e'  automatica  ma 
                     deve  avvenire mediante una chiamata  dal  programma 
                     principale.
                     Questo  servizio  viene  utilizzato per  la  lettura 
                     degli overlay.

        Gli  oggetti  puntati da ES:BX variano a seconda  della  funzione 
        selezionata in AL.
        Nel caso di AL = 00H ES:BX puntano a un blocco di 14 bytes con le 
        seguenti informazioni.


        BYTE   LUNGHEZZA   DESCRIZIONE

        0          2       Indirizzo   segmento   con  la  variabili   di 
                           environment che devono essere passate.
        2          4       Puntatore  alla  stringa di comando  che  deve 
                           essere passata al PSP.
        6          4       Puntatore al FCB di default da passare al PSP.
        10         4       Puntatore al secondo FCB di default.


        La  funzione carica/esegui intaccano il contenuto dei registri SS 
        e  SP  che devono essere quindi salvati e ripristinati  prima  di 
        terminare.





                                       282





        Linguaggio C per MS DOS - F. Bernardotti - 1987 Opus Free Soft





        Nel caso di AL = 01H allora ES:BX puntano a un blocco dati con le 
        seguenti caratteristiche.

        BYTE   LUNGHEZZA   DESCRIZIONE

        0          2       Segmento dove deve essere caricato il file.
        2          2       Fattore di riallocazione per i programmi .EXE

        AX  ritorna  il codice d'errore oppure nulla se  la  funzione  ha 
        avuto esito positivo.


        4CH -  Terminate a Process (EXIT)


        Il  servizio termina un programma restituendo al Dos un codice di 
        uscita  specificabile nel registro AL e testabile mediante la  la 
        pseudo istruzione ERRORLEVEL.  
        Un esempio e' il seguente.
        Il programma viene richiamato dal seguente file .BAT .

        echo off
        prog
        if ERRORLEVEL 1 goto scelta1
        if ERRORLEVEL 2 goto scelta2
        if ERRORLEVEL 3 goto scelta3
        goto fine
        :scelta1
        echo carico scelta 1
        goto fine
        :scelta2
        echo carico scelta 2
        goto fine
        :scelta3
        echo carico scelta 3
        :fine

        Il listato del programma (prog.c) 

        #include <stdio.h>
        #include <dos.h>

        union REGS inregs;

        main()
        {
           int c;
           puts("a .. Scelta A");
           puts("b .. Scelta B");
           puts("c .. Scelta C");
           c = getch();
                                                           Segue ....


                                       283





        Linguaggio C per MS DOS - F. Bernardotti - 1987 Opus Free Soft





           switch(c) {
              case 'a':
              case 'A':
                 inregs.h.al = 1;
                 break;
              case 'b':
              case 'B':
                 inregs.h.al = 2;
                 break;
              case 'c':
              case 'C':
                 inregs.h.al = 3;
                 break;
              default:
                 exit(0);
                 break;
           }
           inregs.h.ah = 0x4C;
           intdos(&inregs);
        }


        4DH -  Get Return Code of a Sub-process (WAIT)


        Il  servizio acquisisce il codice di ritorno di un sottoprogramma 
        terminato mediante la call 4CH.
        Viene riportato in AL  il codice riportato dal programma.
        AH  restituisce  il  modo con cui e'  terminato  il  processo  ed 
        esattamente :

               00H  Terminato normalmente
               01H  Terminato a seguito di un CTRL BREAK
               02H  Terminato a seguito di un errore di un device
               03H  Terminato a seguito di una call 31H



        4EH -  Find First Matching File (FIND FIRST)


        Questa  funzione  e'  simile alla call 11H in quanto  ricerca  il 
        primo  ingresso  nella directory corrispondente  alle  specifiche 
        passate.
        DS:DX  puntano  a una stringa ASCII contenente il path e il  nome 
        del file che si vuole ricercare.
        E' possibile utilizzare i caratteri jolly ? e *.
        CX contiene gli attributi del file.
        Guardate la descrizione fatta per il servizio 11H.
        Se  in uscita il flag di carry e' settato allora AX  contiene  il 
        codice d'errore.



                                       284





        Linguaggio C per MS DOS - F. Bernardotti - 1987 Opus Free Soft






        Se  il  file  viene reperito il DTA e' riempito  con  i  seguenti 
        parametri.


        1  byte  - attributo trovato
        2  bytes - ora del file
        2  bytes - data del file
        2  bytes - valore meno significativo delle dimensioni del file
        2  bytes - valore piu' significativo delle dimensioni del file
        13 bytes - nome ed estensione del file trovato



        4FH -  Find Next Matching File


        La  call e' la continuazione della precedente in quanto  ricerca, 
        dopo  che il primo ingresso in directory e' stato  trovato,  ogni 
        successivo.
        DS:DX  puntano  alle informazioni di una precedente  chiamata  al 
        servizio 4EH.
         
           

        50H -  Set address of PSP


        Si  tratta  di  un'  altro  servizio  non  documentato  o  meglio 
        specificato come "Used Internally by Dos".
        Mediante questa call e' possibile settare l'indirizzo del PSP.
        L'uso  principale e' per quanto riguarda i programmi residenti in 
        memoria.
        BX contiene l'indirizzo del segmento del PSP da settare.
        Nel caso che si esegua un operazione del tipo,  ricordatevi prima 
        di  salvare il vecchio indirizzo del PSP mediante  la  successiva 
        call.



        51H -  Get Address of PSP.


        Esiste una similitudine di questo servizio con il 62H.
        Viene restituito in BX il segmento dell'attuale PSP.
        Anche questo viene documentato dal Technical Reference come "Used 
        Internally by Dos".
        Il seguente esempio riporta il segmento relativo al PSP.






                                       285





        Linguaggio C per MS DOS - F. Bernardotti - 1987 Opus Free Soft






        #include <stdio.h>
        #include <dos.h>

        union REGS inregs, outregs;

        main()
        {
           inregs.h.ah = 0x51;
           intdos(&inregs,&outregs);
           printf("\nSegment of PSP : %04x", outregs.x.bx);
        }



        54H -  Get Verify Setting


        Il  servizio  riporta  mediante  il registro AL  lo  stato  della 
        verifica.
        AL = 00H  La verifica e' disattiva
        AL = 01H  La verifica e' attiva



        56H -  Rename a File


        La call serve a rinominare un file.
        DS:DX  puntano a una stringa ASCII contenente il vecchio  path  e 
        nome del file.
        ES:DI puntano al nuovo path e nome del file.
        Sempre  indicato  dal flag di carry settato un  eventuale  errore 
        potrebbe essere restituito dal registro AX.



        57H -  Get/Set a File's Date and Time


        Il  servizio a seconda del valore del registro AL setta o riporta 
        la data relativa alla creazione o all'ultima modifica di un file.
        Se AL e' a 0 l'operazione eseguita e' quella di riportare la data 
        mentre con AL a 1 e' l'operazione inversa ad essere eseguita.
        BX  contiene  l'handle del file aperto su cui si  vuole  eseguire 
        l'operazione.
        In  caso  di settaggio la data viene specificata all'interno  del 
        registro DX.
        Il valore da settare viene dato da 

                  DX = (ANNO - 1980) * 512 + MESE * 32 + GIORNO



                                       286





        Linguaggio C per MS DOS - F. Bernardotti - 1987 Opus Free Soft





        Sempre  in  caso  di un operazione di settaggio  il  tempo  viene 
        specificato nel registro CX.
        Il valore viene dato da 

                   CX = ORA * 2048 + MINUTI * 32 + SECONDI / 2

        Nel  seguente  esempio viene cambiata la data  relativa  al  file 
        specificato alla richiesta.

        #include <stdio.h>
        #include <dos.h>
        #include <fcntl.h>
        #include <types.h>
        #include <stat.h>

        union REGS inregs, outregs;

        int infile;

        main()
        {
           char n_file[13];
           int ora, minuti, secondi, giorno, mese, anno;
           printf("\n\nNome del file : ");
           gets(n_file);
           if(n_file[0] == '\0')
              exit(0);
           puts("\n");
           do {
              printf("Ora     : ");
              scanf("%d", &ora);
           } while(ora < 0 || ora > 23);
           do {
              printf("Minuti  : ");
              scanf("%d", &minuti);
           } while(minuti < 0 || minuti > 60);
           do {
              printf("Secondi : ");
              scanf("%d", &secondi);
           } while(secondi < 0 || secondi > 60);
           puts(" ");
           do {
              printf("Anno    : ");
              scanf("%d", &anno);
           } while(anno < 1980 || anno > 2029);
           do {
              printf("Mese    : ");
              scanf("%d", &mese);
           } while(mese < 1 || mese > 12);


                                                            Segue ....


                                       287





        Linguaggio C per MS DOS - F. Bernardotti - 1987 Opus Free Soft





           do { 
              printf("Giorno  : ");
              scanf("%d", &giorno);
           } while(giorno < 1 || giorno > 31);
           
           if((infile = open(n_file,O_RDWR)) == NULL) {
              puts("ERRORE : File non trovato");
              abort();
           }
           inregs.h.ah = 0x57;
           inregs.h.al = 0x01;
           inregs.x.bx = infile;
           inregs.x.cx = ora*2048+minuti*32+secondi/2;
           inregs.x.dx = (anno-1980)*512+mese*32+giorno;
           intdos(&inregs,&outregs);
           close(infile);
        }



        59H -  Get Extended Error


        Il  servizio  ritorna informazioni estese sul tipi di errore  che 
        possono verificarsi durante l'esecuzione di una procedura.
        Vengono  restituite quattro distinte informazioni riguardanti  il 
        tipo di errore.
        BX contiene in ingresso 00H.
        In uscita AX contiene il codice d'errore,  BL l'azione suggerita, 
        BH ls classe d'errore e CH la causa.
        L'elenco dettagliato di tutto e' il seguente.

        Codice d'errore     Descrizione

        1                   Invalid function number
        2                   File not found
        3                   Path not found
        4                   No available handles
        5                   Access denied
        6                   Invalid handle
        7                   Memory control blocks destroyed
        8                   Not enough memory
        9                   Invalid memory block
        10                  Invalid environment
        11                  Invalid format
        12                  Invalid access code
        13                  Invalid data
        14                  Reserved
        15                  Invalid drive
        16                  Can't remove current directory
        17                  Not same device
        18                  No more files found


                                       288





        Linguaggio C per MS DOS - F. Bernardotti - 1987 Opus Free Soft





        Codice d'errore     Descrizione

        19                  Write protect
        20                  Unknow unit
        21                  Drive not ready
        22                  Invalid command
        23                  CRC error
        24                  Bad request
        25                  Seek error
        26                  Unknown media type
        27                  Sector not found
        28                  Out of paper
        29                  Write error
        30                  Read error
        31                  General error
        32                  Sharing violation
        33                  Lock violation
        34                  Invalid disk change
        35                  File control block unavailable
        36                  Sharing buffer overflow
        37-49               Reserved
        50                  Network request not supported
        51                  Remote computer not listening
        52                  Duplicate name of network
        53                  Network name not found
        54                  Network busy
        55                  Network device no longer exist
        56                  BIOS command limit exceeded
        57                  Network adaptor hardware error
        58                  Incorrect network response
        59                  Unexpected network error
        60                  Incompatible remote adaptor
        61                  Full print queue
        62                  Not enough space for print
        63                  Print file deleted
        64                  Network name deleted
        65                  Access denied
        66                  Incorrect network device type
        67                  Network name not found
        68                  Too many network names
        69                  BIOS session limit exceeded
        70                  Temporany pause
        71                  Network request not accepted
        72                  Redirection paused
        73-79               Reserved
        80                  File exists
        81                  Reserved
        82                  Cannot make directory entry
        83                  Critical error handler failure
        84                  Too many redirections
        85                  Duplicate redirection
        86                  Invalid password


                                       289





        Linguaggio C per MS DOS - F. Bernardotti - 1987 Opus Free Soft






        Codice d'errore     Descrizione

        87                  Invalid parameter
        88                  Network device fault



        Classe d'errore     Descrizione

        1                   Out of resource
        2                   Temporary problem
        3                   Permission problem
        4                   Internal software error
        5                   Hardware failure
        6                   System software error
        7                   Application software error
        8                   Item not found
        9                   Invalid format
        10                  Item locked
        11                  Media failure or wrong disk
        12                  Item already exists
        13                  Unknown



        Azione raccomandata Descrizione

        1                   Retry
        2                   Retry in a while
        3                   Ask user to reenter request
        4                   Abort and cleanup
        5                   Abort immediately, don't cleanup
        6                   Ignore
        7                   Ask user to perform remedial action, then
                            retry


        Causa               Descrizione

        1                   Unknown or not specific
        2                   Block device
        3                   Network device
        4                   Serial device
        5                   Memory

        Fate  attenzione  che  il  servizio distrugge  il  contenuto  dei 
        registri CL, DX, DI, SI, DS ed ES.






                                       290





        Linguaggio C per MS DOS - F. Bernardotti - 1987 Opus Free Soft






        5AH -  Create Temporary File


        Il servizio crea un file temporaneo.
        L'attributo con cui deve essere creato il file va' settato in CX.
        DS:DX  puntano al path dove deve essere creato il file terminante 
        con \.
        Questa zona di memoria deve essere sempre 12 bytes piu' lunga  in 
        quanto  la  call aggiunge in questo spazio il nome del  file  che 
        viene creato.
        La  stringa  cosi' composta viene puntata in uscita dai  registri 
        DS:DX.
        AX potrebbe restituire un codice d'errore.
        Il   file   creato  con  questa  funzione   non   e'   cancellato 
        automaticamente al termine del programma.
        Il  seguente  esempio,  mediante la funzione getcwd(),  legge  la 
        directory  attuale  e  crea un  file  temporaneo  all'interno  di 
        questa.


        #include <stdio.h>
        #include <direct.h>
        #include <stdlib.h>
        #include <dos.h>

        char var1[64];

        char far *var = var1;

        union REGS inregs,outregs;

        struct SREGS segregs;

        main()
        {
           getcwd(var1,51);

           inregs.h.ah = 0x5A;
           inregs.x.dx = FP_OFF(var);
           segregs.ds  = FP_SEG(var);
           inregs.x.cx = 0x00;

           intdosx(&inregs,&outregs,&segregs);

           printf("\n\nHo creato : %s\n\n", var1);
        }







                                       291





        Linguaggio C per MS DOS - F. Bernardotti - 1987 Opus Free Soft






        5BH -  Create New File


        Il servizio crea un nuovo file.
        DS:DX  puntano  a una stringa ASCII contenente il path e il  nome 
        del file da creare.
        CX contiene l'attributo di questo.
        AX contiene al ritorno il codice d'errore, se il flag di carry e' 
        settato, oppure l'handle del file appena creato.



        5CH -  Lock/Unlock File Access


        Dalla  versione  3.00  del Dos si possono trovare  alcuni  sevizi 
        progettati alla luce della multiutenza.
        La  call  5CH  serve appunto a bloccare e a  liberare  una  parte 
        specificata di un file.
        AL contiene il codice della funzione ovvero

                                00H per chiudere
                                01H per liberare

        BX contiene l'handle del file a cui ci si vuole riferire.
        CX e DX contengono rispettivamente la parte alta e la parte bassa 
        dell'offset dal quale si vuole bloccare o liberare il file.
        SI e DI a sua volta contengono la parte alta e la parte bassa del 
        numero di bytes,  a partire dall'offset specificato,  che  devono 
        essere interessati nell'operazione.
        Anche in questo servizio AX restituisce,  nel caso che il flag di 
        carry si settato, il codice d'errore.
        Nel  caso che una parte del file sia bloccato e un altro processo 
        tenti di accedere a questa saranno eseguiti 3 tentativi.
        Il  Technical  Reference  consiglia,   nel  caso  di   insuccesso 
        dell'operazione,  di  richiamare la call 59H per avere il  codice 
        esteso d'errore.



        62H -  Get Program Segment Prefix Address (PSP)


        Il  servizio  e' simile a quello non documentato di  cui  abbiamo 
        parlato  prima  in  quanto  restituisce  in  BX  l'indirizzo  del 
        segmento del PSP.


        Con  questa call abbiamo terminato i servizi  rigiuardanti  l'int 
        21H del Dos.
        Come  avrete potuto notare molte funzioni incluse nella  libreria 


                                       292





        Linguaggio C per MS DOS - F. Bernardotti - 1987 Opus Free Soft





        standard del compilatore Microsoft C fanno esattamente quello che 
        abbiamo visto parlando di tutte queste calls.
        Questo  chiaramente  e' un punto a nostro favore che non  dovremo 
        metterci li a riscrivere i vari servizi.
        Penso  che con la nuova versione del Dos 3.3 siano stati  incluse 
        nuove calls.
        Purtroppo  penso  anche  che  per un po' di  tempo  il  Technical 
        Reference non sara' disponibile in circolazione.
        Sinceramente   quando  avevo  annunciato  questo  fascicolo   non 
        supponevo che avrebbe preso tutto questo tempo.
        L'idea  che mi ero fatto inizialmente era che al massimo  saremmo 
        arrivati sulle 100-150 pagine.
        A questo punto siamo al doppio e oltre tutto senza aver terminato 
        le argomentazioni.
        La  parte  finale sara' dedicata all'utilizzo di tutto quello  di 
        cui  abbiamo parlato per la scrittura di programmi  residenti  in 
        memoria.
        Durante  la  descrizione  di quanto abbiamo visto  ho  introdotto 
        alcune argomentazioni nel momento in cui comparivano nei  servizi 
        trattati.
        Come avevo detto precedentemente si sarebbe potuto dedicargli dei 
        capitoli a parte.
        Facendo  in questo modo probabilmente si sarebbe andati a  favore 
        dell'ordine ma a discapito della comprensione.
        In ogni caso un indice facilitera' la ricerca dei vari argomenti.
        Vediamo ora alcuni accenni sulla mappatura di memoria.



                             Mappatura della memoria


        Durante questo testo abbiamo accennato all'uso di varie locazioni 
        di memoria.
        Una  mappatura  generica per quanto riguarda le  aree di  memoria 
        utilizzate dal Bios e dal Dos e' la seguente.

                  Segmento Offset  Utilizzo
                  --------------------------------------------- 
                  0000     0000    Tavola vettori di interrupts
                  0040     0000    Area parametri BIOS
                  0050     0000    Area parametri DOS

        Per  fare  alcuni  esempi possiamo riportare  gli  indirizzi  che 
        potrebbero rivelarsi utili.

        0040:0010 Byte contenente lo stato delle periferiche collegate.

        Ad  esempio se si desidera sapere lo stato dell'adattatore  video 
        si potrebbero testare il bit 4 e 5 di questa locazione.




                                       293





        Linguaggio C per MS DOS - F. Bernardotti - 1987 Opus Free Soft





        Se i due bits sono

                                 10 = 80x25 CGA
                                 01 = 40x25 CGA
                                 11 = Monocromatico

        Se  i  due  bits  sono  00  e'  possibile  testare  la  locazione 
        0040:0087  per vedere se la scheda EGA e' quella attiva (!=0  con 
        bit 3 = 0).
        L'elenco  completo  delle  periferiche  testabili  a  partire  da 
        0040:0010 e' :

        bit    descrizione
        0      1 se sono collegati dei drive a floppy
        1      (XT,AT) 1 se e' installato un coprocessore matematico
        2-3    11 se sono installati 64K di RAM base
        4-5    stato adattatore video
        6-7    se bit 0 = 1, numero di floppy
        8      non usato su PC, XT e AT
        9-11   Numero di seriali
        12     1 se e' installato un adattatore games
        13     non usato su PC, XT e AT
        14-15  numero porte parallele

        Un  altro esempio e' portato dalla locazione 0040:0013 in cui  il 
        BIOS salva il numero di Kbytes disponibili nel sistema.
        Le   locazioni  0040:0017-18  vengono  utilizzate  dal  BIOS  per 
        l'interpretazione della tastiera.
        Abbiamo  gia' visto queste locazioni per la rilevazione del tasto 
        Insert.
        Alcune locazioni riguardano il buffer di tastiera.
        Questo e' lungo 32 Bytes che iniziano alla locazione 0040:001E.
        Esistono  anche le locazioni 0040:001A e 0040:001C che contengono 
        i puntatori alla testa e alla coda del buffer.
        Il buffer di tastiera e' di tipo FIFO (first-in first-out).
        Guardate il seguente schema.

         ecc. 36  34  32  30  2E  2C  2A  28  26  24  22  20  1E  1C  1A
        +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
        :   :   :   :   : C : I : A : O :   :   :   :   :   :   :28 :30 :
        +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
                                                                  :   :
                               +----------------------------------+   :
                               :                       +--------------+
                               :                       :
                          Tail Pointer           Head Pointer   

        La  locazione 0040:003E contiene un insieme di bit che  indicano, 
        se   a  0,   che  le  unita'  abbinate  hanno  bisogno   di   una 
        ricalibrazione.
        Il bit 0 corrisponde al drive A:,  il bit 1 a B;, il bit 2 a C: e 
        il bit 3 a d: .


                                       294





        Linguaggio C per MS DOS - F. Bernardotti - 1987 Opus Free Soft





        La  locazione  0040:003F sempre mediante alcuni bit ci indica  lo 
        stato del motore di ogni drive.
        Se  un  bit e' a 0 significa che il  motore  corrispondente  sta' 
        girando.
        Il bit 7 indica uno stato di scrittura su un drive.
        I  bit  relativi allo stato del motore per ogni drive  hanno  gli 
        stessi abbinamenti di quelli della locazione appena vista.
        Alla locazione 0040:0041 e' contenuto il byte indicante lo  stato 
        del disco.
        Se il flag di carry al ritorno di un int 13H e' settato allora il 
        registro AH riportato dallo stesso contiene questo byte.
        La modalita' del video e' invece contenuta a 0040:0049.
        I  valori  sono  relativi  a quelli che vengono  settati  con  il 
        servizio 00H dell'int 10H.
        Un valore uguale a 28H nella locazione 0040:004A specifica che le 
        colonne del video sono 40 mentre un valore pari a 50H  ne  indica 
        80.
        Le  dimensioni del buffer video,  corrispondenti alla  modalita', 
        sono conservate a 0040:004C.
        0040:004E contiene l'offset di partenza del buffer del video.
        I  due  byte  a partire da 0040:0050 indicano  ls  posizione  del 
        cursore relativa ad ogni pagina video possibile.
        Mentre  le  locazioni  precedenti mantenevano  la  posizione  del 
        cursore,  i  due  bytes  a  partire da  0040:0060  contengono  la 
        modalita' del cursore ovvero linea di partenza e finale.
        Anche  questo  contenuto  e' funzione  del  settaggio  effettuato 
        mediante l'apposita call dell'int 10H.
        Alla cella 0040:0062 e' contenuto il numero della pagina attiva.
        Il  valore  3B4H contenuto a 0040:0063 specifica  che  la  scheda 
        video attiva e' la monocromatica.
        3D4H e' relativa alla scheda CGA.
        Per l'identificazione della EGA vedi la pagina precedente.
        La  locazione  0040:0065 contiene l'impostazione della  modalita' 
        video attiva relativa al chip del controllore 6845.
        La tavolozza del colore impostata mediante la porta  3D9H,  vista 
        parlando della gestione video, e' memorizzata a 0040:0066.
        La locazione 0040:0069 viene utilizzato per il calcolo del CRC su 
        blocchi di dati da 256 byte.
        Un  valore di quattro byte contenuti dalla locazione 0040:006C e' 
        incrementato automaticamente dall' INT 08H.
        Quando il valore non viene letto per piu' di 24 ore si ottiene un 
        overflow che viene indicato dalla locazione 0040:0070.
        Fate  attenzione che la significativita' del valore  contenuto  a 
        0040:006C va da sinistra a destra.
        Se  il  tasto  di break viene premuto il bit  7  della  locazione 
        0040:0071 e' settato a 1.
        I  valori di timeout relativi alla stampante e alla porta  RS_232 
        sono   contenuti  rispettivamente  alle  locazioni  0040:0078   e 
        0040:007C.
        I valori sono da 0 a 255 secondi.
        Come  avrete  notato  le locazioni di cui abbiamo  parlato  erano 
        relative all' area di memoria utilizzata dal BIOS.


                                       295





        Linguaggio C per MS DOS - F. Bernardotti - 1987 Opus Free Soft






        Molte  di  queste le avevamo gia' viste  negli  esempi  riportati 
        precedentemente parlando in modo specifico delle periferiche.
        In  ogni caso ho pensato che fosse meglio raggruppare il tutto al 
        fine  di  riportare un po' d'ordine per facilitare  un  eventuale 
        consultazione.
        Concludiamo  l'argomento  e iniziamo a  vedere  altri  interrupts 
        alcuni  dei  quali saranno utilizzati all'interno  dei  programmi 
        memory resident.


                                Altri Interrupts


        Alcuni  di  questi interrupts li ho gia' utilizzati negli  esempi 
        riportati in questo testo accennando solo al loro utilizzo.
        Altri risulteranno nuovi e di fatto solo alcuni saranno utili nei 
        nostri programmi in linguaggio C.


        20H -  Program Terminate

        Parlando  del  PSP  abbiamo visto che uno  dei  campi  in  questo 
        contenuti era relativo all'istruzione INT 20H.
        Avevamo  detto  che  costituiva uno dei metodi utilizzati  da  un 
        programma per mettere fine a se stesso.
        In  altre  parole a un processo e' sufficente  puntare  a  questa 
        istruzione per terminare.
        L'interrupt svuota tutti i buffers ma non salva i file che,  dopo 
        esser  stati   modificati,  non  sono stati  chiusi  prima  della 
        chiamata.


        22H -  Terminate Address


        L'interrupt  punta  alla locazione che  contiene  l'indirizzo  al 
        quale  deve  essere  passato  il controllo  quando  un  programma 
        termina.
        Questo indirizzo e' copiato all'interno del PSP.


        23H -  Ctrl Break Exit Address


        L'interrupt viene eseguito quando l'utente,  durante l'esecuzione 
        di un programma, batte Ctrl Break.
        Come  abbiamo visto precedentemente anche questo indirizzo  viene 
        copiato all'interno del PSP.





                                       296





        Linguaggio C per MS DOS - F. Bernardotti - 1987 Opus Free Soft





        24H -  Critical Error Handler Vector


        Quando  capita un errore durante l'esecuzione di una funzione Dos 
        il controllo viene trasferito all' int 24H.


        25H -  Absolute Disk Read


        Di questo interrupt come del 26H,  il prossimo,  abbiamo  parlato 



        nei capitoli precedenti.
        Senza  ripetere  ricordo  solo che l'interrupt legge uno  o  piu' 
        settori dal disco specificato.


        26H -  Absolute Disk Write


        Vale  lo  stesso discorso dell'interrupt precedente solo  che  in 
        questo caso il servizio svolto e' di scrittura.


        27H -  Terminate but Stay Resident


        Questo  interrupt  e'  importante per i  programmi  residenti  in 
        memoria.
        Infatti l'interrupt permette a un programma di rimanere residente 
        nell'istante in cui il COMMAND del dos riprende il controllo.
        L'interrupt puo' essere utilizzato,  ad esempio,  nell'istante in 
        cui si vuole modificare una routine di interrupt.
        Come   sicuramente   ricorderete   nel  programma   esempio   che 
        intercettava  un  tasto  e settava in ON/OFF  il  dtr  era  stato 
        utilizzato questo interrupt.
        Non  dovrebbe  essere utilizzato con un programma .EXE che  viene 
        letto nella parte alta della memoria.
        Un  altra  precauzione  da  prendere  e'  quella  relativa   alla 
        dimensione massima del programma.
        Questo non deve superare i 64 Kbytes.
        Vediamo  ora  gli esempi relativi al settaggio di due vettori  di 
        interrupt eseguiti con un programma .COM e uno .EXE.

        _text segment
              assume cs:_text, ds:_text
              org   100H                ;offset .COM
              jmp   init                ;salta alla routine di 
                                        ;installazione
                                                            Segue ....


                                       297





        Linguaggio C per MS DOS - F. Bernardotti - 1987 Opus Free Soft





        inter proc  far
              push  ds                  ;salvataggio registri che 
              push  di                  ;verranno cambiati
              ....  ..
              (routine interrupt)
              ....  ..
              pop   di
              pop   ds
              iret
        fine  equ   $
        inter endp
        ;
        init: mov   dx,offset init
              mov   al,NUMERO_INTERRUPT 
              mov   ah,25H
              int   21H
        ;
              lea   dx,fine
              int   27H
        _text ends
              end
              

        Come  potete  vedere  prima  di  richiamare  l'interrupt  27H  il 
        registro  viene  caricato con l'ultimo  indirizzo  della  routine 
        residente.
        Questo  ha  lo scopo di indicare da quale offset potrebbe  essere 
        caricato un successivo programma.      
        Se  vi ricordate avevamo detto che nel caso di un programma  .COM 
        tutti  i registri CS,ES,IP ecc.  puntano inizialmente  all'inizio 
        del PSP.
        Nel  caso  di  un programma .EXE allora  i  registri  CS,IP  ecc. 
        puntano  all'inizio  effettivo del codice ovvero  100H  posizioni 
        oltre l'inizio del PSP.
        Il programma, nel caso di un formato .EXE, sara' :

        _text  segment
               jmp   init
        ;
        inter  proc  far
               push  ds
               push  di
               ....  ..
               (routine interrupt)
               ....  ..
               pop   di
               pop   ds
               iret
        fine   equ   $
        inter  endp
        ;
                                                               Segue ....


                                       298





        Linguaggio C per MS DOS - F. Bernardotti - 1987 Opus Free Soft






        init:  mov   dx offset inter
               mov   ax seg inter
               mov   ds,ax
               mov   al,NUMERO_INTERRUPT
               mov   ah,25H
               int   21H
        ;
               mov   dx,fine + 100H 
               mov   byte ptr es:1,27H
               ret
        _text  ends
               end


        In  questo caso l'istruzione int 27H viene settata  all'indirizzo 
        del PSP dove normalmente si trova l'istruzione int 20H.
        E' stato aggiunto 100H in quanto,  come avevamo detto prima,  nel 
        caso  di  un  .EXE  CS e IP  puntano  effettivamente  alla  prima 
        istruzione del programma e non al suo PSP.
        Nel  caso  di  utilizzo dell'interrupt 27H per  il  settaggio  di 
        routine  di  interrupts e' conveniente scrivere in  assembler  il 
        tutto  in  quanto  in linguaggio C andremmo  incontro  a  inutili 
        difficolta' come ad esempio il salvataggio dei registri.
        Questo non significa che in C un lavoro simile non sia fattibile.
        Dato  che  la  modifica  dei vettori di interrupt  e'  una  delle 
        funzioni  principali  per  la scrittura  di  programmi  residenti 
        vedremo in modo accurato il tutto nei capitoli successivi.


        28H -  Call when DOS is free


        Il nome all'interrupt non e' riportato sul Technical Reference in 
        quanto compare su questo come "Used Internally by Dos".
        L'interrupt  viene richiamato ripetutamente quando il Dos non  ha 
        funzioni in esecuzione.
        Si  tratta  di un altro interrupt importante per la scrittura  di 
        programmi  residenti in memoria che fanno uso di alcune call  del 
        Dos.
        Ne riparleremo tra poco.



        2FH -  Printer


        Questo  interrupt  costituisce  un mezzo per  comunicare  con  lo 
        spooler di stampa.
        A  seconda  del  valore settato in AL il  servizio  svolge  varie 
        funzioni e precisamente i seguenti:



                                       299





        Linguaggio C per MS DOS - F. Bernardotti - 1987 Opus Free Soft







        0  =  Riporta se lo spooler di stampa e' installato o meno.
              I  valori di ritorno sono restituiti sempre da AL e possono 
              essere

              00 - Non installato. E' possibile eseguire installazione.
              01 - Non   installato.    Non    e'    possibile   eseguire 
                   installazione. 
              FF - Installato.


        1  =  Presenta allo spooler un file per farlo stampare.
              La  forma di presentazione e' costituita da un blocco di  5 
              bytes definito dal Technical Reference come submit packet.
              Questo viene puntato da DS:DX.
              Il  primo  byte  costituisce il  livello  che  penso  debba 
              trattarsi  di  un  qualche  cosa che  stabilisce  il  tempo 
              macchina dedicato alla stampa in background dei file.
              I    rimanenti    4   byte    costituiscono    l'indirizzo 
              (segmento/offset) in cui e' conservato il drive, path e il 
              nome del file presentato allo spooler.
              Il  nome  del file non puo' contenere dei caratteri  jolly 
              del tipo ? o *.


        2  =  Cancella un file dallo spooler di stampa.
              DS:DX puntano alla stringa ASCII con il path e il nome del 
              file che deve essere rimosso.
              In questo caso sono ammessi nel nome del file i  caratteri 
              jolly.


        3  =  Cancella tutti i file dallo spooler di stampa.


        4  =  Mediante questa chiamata la coda di stampa viene  bloccata
              e  permette  di  farsi  esaminare  in  quanto  di  ritorno 
              restituisce  in DX il numero d'errore e DS:SI puntano alla 
              coda  di stampa che contiene la serie di nomi di file  che 
              sono in attesa.
              Il primo nome di file corrisponde a quello che e' in  fase 
              di stampa.
              Qualsiasi richiesta di servizio tramite int 2FH sblocca la
              coda.


        5  =  Teoricamente   il  servizio servirebbe a sbloccare la  coda 
              dopo una chiamata al servizio AL = 4.





                                       300





        Linguaggio C per MS DOS - F. Bernardotti - 1987 Opus Free Soft





        I codici d'errore ritornati dai servizi sono i seguenti.

                  Codice d'errore    Descrizione

                         1           Funzione non valida
                         2           File non trovato 
                         3           Path non esistente
                         4           Troppi files aperti
                         5           Accesso negato
                         8           Coda piena
                         9           Occupato (busy)
                         12          Nome troppo lungo
                         15          Drive non valido
                

        E  con questo abbiamo terminato anche il discorso  relativo  agli 
        altri interrupt non visti prima d'ora.
        Purtroppo la Microsoft per alcuni servizi non e' stata prodiga di 
        informazioni.
        Come  avevo gia' accennato prima la scusante a questa carenza  in 
        genere e' data dal fatto che per alcuni servizi non si garantisce 
        un futuro nelle successive versioni del Dos.
        Questa  per  me  e'  una stupidata in quanto a  questo  punto  si 
        potrebbe  benissimo  non  documentare nulla e  dire  che  non  si 
        garantiscono neppure altre versioni del Dos.
        Intanto che ci sono perche' non dire nulla ?
        Prima  di  addentrarci sulle problematiche dei  programmi  memory 
        resident  vediamo  ancora il metodo per la creazione  dei  device 
        driver.
        D'altra parte in questo testo abbiamo parlato un po' di tutte  le 
        argomentazioni  inerenti al sistema operativo Ms Dos e quindi  al 
        fine  di  completare la panoramica riportata mi  sembra  doveroso 
        trattare anche questi.
         


                                  Device Driver


        Un  device driver e' uno speciale programma atto al controllo del 
        I/O con una determinata periferica.
        Ho  utilizzato il termine speciale in quanto per la scrittura  di 
        un driver bisogna attenersi ad alcune specifiche particolari.
        Il  programma deve avere un' immagine di memoria non  utilizzante 
        ORG 100H.
        Il  device  deve essere scritto in assembler con un ORG 0H  o  al 
        limite  senza nessuna istruzione che stabilisca  l'origine  dello 
        stesso  in  quanto  il  programma non utilizza il  PSP  ma  viene 
        semplicemente letto.
        Esistono due tipi di devices.
        I  devices  di tipo carattere sono creati per l' I/O  seriale  di 



                                       301





        Linguaggio C per MS DOS - F. Bernardotti - 1987 Opus Free Soft





        caratteri singoli. 
        Per  portare un esempio sono definiti devices di questo tipo  CON 
        (console) e AUX (porta ausiliaria).
        Il secondo tipo e' costituito dai devices a blocchi.
        Sono  esempi  di questi i dischi che trattano l'  I/O  appunto  a 
        blocchi.
        Come  difatto  saprete un disco tratta come unita' minima per  il 
        trasferimento di dati un settore.
        Abbiamo parlato prima della configurazione fisica di un programma 
        di un device.
        Oltre  a questo uno di questi programmi necessita in testa di  un 
        header lungo diciotto bytes.
        Il  primo  campo  lungo  4  bytes e' lo  spazio  riservato  a  un 
        puntatore al successivo driver.
        Questo  contiene  sempre FFFFFFFFH in quanto il  Dos  al  momento 
        della  lettura del devices piazzera' l'indirizzo di partenza  del 
        prossimo header.
        Il secondo campo e' costituito da 2 bytes che servono a contenere 
        l'attributo del device.
        Di 16 bits solo 7 hanno un significato e precisamente :

                     +---+---+---+---+---+---+---+
                     :15 :14 :13 : 3 : 2 : 1 : 0 :
                     +---+---+---+---+---+---+---+
                       :   :   :   :   :   :   :
                       :   :   :   :   :   :   1 = standard input device
                       :   :   :   :   :   :   0 = not standard input
                       :   :   :   :   :   1 = standard output device
                       :   :   :   :   :   0 = not standard output
                       :   :   :   :   1 = current NUL device
                       :   :   :   :   0 = not NUL device
                       :   :   :   1 = clock device
                       :   :   :   0 = not a clock device
                       :   :   1 = IBM block format
                       :   :   0 = other block format
                       :   1 = IOCTL supported
                       :   0 = IOCTL not supported
                       1 = character device
                       0 = block device

        Generalmente vengono settati solo i bit 15 e 14.
        Il  bit  13  chiaramente e' in funzione del bit 15 in  quanto  ha 
        esclusivamente significato con i device a blocchi.
        I rimanenti vengono utilizzati solo per rimpiazzare i devices  di 
        default del Dos.
        Il  terzo  campo di due bytes serve a contenere  quella  definita 
        strategy routine.
        Quando  il  Dos  legge  il device crea e  setta  un  blocco  data 
        chiamato request header.
        Questo possiede fondamentalmente due funzioni.
        La prima e' quella di servire come area di lavoro del Dos.
        La   funzione   piu'  importante  e'  quella  di   puntare   alle 


                                       302





        Linguaggio C per MS DOS - F. Bernardotti - 1987 Opus Free Soft





        informazioni  che  devono essere passate al device dal  programma 
        chiamante e di consevare alcune informazioni.
        Il  formato  del  request header e'  variante  come  lunghezza  a 
        seconda della natura del servizio richiesto anche se in ogni caso 
        i primi tredici byte sono sempre uguali e sono :

        campo     lunghezza    scopo
          
          1        1 byte      Lunghezza del request header
          2        1 byte      Codice  unita'.  Usato solo per  device  a 
                               blocchi.
          3        1 byte      Codice  comando.  Viene  salvato  l'ultimo 
                               codice di comando impartito al device.
                               Vedremo tra poco i comandi validi.
          4        2 bytes     Stato. Viene settato tutte le volte che il
                               driver  viene chiamato.  Se il bit  15  e' 
                               settato  significa che si e' verificato un 
                               errore.  In questo caso gli otto bit  meno 
                               significativi    contengono   il    codice 
                               d'errore e precisamente 

                               0 tentativo di scrittura su disco protetto
                               1 unita' sconosciuta
                               2 device non pronto
                               3 comando sconosciuto
                               4 errore di CRC
                               5 errata    lunghezza   struttura    drive 
                                 richiesto
                               6 errore posizionamento
                               8 media sconosciuto
                               9 errore di fine carta su stampante
                               A errore scrittura
                               B errore lettura
                               C errore generale
                               F cambio disco non valido

          5        8 bytes     Area riservata al Dos.
          6        variabile   Area riservata operazioni del driver

        I byte che si differenziano li vedremo con i singoli comandi
        Il  quarto  campo  di due byte e' un puntatore  alla  routine  di 
        interrupt del device.
        Ambedue  i campi precedenti devono essere residenti nello  stesso 
        segmento del device header.
        L'ultimo campo, il quinto, del device header contiene il nome del 
        device  stesso  nel  caso  che si tratti di  un  device  di  tipo 
        carattere.
        Nel  caso  di un device a blocchi lo spazio  sara'  riservato  al 
        numero dell'unita'.
        Questi sono lunghi al massimo 8 bytes e vengono giustificati, nel 
        caso  che  il  nome o il numero unita'non siano  tanto  lungo,  a 
        sinistra.


                                       303





        Linguaggio C per MS DOS - F. Bernardotti - 1987 Opus Free Soft





        I bytes liberi vengono riempiti di spazi.
        Il  Dos  quando  richiama il servizio di  un  driver  punta  alla 
        strategy  routine  e  setta nel request  header  le  informazioni 
        relative a quello che desidera che venga eseguito.
        Appena  il  Dos ritorna dalla richiesta fatta a  quella  definita 
        strategy  routine richiama la routine d'interrupt senza passargli 
        nessun  parametro  in  quanto  questa  utilizza  le  informazioni 
        restituite dalla chiamata precedente.
        Il  Dos passa il puntatore al request header mediante i  registri 
        ES:BX.
        Il  codice di comando specificato nel request header e'  uno  dei 
        seguenti.


          Codice             Funzione
          ------------------------------------------------------------- 

            0                INIT
            1                MEDIA CHECK  (Solo  per  device a blocchi)
            2                BUILD BPB    (Solo  per  device a blocchi)
            3                IOCTL input
            4                INPUT
            5                NO DESTRUCTIVE INPUT NO WAIT (Solo  device
                             a carattere)
            6                INPUT STATUS     (Solo device a carattere)
            7                INPUT FLUSH      (Solo device a carattere)
            8                OUTPUT
            9                OUTPUT WITH VERIFY
            10               OUTPUT STATUS    (Solo device a carattere)
            11               OUTPUT FLUSH     (Solo device a carattere)
            12               IOCTL output
            13               DEVICE OPEN
            14               DEVICE CLOSE
            15               REMOVABLE MEDIA


        Benche'  esistano  vari metodi per installare un device  il  piu' 
        utilizzato  e' quello di utilizzare in fase di bootstrap del  Dos 
        il CONFIG.SYS.
        Supponiamo di aver creato un device chiamato PIPPO.

        C>type config.sys

        device = pippo.sys
        device = ansi.sys

        ecc.

        Prima  di  proseguire  con la descrizione  particolareggiata  dei 
        comandi precedentemente elencati vediamo lo schema rappresentante 
        il percorso eseguito per effettuare un operazione, ad esempio, di 
        scrittura.


                                       304





        Linguaggio C per MS DOS - F. Bernardotti - 1987 Opus Free Soft





        programma chiamante 

                 char buffer[512];
                 char far *var = buffer;
                 ...........
                 ...........
                 int c;                             Command code  13
                 c = open("pippo",O_RDWR);------------------------------+
                 inregs.h.ah = 0x40;           /* Write to a device */  :
                 inregs.x.bx = c;              /* handle            */  :
                 segregs.ds  = FP_SEG(buffer); /* seg data          */  :
                 inregs.x.dx = FP_OFF(buffer); /* offset data       */  :
                 inregs.x.cx = 512;            /* bytes da scrivere */  :
                 intdosx(&inregs,&outregs,&segregs);------------------+-+
                                                    Command code  08  :
                                                                      :
        Device   +-----------------+ <--------------------------------+
        Header   : 1 ............. :   Cerca device
                 : . ............. :
                 : 5 Nome device   :------+ Ritorna indirizzo 
                 +-----------------+      : request header          ret ^
                                          :                             :
        Device   +-----------------+ <----+                             :
        Strategy :  Puntatore  al  :                    Request Header  :
                 : request  header : --------------> +------------------+
                 :       ES:BX     :                 : 1 .............. :
                 +-----------------+  codice comando : 2 .............. :
        Device   +-------------------------+     +---- 3 Codice comando :
        Interrupt:     Tavola funzioni     :Cerca: +-> 4 Status Word    :
                 :   +-----------------+ <-------+ : : 5 Ecc.           :
                 :   : Check Media     :   :       : +------------------+
                 :   : Input or output :   :       :
                 :   : Ecc.            : Trovato ? : Se non trovato segna
                 :   +-----------------+ -----+----+ errore  nella status
                 :                         :  : no ^ word ed esce
                 :  Routines di  servizio  :  :si  :
                 :        del device       :  :    : Se   trovato  codice 
                 :   +-----------------+   :  :    : comando cerca la sua
                 :   +-----------------+ <----+    : routine  di servizio
                 :                         :       : la esegue e setta la
                 :   +-----------------+   :       : status word prima di
                 :   +-----------------+   :       : uscire  per  tornare
                 :            :            :       : al programma
                 +------------:------------+       :
                              :                    :
                              +--------------------+      
                                                                          


        Spero che sia stata chiara la meccanica di funzionamento.
        Ancora una puntualizzazione.
        State  attenti  che  nel caso che scriviate  una  device  dovrete 


                                       305





        Linguaggio C per MS DOS - F. Bernardotti - 1987 Opus Free Soft






        salvare TUTTI i registri e ripristinarli prima di terminare.

        Es:

                                     push ax
                                     push bx
                                     push cx
                                     push ds
                                     .... ..
                                     (routine)
                                     .... ..
                                     pop  ds
                                     pop  cx
                                     pop  bx
                                     pop  ax
                                     ret


        Vediamo  ora  singolarmente  i bytes che si  differenziano  dalla 
        struttura di 13 bytes vista prima a seconda del codice di comando 
        diretto al device.


        Codice comando = 0         INIT

        Struttura request header

        13 bytes - Request Header
         1 byte  - Numero unita' (Non per device a carattere)
         4 bytes - Indirizzo finale del codice del programma residente
         4 bytes - Puntatore al BPB (Non per device a carattere)
         1 byte  - Contiene  la  lettera  relativa  alla  prima  unita  a 
                   blocchi


        Codice comando = 1         MEDIA CHECK

        Struttura request header

        13 bytes - Request Header
         1 byte  - Descrittore media dal Dos
         1 byte  - Per ritorno valore e precisamente
                      -1 Media has been changed
                       0 Don't know if media has been changed
                       1 Media has not been changed
         4 bytes - Puntatore alla precedende ID di Volume se il driver ha 
                   settato i bit 11 a 1 della word contenente l'attributo 
                   del   device  e  se  il  byte  precedente  indica   un 
                   cambiamento (-1 = Media changed)




                                       306





        Linguaggio C per MS DOS - F. Bernardotti - 1987 Opus Free Soft






        Codice comando = 2         BUILD BPB (Bios Parameter Block)

        Struttura request header

        13 bytes - Request Header
         1 byte  - Descrittore media dal Dos
         4 bytes - Indirizzo trasferimento (buffer)
         4 bytes - Puntatore al BPB

        Il   BPB   contiene  informazioni  pertinenti  il  device   quali 
        dimensione  dei  settori,  settori per  unita'  allocate,  numero 
        unita' allocate, ingressi in directory ecc.
        Le  informazioni  relative al BPB sono prese dal settore di  boot 
        dell'unita'.

        Il formato di questo settore e' il seguente.


        3 bytes - JUMP near oppure 2 bytes per un istruzione di JMP short
                  seguito da un istruzione NOP.
        8 bytes - Nome OEM e versione
        2 bytes - Bytes per settore                                <----+
        1 byte  - Settore per unita' allocata (potenza di 2)            :
        2 bytes - Settori riservati                                     :
        1 byte  - Numero di FAT'S                                       B
        2 bytes - Numero di massimo di ingressi nella root directory    P
        2 bytes - Numero totale di settori                              B
        1 byte  - Descrittore disco                                     :
        2 bytes - Numero di settori per una FAT                    <----+
        1 byte  - Settori per traccia
        1 byte  - Numero di facciate
        1 byte  - Numero di settori nascosti


        Il  byte  contenente  il descrittore del  disco  ha  il  seguente 
        formato.

                        +---+---+---+---+---+---+---+---+
                        : 7 : 6 : 5 : 4 : 3 : 2 : 1 : 0 :
                        +---+---+---+---+---+---+---+---+
                          :   :   :   :   :   :   :   :
                          1   1   1   1   1   :   :   1 = 2 sided
                                              :   :   0 = 1 sided
                                              :   1 = 8 sectors
                                              :   0 = not 8 sectors
                                              1 = removable
                                              0 = fixed






                                       307





        Linguaggio C per MS DOS - F. Bernardotti - 1987 Opus Free Soft






        Codice comando = 3,4,8,9,12   INPUT or OUTPUT

        Struttura request header

        13 bytes - Request Header
         1 byte  - Descrittore media
         4 bytes - Indirizzo area trasferimento (buffer)
         2 bytes - Byte/settore
         2 bytes - Numero   settore  iniziale  (non  usato  da  device  a 
                   carattere)
         4 bytes - Se viene restituito il codice d'errore 0FH contiene un
                   puntatore all'identificatore di volume.


        Codice comando = 5            Non Destructive Input No Wait

        Struttura request header

        13 bytes - Request Header
         1 byte  - Letto dal device


        Codice comando = 6,10         STATUS

        Struttura request header

        13 bytes - Request Header


        Codice comando = 7,11         FLUSH

        Struttura request header

        13 bytes - Request Header


        Codice comando = 13,14        OPEN or CLOSE

        Struttura request header

        13 bytes - Static Request Header


        Codice comando = 15           REMOVABLE MEDIA

        Struttura request header

        13 bytes - Static Request Header





                                       308





        Linguaggio C per MS DOS - F. Bernardotti - 1987 Opus Free Soft






        Nel dischetto contenente i programmi complementari del Dos esiste 
        un file, VDISK.LST, che puo' essere listato contenente un esempio 
        di scrittura relativo a un disco virtuale.
        Con questo concludo anche il discorso relativo ai devices.
        Ora  non ci resta che concludere il tutto trattando alcuni  punti 
        chiave per la scrittura di programmi residenti in memoria.



                         Programmi residenti in memoria


        Ogni programma residente in memoria si basa sulla ridirezione  di 
        uno o piu' vettori di interruzione.
        Fondamentalmente  possiamo suddividere questo genere di programmi 
        in due tipi differenti.
        Il primo tipo e' costituito da quei programmi che modificano  una 
        routine di interrupt per svolgere particolari compiti.
        Supponiamo,  ad esempio,  di voler bloccare il settaggio video in 
        una determinata modalita'.
        Potremmo modificare la routine dell'interrupt 10H,  quello che si 
        interessa  della gestione screen,  in modo che ad ogni chiamata a 
        questo venga vagliato il servizio richiesto.
        Nel  caso che si tratti di un servizio estraneo al settaggio  del 
        video ci sarebbe una chiamata  al vecchio vettore di interrupt  e 
        quindi l'esecuzione della funzione richiesta.
        Se  la call e' relativa a un settaggio video allora  si  potrebbe 
        eseguire   una  forzatura  del  valore  relativo  al  modo  e  il 
        successivo salto alla routine di interrupt originale.
        In questo testo abbiamo gia' visto alcuni esempi relativi al tipo 
        di programma appena accennato.
        L'altro  tipo  di  programmi residenti sono quelli  del  tipo  di 
        SideKick (Tm).
        In  quest'ultimo  caso la ridirezione dei vettori  d'  interrupts 
        avviene  allo  scopo  di testare se in input sono  stati  battuti 
        certi tasti corrispondenti a quelli per l'attivazione.
        Come  vedremo successivamente potrebbe verificarsi la  necessita' 
        di ridirigere o addirittura di scrivere altre routine.
        Parlando  dell'interrupt 27H avevo accennato alla difficolta'  di 
        scrivere in linguaggio C simili programmi.
        In  alcuni casi i problemi sono minimi ma in altri possono essere 
        talmente complicati da far preferire una scrittura in  linguaggio 
        assembler.
        In  ogni  caso non voglio lasciare ad intendere che  scrivere  un 
        programma residente in memoria mediante quest' ultimo risulti una 
        cosa semplice.
        Le  strade  percorse  da coloro che hanno  scritto  programmi  di 
        questo tipo sono svariate e non si puo' in nessun caso parlare di 
        tecniche uniche.
        In  un  esempio  riportato nel capitolo riguardante  la  gestione 
        della  tastiera  avevamo  visto un programma  che  modificava  il 


                                       309





        Linguaggio C per MS DOS - F. Bernardotti - 1987 Opus Free Soft





        vettore   dell'   interrupt   16H   allo   scopo   di    eseguire 
        l'intercettazione del tasto CTRL B.
        Essenzialmente  un programma residente si puo' suddividere in due 
        parti  ovvero  la  parte  che rimarra'  in  memoria  e  la  parte 
        d'installazione non residente.
        Questo e' a livello semplicistico in quanto come vedremo esistono 
        ben altre problematiche.
        Quando  esiste la possibilita' conviene scrivere un programma  in 
        modo che risulti un .COM.
        In ogni caso,  per tornare al discorso di prima, possiamo fare la 
        seguente schematizzazione.

        segmento  codice
                  origine 100H
                  salta all'installazione 

        procedura residente interrupt
                  abilita interrupt
                  e' una richiesta input tastiera ?
                  se si chiama vecchio interrupt (CALL)
                  altrimenti salta vecchio interrupt (JMP)
                  controlla il tasto
                  ..................
                  nostro programma
                  ..................
                  ritorna interrupt (IRET)
        procedura residente fine

        installazione parte NON residente
                  controllo se la procedura e' gia' stata installata
                  disattivazione CTRL BREAK
                  salvataggio vecchio vettore interrupt
                  settaggio  nuovo vettore interrupt indirizzo  procedura 
                  residente
                  termina ma rimani residente
        fine      segmento codice

        Come  avrete notato ho segnato tra parentesi due diversi tipi  di 
        richiami alle vecchie routine d'interrupt.
        Come  sapra'  chi  conosce  l'assembler il  salto  (JMP)  non  e' 
        condizionato  al  ritorno  mentre  la  chiamata  (CALL)  mediante 
        l'istruzione RET ripristina l'indirizzo successivo alla CALL.
        Questo  significa  che  il controllo all'interno  della  modifica 
        della  routine d'interrupt avverra' prima sul  registro  AH,  che 
        come  sapete  contiene  il numero del  servizio,  allo  scopo  di 
        controllare se si tratta di una richiesta d'input da tastiera.
        Nel  caso che AH contenga il codice relativo ad un altro servizio 
        e' inutile proseguire e quindi mediante un salto senza ritorno si 
        ripassa il controllo alla vecchia routine d'interrupt.
        In  caso affermativo allora ci sara' una chiamata con ritorno  in 
        quanto  dopo  che la vecchia routine d'interrupt ha  inputato  il 
        tasto  ci  dovra' essere il controllo sul suo codice al  fine  di 


                                       310





        Linguaggio C per MS DOS - F. Bernardotti - 1987 Opus Free Soft




        accertare che questo sia quello da noi aspettato.
        Chiaramente  se questo equivale allora prima dell' IRET ci  sara' 
        il richiamo al nostro programma residente.
        In  altre  parole  quando ci serve una chiamata  con  ritorno  al 
        vecchio interrupt potremo simulare questa con

                        pushf
                        cli
                        call DWORD PTR cs:vecchio_vettore     
           
        Nel caso che il salto debba essere incondizionato allora

                        pop registri salvati
                        cli
                        jmp DWORD PTR cs:vecchio_vettore

        In questo ultimo caso non avremo piu' il controllo del programma.
        Voglio ripetere il discorso relativo alla chiamata dell'interrupt 
        a  costo di sembrare pedante in quanto penso che  sia  necessario 
        capire il suo meccanismo.
        Normalmente  quando  viene chiamato un interrupt viene  letto  il 
        segmento  e  l'offset della routine di servizio dalla tavola  dei 
        vettori.
        Supponendo di aver ridiretto l' int 16H e' chiaro che l'indirizzo 
        contenuto  in  questa  tabella e'  quello  relativo  alla  nostra 
        routine  residente  in  quanto  l'operazione  e'  stata  eseguita 
        mediante la funzione d'installazione.
        Come   sapete  un'  interrupt  potrebbe  svolgere  piu'   servizi 
        selezionabili,  mediante opportuno settaggio prima della chiamata 
        stessa, all'interno del registro AH.
        Tutto   questo  significa  che  quando  ci  sara'  una   chiamata 
        all'interrupt 16H il controllo passera' alla nostra routine.
        Ora si dovra' vedere se si tratta di una richiesta d' input.

        _key_i proc       near
               sti
               cmp        ah,0               ;e' una richiesta d'input
               jne        kio                ;se no salta alla vecchia
                                             ;routine.
               pushf                         ;se si simula una chiamata
               cli                           ;al vecchio interrupt e dopo
               call       dword ptr cs:o_kio ;che ha eseguito  la  sua 
                                             ;funzione
               sti
               cmp        ax,4900H           ;controlla se e' PgUp
               jne        fine               ;se no ritorna dall'int
               NOSTRE FUNZIONI........       ;se si richiama funzioni
        fine:
               iret
        kio:
               jmp        dword ptr cs:o_kio
        _key_i endp



                                       311





        Linguaggio C per MS DOS - F. Bernardotti - 1987 Opus Free Soft





        L'esempio  precedente  non e' completo in quanto  entrando  nella 
        routine  d'interrupt si dovrebbero salvare tutti i  registri  che 
        pensiamo vengano cambiati per poi ripristinarli prima di uscire.
        Il discorso della memorizzazione e del  ripristino vale anche per 
        quanto  riguarda l'ambiente precedente alla possibile  esecuzione 
        delle nostre funzioni.
        Supponiamo che si stia lavorando con un programma di WP e che  la 
        nostra  utility  residente  sia una finestra  in  cui  appare  un 
        calcolatore tipo quello di SideKich.
        Prima  di  eseguire il richiamo alle funzioni di  questo  dovremo 
        salvare  il  modo  video  utilizzato  dal  programma  di  WP,  la 
        schermata  presente ecc.  in modo che terminando il nostro lavoro 
        con  l'  utility sia possibile ripristinare l'ambiente  originale 
        del WP.
        Sempre   nell'esempio  precedente  avrete  notato   l'uso   delle 
        istruzioni CLI e STI.
        Quando   una   routine   d'interrupt   e'   chiamata    il   flag 
        d'interruzione  e' settato in modo che non possa essere richiesto  
        nessun altro interrupt mascherabile.
        Lasciare  disabilitati questi interrupts per un tempo  abbastanza 
        lungo  puo'  creare  dei problemi in  quanto  potrebbero  esserci 
        alcune  periferiche i cui programmi agiscono in  background  che, 
        nel frattempo che la nostra utility e' attiva, eseguono chiamate.
        Appena  si presenta la possibilita' conviene riabilitare il tutto 
        mediante l'istruzione STI.
        Il  problema  maggiore per la stesura di programmi  residenti  in 
        memoria e' dato dagli interrupts non rientranti.
        Il  termine "rientrante" mi lascia un po' perplesso in quanto non 
        so' se e' la traduzione esatta della parola inglese "reentrancy".
        Tra questo tipo di interrupts troviamo quelli del Dos.
        Mi spiego meglio.
        Il Bios quando esegue una routine d'interrupt utilizza i registri 
        e   lo   stack   per  salvare   alcuni   valori   usati   durante 
        l'elaborazione.
        Il Dos, al contrario, utilizza delle zone di memoria per eseguire 
        lo stesso compito.
        Supponendo  che venga effettuata una chiamata ad un servizio  del 
        Dos  questa verrebbe eseguita e alcuni valori verrebbero  salvati 
        all'interno di variabili in memoria.
        Se  per puro caso venisse eseguita una seconda call al Dos mentre 
        la  prima  non e' ancora terminata si potrebbe verificare  che  i 
        dati salvati in una determinata area  dal primo servizio  vengano 
        ricoperti da quelli scritti dal secondo.  
        Questo  ci  spinge a pensare che nei nostri  programmi  residenti 
        dobbiamo vagliare l'istante in cui eseguire una call al Dos.
        Un  eventuale  chiamata  ad un servizio  potrebbe  avvenire  solo 
        nell'istante in cui il Dos risulta essere libero. 
        Allo  scopo  di girare intorno a questo tipo di  problema  ci  si 
        presenta una soluzione.
        Tra   gli   interrupts   e  le  calls   non   documentate   visti 
        precedentemente  c'era  il servizio 34H dell'interrupt 21H  (Find 
        active byte).


                                       312





        Linguaggio C per MS DOS - F. Bernardotti - 1987 Opus Free Soft






        Il  metodo per accertarsi se e' in corso o meno una call del  Dos 
        e' quello di utilizzare questa funzione.
        Questo servizio riporta il numero di chiamate al Dos che sono  in 
        esecuzione.
        Il valore riportato dal servizio puo' essere  0,  nel caso che il 
        Dos  sia libero,  oppure maggiore di 0,  nel caso che ci sia  una 
        call attiva.
        Questo detto in altre parole significa che durante la stesura  di 
        un  programma  residente  non potremo  chiamare  direttamente  un 
        servizio  del Dos ma potremo farlo chiamando una nostra  funzione 
        che  prima di eseguire la call dovra' accertarsi che il  Dos  non 
        sia attivo.
        Un esempio come quello che segue potrebbe sembrare essere esatto:


                       ...........       ; ERRATO !!!!!!!
        attivo         dw     ?,?    
                       ...........
                       jmp    init

        new_interrupt  proc   far
                       ...........
                       mov    ah,00H  ;prima di richiedere la call  00H
                       call   active  ;dell'int 21H guarda se il DOS e'
                       int    21H     ;attivo.
                       ...........
        new_interrupt  endp

        active         proc   near
                       push   di
                       push   bp
                       mov    di,attivo
                       mov    ax,attivo[2]
                       mov    bp,ax
        a_1:
                       cmp    BYTE PTR [bp][di],0
                       jne    a_1
                       pop    bp
                       pop    di
                       ret
        active         endp

        init:
                       ...........
                       push   es
                       mov    ah,34H
                       int    21H
                       mov    attivo,bx
                       mov    attivo[2],es
                       pop    es
                       ...........


                                       313





        Linguaggio C per MS DOS - F. Bernardotti - 1987 Opus Free Soft



                                  

        Purtroppo  si rivela inefficace in quanto se nella routine active 
        ci si entra nell' istante in cui  il Dos non e' attivo allora  si 
        esce normalmente.
        Nel caso in cui ci si entra quando l'active byte e' attivo allora 
        il  programma  si blocca miseramente in quanto ci si entra in  un 
        loop infinito.
        Il  nostro  programma occuperebbe per eseguire il loop  tutto  il 
        tempo  macchina  non  dando la possibilita' al Dos  di  finire  i 
        servizi che erano attivi e quindi di settare l'active byte a off.
        La  nostra  funzione  destinata a controllare lo  stato  del  Dos 
        dovra' essere abbinata ad un interrupt come l'int 8.
        Questo come saprete viene richiamato varie volte al secondo.
        In altre parole potremmo scrivere una piccola routine collegata a 
        questo  interrupt che testi tutte le volte che viene  richiamato, 
        in  genere 18.2 volte al secondo,  l'active byte e che  setti  un 
        flag ad indicare che il Dos e' attivo o meno.
        Dal  nostro programma dovremo successivamente testare questo flag 
        per  sapere  se esiste o meno la possibilita' di  richiamare  una 
        call del Dos.
        C'e'  anche  la  possibilita' di utilizzare l'int  28H  che  come 
        abbiamo visto viene richiamato quando il Dos attende un input.
        Un altro esempio legato all'active byte e' il seguente.
        Si tratta di una routine collegata all'interrupt 1CH (Timer Tick) 
        che  testa  lo  stato dell'active byte e lo stampa  18  volte  al 
        secondo nell'angolo in alto a sinistra.


        ;
        ; Show Active Byte - ACTIVE.ASM
        ;

        code     segment   para   'code'
                 assume    cs:code, ds:code
                 org       100H
                 ;
        active   dw        ?,?
                 ;
                 jmp       init
                 ;
        new      proc      far
                 push      ax
                 push      ss
                 push      bp
                 push      ds
                 push      di
                 push      cx
                 push      dx
                 push      bx
                 push      es
                 sti
                 ;
                 mov       ax,0B800H


                                       314





        Linguaggio C per MS DOS - F. Bernardotti - 1987 Opus Free Soft







                 push      ds
                 mov       ds,ax
                 mov       cx,active[2]
                 mov       bp,cx
                 mov       di,active
                 ;
                 mov       al,BYTE PTR [bp][di]
                 add       al,10
                 mov       ds:[0],al
                 pop       ds
                 ;
                 pop       es
                 pop       bx
                 pop       dx
                 pop       cx
                 pop       di
                 pop       ds
                 pop       bp
                 pop       ss
                 pop       ax
                 iret
        new      endp
                 ;
        init:
                 ;
                 mov       ah,25H
                 mov       al,1CH
                 mov       bx,SEG new
                 mov       ds,bx
                 mov       dx,OFFSET new
                 int       21H
                 ;
                 push      es
                 mov       ah,34H
                 int       21H
                 mov       active,bx
                 mov       active+2,es
                 pop       es
                 ;
                 mov       dx,OFFSET init+100H
                 int       27H
        code     ends
                 end
         








                                       315





        Linguaggio C per MS DOS - F. Bernardotti - 1987 Opus Free Soft






        Potrebbe essere adottata per piccole routine il seguente caso.
        L'interrupt  16H (o al limite il 9H) viene ridiretto in modo  che 
        testi i caratteri in input alla ricerca del tasto di attivazione.
        Quando   questo   viene   intercettato   la   routine   collegata 
        all'interrupt  di input da tastiera setta un flag che  indichera' 
        all'interrupt 8H lo stato di attivo.
        Questo  con il flag non settato tutte le volte che viene chiamato 
        ritorna mediante un IRET.
        Nel caso che l'int 8H testi il flag e verifichi la condizione  di 
        attivazione  eseguira'  le  altre  funzioni  legate  alla  nostra 
        utility.
        In  questo caso la routine collegata all'int 8H non ha solo  piu' 
        lo  scopo  di controllare lo stato del Dos ma  bensi'  quello  di 
        eseguire  il  nostro programma in quanto questo  difatti  diventa 
        parte della routine di servizio dell'interrupt.
        Nel  seguente  esempio  viene  utilizzato  solo  l'interrupt  16H 
        che intercetta CTRL F1 o CTRL F2 e attiva l'applicazione.
        Il  programma  serve al monitoraggio delle porte seriali  COM1  e 
        COM2.

        ;
        ;----------------------------------------------------------
        ; TSR.ASM
        ;----------------------------------------------------------
        ; NOTA: Il programma e' in grado di stabilire il tipo  di
        ; scheda video  installata.     I tipi validi sono CGA ed
        ; Hercules.
        ;----------------------------------------------------------
        ;
        attivable      equ      0
        noattiva       equ      1
        ;
        ;
        code           segment     para   public   'code'
                       assume      cs:code
        ;
        ;----------------------------------------------------------
        ; Salta a inizializzazione vettore interrupt 16H
        ;----------------------------------------------------------
        ;
                       jmp     init
        ;
        ;----------------------------------------------------------
        ; Vecchi vettori d'interrupts e flag indicanti attivazione
        ;----------------------------------------------------------
        ;
        dtr_on         db      '1'
                       db      '$'

                                                            Segue ...



                                       316





        Linguaggio C per MS DOS - F. Bernardotti - 1987 Opus Free Soft



        dtr_off        db      '0'
                       db      '$'
        error          db      10,10,13
                       db      7
                       db      'Non ci sono porte seriali'
                       db      10,13
                       db      'Impossibile installare Monitor'
                       db      10,10,13
                       db      '$'
        buffer         dw      2000 dup(0)
        m_1            db      '+---[COM  Monitor  1.0]---+'
                       db      10,13
                       db      ':                         :'
                       db      10,13
                       db      ': DCD  RNG  DSR  CTS  DTR :'
                       db      10,13
                       db      ': +-+  +-+  +-+  +-+  +-+ :'
                       db      10,13
                       db      ': : :  : :  : :  : :  : : :'
                       db      10,13
                       db      ': +-+  +-+  +-+  +-+  +-+ :'
                       db      10,13
                       db      ':                         :'
                       db      10,13
                       db      '+-------------------------+'
                       db      '$'
        attivo         db      '1'
                       db      '$'
        non_att        db      '0'
                       db      '$'
        ;
        ;
        cur_type_ch    db      0
        cur_type_cl    db      0
        cur_pos_x      db      0
        cur_pos_y      db      0
        ;
        old_int_16     dw      ?,?
        utile          db      0
        flag           db      0
        status         db      0
        video_type     dw      ?
        port_attive    db      0
        num_port       db      0
        port_address   dw      0
        port_cl        dw      0
        port_lsb       dw      0
        port_msb       dw      0
        port_cm        dw      0
        com_1          db      '1'
                       db      '$'

                                                              Segue ....



                                       317





        Linguaggio C per MS DOS - F. Bernardotti - 1987 Opus Free Soft



        com_2          db      '2'
                       db      '$'
        msb            db      0
        lsb            db      0
        boh            db      '????'
                       db      '$'
        baud300        db      ' 300'
                       db      '$'
        baud1200       db      '1200'
                       db      '$'
        baud2400       db      '2400'
                       db      '$'
        baud4800       db      '4800'
                       db      '$'
        baud9600       db      '9600'
                       db      '$'
        parity_ev      db      ',E'
                       db      '$'
        parity_no      db      ',N'
                       db      '$'
        data_bit_8     db      ',8,'
                       db      '$'
        data_bit_7     db      ',7,'
                       db      '$'
        stop_bit_1     db      '1'
                       db      '$'
        stop_bit_2     db      '2'
                       db      '$'
        ;
        ;----------------------------------------------------------
        ; Routine interrupt 16H
        ;----------------------------------------------------------
        ;
        new_int_16     proc      far
                 sti
                 cmp      ah,0
                 jne      old_int_jmp
                 pushf
                 call     DWORD PTR cs:old_int_16
                 cmp      ax,5E00H
                 jne      com2
        com1:
                 call     set_port_1
                 mov      cs:port_attive,1
                 jmp      test_ok
        com2:
                 cmp      ax,5F00H
                 jne      end_int
                 cmp      cs:num_port,2
                 jne      com1
                 call     set_port_2
                 mov      cs:port_attive,2
                                                              Segue ...   



                                       318





        Linguaggio C per MS DOS - F. Bernardotti - 1987 Opus Free Soft




        test_ok:
                 cmp      cs:flag,attivable
                 jne      end_int
                 mov      cs:flag,noattiva
                 call     new_direct
                 mov      cs:flag,attivable
        end_int:
                 iret
        old_int_jmp:
                 jmp      DWORD PTR cs:old_int_16
        new_int_16        endp
        ;
        ;----------------------------------------------------------
        ; Setta porte COM1
        ;----------------------------------------------------------
        ;
        set_port_1      proc      near
                 mov      cs:port_address,3FEH
                 mov      cs:port_cl,3FBH
                 mov      cs:port_lsb,3F8H
                 mov      cs:port_msb,3F9H
                 mov      cs:port_cm,3FCH
                 ret
        set_port_1      endp
        ;
        ;----------------------------------------------------------
        ; Setta porte COM2
        ;----------------------------------------------------------
        ;
        set_port_2      proc      near
                 mov      cs:port_address,2FEH
                 mov      cs:port_cl,2FBH
                 mov      cs:port_lsb,2F8H
                 mov      cs:port_msb,2F9H
                 mov      cs:port_cm,2FCH
                 ret
        set_port_2      endp
        ;
        ;----------------------------------------------------------
        ; Procedura principale
        ;----------------------------------------------------------
        ;
        new_direct       proc      near
                 push      ax
                 push      bx
                 push      cx
                 push      dx
                 push      si
                 push      di
                 push      es
                 push      ds
                                                              Segue .... 



                                       319





        Linguaggio C per MS DOS - F. Bernardotti - 1987 Opus Free Soft





                 call      get_video
                 call      save_cur
                 mov       ah,1
                 mov       ch,13H
                 mov       cl,13H
                 int       10H
                 call      leggi
                 call      clear
                 mov       dh,0
                 mov       dl,0
                 call      at
                 lea       dx,m_1
                 call      print
                 mov       dh,0
                 mov       dl,8
                 call      at
                 cmp       cs:port_attive,2
                 jne       a_35
                 lea       dx,com_2
                 jmp       pok
        a_35:
                 lea       dx,com_1
        pok:
                 call      print
                 call      f_read
                 call      spy_baud
                 call      dtr
                 call      parity
                 mov       ah,0
                 int       16H
                 call      scrivi
                 mov       dh,cs:cur_pos_y
                 mov       dl,cs:cur_pos_x
                 call      at
                 mov       ah,1
                 mov       ch,cs:cur_type_ch
                 mov       cl,cs:cur_type_cl
                 int       10H
        ;
                 pop       ds
                 pop       es
                 pop       di
                 pop       si
                 pop       dx
                 pop       cx
                 pop       bx
                 pop       ax
                 ret
        new_direct         endp

                                                          Segue ....



                                       320





        Linguaggio C per MS DOS - F. Bernardotti - 1987 Opus Free Soft





        ;
        ;---------------------------------------------------------
        ; Controlla parita', data bit e stop bit
        ;---------------------------------------------------------
        ;
        parity         proc      near
                 mov      dx,port_cl
                 in       al,dx
                 mov      cs:utile,al
                 mov      dh,6
                 mov      dl,12
                 call     at
                 mov      al,cs:utile
                 and      al,8
                 jz       none
                 lea      dx,parity_ev
                 jmp      end_p_a
        none:
                 lea      dx,parity_no
        end_p_a:
                 call     print
                 mov      al,cs:utile
                 and      al,3
                 cmp      al,2
                 jne      otto
                 lea          dx,data_bit_7
                 jmp      stampa
        otto:
                 lea      dx,data_bit_8
        stampa:
                 call     print
                 mov      al,cs:utile
                 and      al,8
                 cmp      al,8
                 jne      uno
                 lea      dx,stop_bit_2
                 jmp      end_stop
        uno:
                 lea      dx,stop_bit_1
        end_stop:
                 call     print
                 ret
        parity            endp







                                                        Segue ....



                                       321





        Linguaggio C per MS DOS - F. Bernardotti - 1987 Opus Free Soft


        ;
        ;---------------------------------------------------------
        ; Controlla dtr
        ;---------------------------------------------------------
        ;
        dtr         proc      near
                 mov      dh,4
                 mov      dl,23
                 call     at
                 mov      dx,port_cm
                 in       al,dx
                 test     al,1
                 jz       no_dtr
                 lea      dx,dtr_on
                 jmp      end_pa
        no_dtr:
                 lea      dx,dtr_off
        end_pa:
                 call     print
                 ret
        dtr               endp
        ;
        ;---------------------------------------------------------
        ; Legge baud rate, parity, data bit, stop bit e dtr
        ;---------------------------------------------------------
        ;
        spy_baud      proc      near
                 mov      dh,6
                 mov      dl,8
                 call     at
                 mov      dx,port_cl
                 in       al,dx
                 or       al,128
                 out      dx,al
                 mov      dx,port_lsb
                 in       al,dx
                 mov      cs:lsb,al
                 mov      dx,port_msb
                 in       al,dx
                 mov      cs:msb,al
                 cmp      msb,01H
                 jne      no_300
                 lea      dx,baud300
                 jmp      end_spy
        no_300:
                 cmp      lsb,60H
                 jne      no_1200
                 lea      dx,baud1200
                 jmp      end_spy
        no_1200:
                 cmp      lsb,30H
                 jne      no_2400
                 lea      dx,baud2400
                 jmp      end_spy                          Segue ....



                                       322





        Linguaggio C per MS DOS - F. Bernardotti - 1987 Opus Free Soft







        no_2400:
                 cmp      lsb,18H
                 jne      no_4800
                 lea      dx,baud4800
                 jmp      end_spy
        no_4800:
                 cmp      lsb,0CH
                 jne      non_so
                 lea      dx,baud9600
                 jmp      end_spy
        non_so:
                 lea      dx,boh
        end_spy:
                 call     print
                 mov      dx,port_cl
                 in       al,dx
                 and      al,127
                 out      dx,al
                 ret
        spy_baud          endp
        ;
        ;---------------------------------------------------------
        ; Cerca il tipo di video per settare segmento buffer
        ;---------------------------------------------------------
        ;
        get_video      proc      near
                 push     es
                 mov      ax,40H
                 mov      es,ax
                 mov      al,es:[10H]
                 and      al,00110000b
                 cmp      al,48
                 je       mono
                 mov      cs:video_type,0B800H
                 jmp      end_get
        mono:
                 mov      cs:video_type,0B000H
        end_get:
                 pop      es
                 ret
        get_video         endp







                                                              Segue ....



                                       323





        Linguaggio C per MS DOS - F. Bernardotti - 1987 Opus Free Soft




        ;
        ;---------------------------------------------------------
        ; Salva la posizione del cursore per poi ripristinarla
        ;---------------------------------------------------------
        ;
        save_cur      proc      near
                 mov      bh,0
                 mov      ah,3
                 int      10H
                 mov      cs:cur_pos_x,dl
                 mov      cs:cur_pos_y,dh
                 mov      cs:cur_type_ch,ch
                 mov      cs:cur_type_cl,cl
                 ret
        save_cur          endp
        ;
        ;---------------------------------------------------------
        ; Legge i bit della porta 3FEH
        ;---------------------------------------------------------
        ;
        f_read         proc      near
                 mov      dx,cs:port_address
                 in       al,dx
                 mov      cs:status,al
                 mov      dh,4
                 mov      dl,3
                 test     status,128
                 jz       a_1
                 mov      al,1
                 jmp      a_2
        a_1:
                 mov      al,0
        a_2:
                 call     at_print
                 mov      dh,4
                 mov      dl,8
                 test     status,64
                 jz       a_3
                 mov      al,1
                 jmp      a_4
        a_3:
                 mov      al,0
        a_4:
                 call     at_print
                 mov      dh,4
                 mov      dl,13
                 test     status,32
                 jz       a_7
                 mov      al,1
                 jmp      a_8

                                                              Segue ....



                                       324





        Linguaggio C per MS DOS - F. Bernardotti - 1987 Opus Free Soft




        a_7:
                 mov      al,0
        a_8:
                 call     at_print
                 mov      dh,4
                 mov      dl,18
                 test     status,16
                 jz       a_11
                 mov      al,1
                 jmp      a_12
        a_11:
                 mov      al,0
        a_12:
                 call     at_print
                 ret
        f_read            endp
        ;
        ;----------------------------------------------------------
        ; Stampa a una certa posizione flag (0 o 1)
        ;----------------------------------------------------------
        ;
        at_print      proc      near
                 call     at
                 cmp      al,1
                 jne      off
                 lea      dx,cs:attivo
                 jmp      e_a
        off:
                 lea      dx,cs:non_att
        e_a:
                 call     print
                 ret
        at_print          endp
        ;
        ;---------------------------------------------------------
        ; Stampa stringa
        ;---------------------------------------------------------
        ;
        print         proc      near
                 push     cs
                 pop      ds
                 mov      bl,112
                 mov      si,dx
        p_1:
                 mov      al,[si]
                 cmp      al,'$'
                 je       p_end
                 mov      ah,0EH
                 int      10H
                 inc      si
                 jmp      p_1
                                                            Segue ....



                                       325





        Linguaggio C per MS DOS - F. Bernardotti - 1987 Opus Free Soft




        p_end:
                 ret
        print             endp
        ;
        ;---------------------------------------------------------
        ; Posiziona il cursore
        ;---------------------------------------------------------
        ;
        at         proc      near
                 push     ax
                 mov      ah,2
                 mov      bh,0
                 int      10H
                 pop      ax
                 ret
        at                endp

        ;
        ;----------------------------------------------------------
        ; Memorizza video
        ;----------------------------------------------------------
        ;
        leggi         proc      near
                 mov      ax,cs:video_type
                 mov      ds,ax
                 mov      si,0000H
                 push     cs
                 pop      es
                 mov      di,OFFSET buffer
                 mov      cx,2000
                 cld
                 rep      movsw
                 ret
        leggi             endp
        ;
        ;-----------------------------------------------------------
        ; Riscrive video
        ;-----------------------------------------------------------
        ;
        scrivi         proc      near
                 push      cs
                 pop       ds
                 mov       si,offset buffer
                 mov       ax,cs:video_type
                 mov       es,ax
                 mov       di,0000H
                 mov       cx,2000   
                 cld
                 rep       movsw
                 ret
        scrivi             endp
                                                          Segue ....



                                       326





        Linguaggio C per MS DOS - F. Bernardotti - 1987 Opus Free Soft




        ;
        ;-----------------------------------------------------------
        ; Cancella la finestra
        ;-----------------------------------------------------------
        ;
        clear         proc      near
                 mov      al,0
                 mov      ah,7
                 mov      ch,0
                 mov      cl,0
                 mov      dh,7
                 mov      dl,26
                 mov      bh,112
                 int      10H
                 ret
        clear             endp
        ;
        ;-----------------------------------------------------------
        ; Inizializzazione vettore interrupt 16H
        ;-----------------------------------------------------------
        ;
        init:
                 assume   ds:code
                 call     verify_port
                 cmp      cs:num_port,0
                 jne      ok
                 lea      dx,error
                 call     print
                 int      20H
        ok:
                 push     cs
                 pop      ds
        ;
                 mov      ah,35H
                 mov      al,16H
                 int      21H
                 mov      WORD PTR old_int_16,bx
                 mov      WORD PTR old_int_16[2],es
        ;
                 mov      ah,25H
                 mov      al,16H
                 mov      bx,SEG new_int_16
                 mov      ds,bx
                 mov      dx,OFFSET new_int_16
                 int      21H
        ;
                 lea      dx,copyright
                 call     print
        ;
                 mov      dx,OFFSET init+100H
                 int      27H
                                                              Segue ....



                                       327





        Linguaggio C per MS DOS - F. Bernardotti - 1987 Opus Free Soft




        copyright db      10,10,13
                  db      '***> RESIDENT COM MONITOR <***'
                  db      10,13
                  db      '(C)  Copyright  Opus Free Soft'
                  db      10,13
                  db      'by F.Bernardotti Montecastello'
                  db      10,10,13
                  db      'Premi :     <Ctrl-F1> per COM1'
                  db      10,13
                  db      '      :     <Ctrl-F2> per COM2'
                  db      10,10,13
                  db      '$'
        ;
        ;------------------------------------------------------------
        ; Verifica il numero di porte seriali installate
        ;------------------------------------------------------------
        ;
        verify_port      proc      near
                 mov      ax,40H
                 mov      es,ax
                 mov      al,es:[11h]
                 and      al,00000110b
                                shr      al,1
                 mov      cs:num_port,al
                 ret
        verify_port       endp
        code              ends
                          end



        Utilizzando  per  l'esecuzione  l'interrupt 16H  ci  troviamo  di 
        fronte ad altre problematiche.
        Ad  esempio  si  dovrebbe  testare prima di ogni  chiamata  a  un 
        interrupt  che  non  ce  ne  siano  altri,  di  quelli  hardware, 
        pendenti.
        Il risultato si ottiene nel seguente modo 

                                 cli
                                 mov  al,11
                                 out  20H,al
                                 in   al,20H
                                 sti

        Da  questa  ultima  routine  e'  possibile  rilevare  se  qualche 
        interrupt hardware e' attivo testando il byte contenuto in AL.
        Se  il  valore  e'  0 significa che  non  c'e'  nessun  interrupt 
        attivo.
        In  ambedue  i  casi precedenti,  per  quanto  ci  e'  possibile, 
        conviene  usare chiamate al Bios anche se questo,  ad esempio per 
        servizi del disco, ci potrebbe risultare complicato.




                                       328





        Linguaggio C per MS DOS - F. Bernardotti - 1987 Opus Free Soft




        Un  altro  accorgimento  e'  quello di  non  memorizzare  i  dati 
        allocandoli  in  memoria e di utilizzare al suo posto i  registri 
        del  processore.
        Ad  ogni  call dovra' corrispondere un operazione di  salvataggio 
        di questi nello stack e una di  ripristino prima della fine.
        Il  discorso  dello  stack e' interessante in  quanto  si  dovra' 
        fornire al nostro programma uno di questi sufficentemente grande.
        Il meccanismo di chiamata di un interrupt salva nello stack molti 
        valori.
        Quando  avevamo parlato dell' interrupt 1CH si era detto  che  un 
        problema  era  costituito  da una routine  abbastanza  lunga   in 
        quanto  si  sarebbe potuto verificare  una   successiva  chiamata 
        mentre la prima era ancora in esecuzione.
        Lo   stesso   problema  potrebbe  presentarsi  con  i   programmi 
        residenti.
        Supponiamo di aver ridiretto l'interrupt 16H per fare in modo che 
        questo  testi  i codici dei caratteri inputati da  tastiera  alla 
        ricerca di quello relativo all'attivazione della nostra routine.
        Una  volta  attivata si potrebbe verificare che  vengano  premuti 
        nuovamente i tasti di richiamo.
        La  call al nostro programma residente non dovrebbe  avvenire  in 
        quando questo e' gia' attivo e quindi in esecuzione.
        Il   metodo  per  superare  questo  ostacolo  ci  viene   offerto 
        dall'inserimento  di  un flag con il compito di segnalare  se  la 
        nostra routine e' attiva o meno.
        Nel programma esempio precedente questo compito e' assegnato alla 
        variabile FLAG.
        In  caso  affermativo si dovrebbe verificare un salto al  vecchio 
        vettore d'interrupt senza piu' eseguire l'attivazione. 
        Un  altro  pasticcio  riguardante la rientranza  e'  dovuto  all' 
        utilizzo degli stacks da parte, ad esempio, del Dos.
        Il  Dos  al termine di una chiamata a un servizio  ripristina  il 
        contenuto dello stack.
        Supponendo  che  sia  in esecuzione una call e'  chiaro  che  una 
        successiva  rischia  di  mandare in overflow il  contenuto  dello 
        o  degli,  piu' di uno,  stacks utilizzati senza contare  che  il 
        ripristino  potrebbe  fare  perdere il contenuto  presente  prima 
        della chiamata stessa.
        Questo  induce  a pensare che i registri SS e  SP  devono  essere 
        salvati.
        Notate che alcune calls del Dos utilizzano due stack mentre altre 
        arrivano fino a tre.
        Bisogna  cercare di minimizzare l'utilizzo dello stack  da  parte 
        dei nostri programmi TSR ed in ogni caso salvare quelli del Dos.
        I  problemi riguardanti l'installazione di un programma residente 
        non sono finiti.
        Una delle necessita' in alcuni casi e' quella di settare il PSP.
        Quando  vengono  eseguiti dei servizi su disco e' conveniente  in 
        fase  d' installazione del nostro programma  salvare  l'indirizzo 
        del  PSP  per  poi,  nella parte residente,  eseguire  lo  switch 
        sostituendo  quello  del  programma su cui  siamo  "apparsi"  con 
        quello relativo alla nostra routine.



                                       329





        Linguaggio C per MS DOS - F. Bernardotti - 1987 Opus Free Soft






        Chiaramente in uscita si dovra' ripristinarlo.
        Questi scopi possono essere ottenuti mediante le call gia'  viste 
        in  precedenza  con i servizi del Dos e precisamente la  50H  per 
        settare  il  nuovo  PSP  e la 51H  per  salvare  l'indirizzo  del 
        vecchio.
        E' anche conveniente settare, se il servizio esegue operazioni su 
        disco, un nuovo DTA.
        Nell'esempio  precedente ho omesso una parte di  codice  relativo 
        alla  segnalazione della gia' avvenuta installazione nel caso che 
        si tenti di rileggere una seconda volta il programma.
        Come  avrete  notato TSR salva inizialmente i vecchi  vettori  di 
        interrupts   (in questo caso solo il 16H) per poterli  richiamare 
        per lo svolgimento delle funzioni ad essi associate.
        Se  si rileggesse la seconda volta TSR e' chiaro che  l'indirizzo 
        della routine dell' interrupt 16H non sarebbe piu' l'originale in 
        quanto questa e' gia' stata modificata dalla prima installazione.
        Per  raggirare  il problema si puo'  utilizzare  una  particolare 
        scritta  di  riconoscimento collegata a un vettore  di  interrupt 
        libero (ad esempio dal 60H al 67H).
        In  fase di installazione si dovrebbe ricavare l'indirizzo  della 
        routine   di  questo  interrupt  leggendo  poi  se  esiste   gia' 
        a questo offset l'identificatore dell'installazione.
        In caso affermativo si dovrebbe uscire senza rinstallare il tutto 
        segnalandolo con un messaggio.
        Precedentemente   avevo   detto  che  si  doveva  salvare   prima 
        dell'attivazione  tutti i parametri riguardanti al  programma  su 
        cui compare il nostro TSR.
        Tra  questi  parametri  ritroviamo  il modo  video,  il  tipo  di 
        cursore e la posizione di questo.
        Bisogna  anche  prestare attenzione  durante  l'esecuzione  della 
        nostra  utility a non modificare variabili del Bios (0040:xxxx) o 
        il settaggio delle porte.
        E' chiaro che se noi modifichiamo questi parametri al rientro nel 
        programma questo potrebbe trovarsi nei pasticci a causa di valori 
        non opportuni.
        Se  dovete  svolgere  le  operazioni  appena  dette  salvate   il 
        contenuto originale prima di eseguire modifiche e ripristinate il 
        tutto  prima  di uscire per fare in modo che "nessuno si  accorga 
        che voi siete passati di li'".
        Un  ultima  precauzione non adottata dall'esempio  precedente  e' 
        dato  dalla  necessita' di disattivare durante  l'esecuzione  del 
        nostro programma il Ctrl Break.
        E'  chiaro  che nel caso che questo sia attivo e premuto  non  si 
        potrebbe   verificare  un  ripristino  dell'ambiente   precedente 
        all'attivazione correndo seri pericoli di crash.
        Precedentemente ho generalizzato parlando delle call's al Dos.
        In  effetti quelle che procurano i maggiori inconvenienti sono le 
        precedenti alla 0CH e la 50H e 51H.
        Nell'ultimo esempio che riportero' viene aggiunto un servizio, se 
        cosi  si  puo'  dire,  all'int 16H allo scopo  di  vedere  se  il 
        programma e' stato gia' letto.


                                       330





        Linguaggio C per MS DOS - F. Bernardotti - 1987 Opus Free Soft




        Il  seguente esempio risiede in memoria e legge alla pressione di 
        ALT F1 la directory corrente.

        ;
        ; Il programma dopo essere caricato termina e rimane residente.
        ; Mediante la pressione di Ctrl F1 e' possibile  da   qualsiasi
        ; programma richiedere la Directory senza uscire sa questo.
        ; Rilascio anche i sorgenti per chi fosse interessato  ai  prg.
        ; residenti.
        ;
                 TITLE   READ_DIR
        attivable    equ      0
        noattiva     equ      1
        request      equ      "SD"
        respond      equ      "sd"
        ;
        ; Segmento codice
        ;
        code        segment   para   public   'code'
                    assume   cs:code,ds:code
        ;
        ; Salta a routine installazione
        ;
        showdir:   jmp      init
        ;
        ; Vecchi vettori e varie
        ;
        stop       db      0
        att        db      0
        schifi     db      '             .......',0
        masch1     db      '+--------[ DIRECTORY 2.1 ]-------+',0
        masch2     db      ':                                :',0
        masch3     db      '+--------------------------------+',0
        blank      db      '--------------------------------',0
        premi      db      '[Premi un tasto o  ESC per fine]',0
        righe      db      0
        old_dta    dw      ?,?
        cur_pos_x  db      0
        cur_pos_y  db      0
        cur_type_ch   db      0
        cur_type_cl   db      0
        dta        db      512   dup(0)
        utile      db      0
        this_psp   dw      ?
        old_psp    dw      ?
        old_int_1c    dw      ?,?
        old_int_16    dw      ?,?
        buffer     dw      2000 dup(?)
        screen     dw      0
        path       db      '*.*',0
        flag       db      0
        nessuno    db      'Nessun File',0



                                       331





        Linguaggio C per MS DOS - F. Bernardotti - 1987 Opus Free Soft





        ;
        ; Routine interrupt 16H
        ;
        new_int_16   proc   far
                 sti
                 cmp      ax,request
                 je       ok_re
                 cmp      ah,0
                 jne      old_int_jmp
                 pushf
                 cli
                 call     DWORD PTR cs:old_int_16
                 cmp      ax,5E00H
                 jne      end_int
                 cmp      cs:flag,attivable
                 jne      end_int
                 mov      cs:flag,noattiva
                 sti
                 jmp      activate
        end_int:
                 iret
        ok_re:
                 mov      ax,respond
                 jmp      end_int
        old_int_jmp:
                 jmp      DWORD PTR cs:old_int_16
        activate:
                 push     ax
                 push     ss
                 push     bp
                 push     bx
                 push     cx
                 push     dx
                 push     si
                 push     di
                 push     es
                 push     ds
        ;
                 assume   cs:code,ds:code
                 push     cs
                 pop      ds
                 mov      stop,0
                 call     set_psp
                 call     set_dta
                 call     screenproc
                 call     save_cur
                 call     leggi
                 call     clear
                 call     print_masc
                 call     print_dir
                 cmp      stop,1
                 je       basta


                                       332





        Linguaggio C per MS DOS - F. Bernardotti - 1987 Opus Free Soft



                 mov     dh,22
                 mov     dl,1
                 call    at
                 lea     dx,premi
                 call    print
                 mov     ah,0
                 int     16H
        basta:
                 call    restore_cur
                 call    scrivi
                 call    re_set_dta
                 call    re_set_psp
                 mov     cs:flag,attivable
        ;
        a_21:
                 pop      ds
                 pop      es
                 pop      di
                 pop      si
                 pop      dx
                 pop      cx
                 pop      bx
                 pop      bp
                 pop      ss
                 pop      ax
                 jmp      end_int
        new_int_16   endp
        ;
        ; Stampa maschera
        ;
        print_masc      proc      near
                 mov      dh,0
                 mov      dl,0
                 call     at
                 lea      dx,masch1
                 call     print
                 mov      cx,21
                 mov      dh,1
                 mov      dl,0
        a_2_1:
                 call     at
                 push     dx
                 lea      dx,masch2
                 call     print
                 pop      dx
                 inc      dh
                 loop     a_2_1
                 mov      dh,22
                 mov      dl,0
                 call     at
                 lea      dx,masch3
                 call     print
                 ret
        print_masc      endp


                                       333





        Linguaggio C per MS DOS - F. Bernardotti - 1987 Opus Free Soft





        ;
        ; Stampa riga ............................
        ;
        rig      proc   near
                 mov    dh,21
                 mov    dl,2
                 call   at
                 lea    dx,schifi
                 call   print
                 mov    dh,21
                 mov    dl,2
                 call   at
                 ret
        rig      endp
        ;
        ; Stampa dir
        ;
        print_dir   proc   near
                 mov    cs:righe,0
                 push   dx
                 push   cx
                 push   ax
                 push   cs
                 pop    ds
                 lea    dx,path
                 mov    cx,00FFH
                 mov    ah,4EH
                 int    21H
                 jc     errore
                 call   rig
        line:
                 lea    bx,dta
                 add    bx,30
        char:
                 mov    dl,[bx]
                 cmp    dl,0
                 je     finita
                 call   pr_char
                 inc    bx
                 jmp    char
        finita:
                 call   attrib
                 call   clear_one
                 mov    dh,21
                 mov    dl,2
                 call   at
                 cmp    righe,18
                 jne    ancora
                 call   set_righe
                 cmp    stop,1
                 je     ritorna
                 mov    cs:righe,0


                                       334





        Linguaggio C per MS DOS - F. Bernardotti - 1987 Opus Free Soft




        ancora:
                 call     rig
                 inc      righe
                 lea      dx,path
                 mov      ah,4FH
                 int      21H
                 jc       ritorna
                 jmp      line
        errore:
                 mov      dh,10
                 mov      dl,12
                 call     at
                 lea      dx,nessuno
                 call     print
        ritorna:
                 pop      ax
                 pop      cx
                 pop      dx
                 ret
        print_dir   endp
        ;
        ; Scrive attributi
        ;
        attrib      proc   near
                 mov      dh,21
                 mov      dl,24
                 call     at
                 mov      dl,'['
                 call     pr_char
                 lea      bx,dta+21
                 mov      ah,BYTE PTR [bx]
                 mov      att,ah
                 test     att,01
                 jz       bb_1
                 mov      dl,'r'
                 jmp      bb_2
        bb_1:
                 mov      dl,'-'
        bb_2:
                 call     pr_char
                 test     att,02
                 jz       bb_3
                 mov      dl,'h'
                 jmp      bb_4
        bb_3:
                 mov      dl,'-'
        bb_4:
                 call     pr_char
                 test     att,04
                 jz       bb_5
                 mov      dl,'s'
                 jmp      bb_6



                                       335





        Linguaggio C per MS DOS - F. Bernardotti - 1987 Opus Free Soft




        bb_5:
                 mov      dl,'-'
        bb_6:
                 call     pr_char
                 test     att,08
                 jz       bb_7
                 mov      dl,'v'
                 jmp      bb_8
        bb_7:
                 mov      dl,'-'
        bb_8:
                 call     pr_char
                 test     att,10H
                 jz       bb_9
                 mov      dl,'d'
                 jmp      bb_10
        bb_9:
                 mov      dl,'-'
        bb_10:
                 call     pr_char
                 test     att,20H
                 jz       bb_11
                 mov      dl,'a'
                 jmp      bb_12
        bb_11:
                 mov      dl,'-'
        bb_12:
                 call     pr_char
                 mov      dl,']'
                 call     pr_char
                 mov      dh,21
                 mov      dl,02
                 call     at
                 ret
        attrib      endp
        ;
        ; Setta la pausa alla 20a riga
        ;
        set_righe   proc   near
                 mov      dh,22
                 mov      dl,1
                 call     at
                 lea      dx,premi
                 call     print
                 mov      ah,0
                 int      16H
                 cmp      al,27
                 jne      con
                 mov      stop,1
                 jmp      end_scroll





                                       336





        Linguaggio C per MS DOS - F. Bernardotti - 1987 Opus Free Soft





        con:
                 mov      dh,22
                 mov      dl,1
                 call     at
                 lea      dx,blank
                 call     print
                 mov      dh,21
                 mov      dl,2
                 call     at
        end_scroll:
                 ret
        set_righe   endp
        ;
        ; Stampa un carattere
        ;
        pr_char      proc   near
                 push    ax
                 push    bx
                 mov     bl,7
                 mov     ah,14
                 mov     al,dl
                 int     10H
                 pop     bx
                 pop     ax
                 ret
        pr_char      endp
        ;
        ; Esegue lo scroll di una riga
        ;
        clear_one   proc   near
                 mov     al,1
                 mov     ah,6
                 mov     ch,2
                 mov     cl,2
                 mov     dh,21
                 mov     dl,32
                 mov     bh,7
                 int     10H
                 ret
        clear_one   endp
        ;
        ; Cerca scheda video e setta buffer relativo
        ;
        screenproc   proc   near
                 push    es
                 mov     ax,40H
                 mov     es,ax
                 mov     al,es:[10H]
                 and     al,00110000b
                 cmp     al,48
                 je      mono
                 mov     cs:screen,0B800H


                                       337





        Linguaggio C per MS DOS - F. Bernardotti - 1987 Opus Free Soft





                 jmp      end_screen
        mono:
                 mov      cs:screen,0B000H
        end_screen:
                 pop      es
                 ret
        screenproc   endp
        ;
        ; Legge memoria video per poterla salvare alla fine
        ;
        leggi      proc   near
                 mov      ax,cs:screen
                 mov      ds,ax
                 mov      si,0000H
                 push     cs
                 pop      es
                 mov      di,OFFSET buffer
                 mov      cx,2000
                 cld
                 rep      movsw
                 ret
        leggi      endp
        ;
        ; Salva la posizione e il tipo di cursore
        ;
        save_cur   proc   near
                 mov      bh,0
                 mov      ah,3
                 int      10H
                 mov      cs:cur_pos_x,dl
                 mov      cs:cur_pos_y,dh
                 mov      cs:cur_type_ch,ch
                 mov      cs:cur_type_cl,cl
                 mov      ah,1
                 mov      ch,13H
                 mov      cl,13H
                 int      10H
                 ret
        save_cur   endp
        ;
        ; Riscrive la schermata originale
        ;
        scrivi      proc   near
                 push     es
                 push     cs
                 pop      ds
                 mov      si,OFFSET   buffer
                 mov      ax,cs:screen
                 mov      es,ax
                 mov      di,0000H
                 mov      cx,2000



                                       338





        Linguaggio C per MS DOS - F. Bernardotti - 1987 Opus Free Soft





                 cld
                 rep      movsw
                 pop      es
                 ret
        scrivi      endp
        ;
        ; Ripristina posizione e tipo cursore fine programma residente
        ;
        restore_cur   proc   near
                 mov      dh,cs:cur_pos_y
                 mov      dl,cs:cur_pos_x
                 call     at
                 mov      ah,1
                 mov      ch,cs:cur_type_ch
                 mov      cl,cs:cur_type_cl
                 int      10H
                 ret
        restore_cur   endp
        ;
        ; Stampa le stringhe 
        ;
        print      proc   near
                 push     cs
                 pop      ds
                 mov      bl,112
                 mov      si,dx
        p_1:
                 mov      al,[si]
                 cmp      al,0
                 je       end_p
                 mov      ah,0EH
                 int      10H
                 inc      si
                 jmp      p_1
        end_p:
                 ret
        print      endp
        ;
        ; Cancella zona video per finestra
        ;
        clear      proc   near
                 mov      al,0
                 mov      ah,7
                 mov      ch,0
                 mov      cl,0
                 mov      dh,22
                 mov      dl,33
                 mov      bh,7
                 int      10H
                 ret
        clear      endp



                                       339





        Linguaggio C per MS DOS - F. Bernardotti - 1987 Opus Free Soft





        ;
        ; Posiziona il cursore
        ;
        at         proc   near
                 mov      ah,2
                 mov      bh,0
                 int      10H
                 ret
        at         endp
        ;
        ; Setta DTA
        ;
        set_dta      proc   near
                 mov      ah,47
                 int      21H
                 mov      old_dta,bx
                 mov      old_dta[2],es
                 mov      ah,26
                 push     cs
                 pop      ds
                 lea      dx,dta
                 int      21H
                 ret
        set_dta      endp
        ;
        ; Risetta il vecchio DTA
        ;
        re_set_dta   proc   near
                 push     ds
                 mov      dx,cs:old_dta
                 mov      ax,cs:old_dta[2]
                 mov      ds,ax
                 mov      ah,26
                 int      21H
                 pop      ds
                 ret
        re_set_dta   endp
        ;
        ; Salva corrente PSP e setta quello dell'utility
        ;
        set_psp      proc   near
                 mov      ah,98
                 int      21H
                 mov      WORD PTR cs:old_psp,bx
                 mov      bx,WORD PTR cs:this_psp
                 mov      ah,80
                 int      21H
                 ret
        set_psp      endp





                                       340





        Linguaggio C per MS DOS - F. Bernardotti - 1987 Opus Free Soft




        ;
        ; Rinstalla PSP del programma originale
        ;
        re_set_psp   proc   near
                 mov      ah,80
                 mov      bx,WORD PTR cs:old_psp
                 int      21H
                 ret
        re_set_psp   endp
        ;
        ;----------------------------------------------------------------------
        ; PARTE NON RESIDENTE
        ;----------------------------------------------------------------------
        ;

        ;
        ; Salva e installa vettori interrupts
        ;
        init:
                 push     cs
                 pop      ds
        ;
        ; Controlla se gia' installato SD
        ;
                 mov      ax,request
                 int      16H
                 cmp      ax,respond
                 jne      no_in
                 lea      dx,gia_in
                 mov      ah,9
                 int      21H
                 mov      ax,4C00H
                 int      21H
        no_in:
        ;
        ; Salva vettore interrupt 16H
        ;
                 mov      ah,35H
                 mov      al,16H
                 int      21H
                 mov      old_int_16,bx
                 mov      old_int_16[2],es
        ;
        ; Setta nuovo vettore interrupt 16H
        ;
                 mov      ah,25H
                 mov      al,16H
                 lea      dx,new_int_16
                 int      21H






                                       341





        Linguaggio C per MS DOS - F. Bernardotti - 1987 Opus Free Soft




        ;
        ; Salva indirizzo PSP
        ;
                 mov      ah,98
                 int      21H
                 mov      cs:this_psp,bx
        ;
        ; Stampa la maschera
        ;
                 lea      dx,m_1
                 mov      ah,09H
                 int      21H
        ;
        ; Termina e rimani residente
        ;
                 mov      dx,OFFSET init + 100H
                 int      27H
        ;
        ; Maschera
        ;
        gia_in         db      10,13
                 db      'RESIDENT SHOW DIR Ver. 2.1'
                 db      10,10,13
                 db      'ERR : Show Dir installata'
                 db      10,13
                 db      '    : <Ctrl F1> per attivarla'
                 db      10,13
                 db      '$'
        m_1         db      10,10,13
                 db      '+---------------------------------+'
                 db      10,13
                 db      ':  RESIDENT  SHOW  DIR  Ver. 2.1  :'
                 db      10,13
                 db      '+---------------------------------+'
                 db      10,13
                 db      ':     Writen by  F.Bernardotti    :'
                 db      10,13
                 db      ':  Opus 33/3  Tel. 0131-35.55.06  :'
                 db      10,13
                 db      ':  Premi <Ctrl-F1> per  attivare  :'
                 db      10,13
                 db      '+---------------------------------+'
                 db      10,10,13
                 db      '$'
        code      ends
                 end    showdir



        Voglio  a questo punto,  prima di terminare,   riportare un breve 
        riassunto  di  tutti  i consigli per la  scrittura  di  programmi 
        residenti.



                                       342





        Linguaggio C per MS DOS - F. Bernardotti - 1987 Opus Free Soft





        * Testate che la routine non sia gia' stata installata.
        * Se  eseguite call al Dos collegate una routine all'interrupt 8H 
          che   testi   lo   stato   dell'active   byte   e   che   setti 
          in  modo  opportuno un flag che testerete prima della  call  al 
          Dos.
        * Settate   un  flag anche per indicare che la  routine  e'  gia' 
          attiva in modo che non possa essere richiamata.
        * Disattivate  il ctrl break agendo sulla tavola dei  vettori  di 
          interrupt.
        * Minimizzate l'uso dello stack.
        * Salvate  prima dell'attivazione tutto quello che  modificherete 
          durante l'esecuzione.
        * Ridirigete PSP e DTA se e' necessario.
        * Preferite  in ogni caso le chiamate al Bios al posto di  quelle 
          al Dos.  

        Per ora,  a causa della mia prossima partenza per la seconda fase 
        delle ferie estive, concludo il tutto.
        A  settembre  rilasciero'  un update  con  la  continuazione  sui 
        programmi  residenti  in memoria e con le funzioni  aggiunte  del 
        Dos 3.3.
        Per  tale periodo,  tra gli esempi,  riportero' una  routine  che 
        permette  di  far  diventare residente un  programma  scritto  in 
        linguaggio C.
        Non  ho avuto il tempo di rileggere il tutto,  o meglio di  farlo 
        rileggere  a mia moglie,  alla ricerca di eventuali erroracci  di 
        grammatica.
        Purtroppo questa non e' il mio forte.
        Spero  che non ci facciate molto caso e che capiate il fatto  che 
        mia  moglie,  se l'avessi costretta a rileggere circa 350 pagine, 
        mi avrebbe eleminato fisicamente.
        Ho  cercato in questo testo di trattare andando alla  ricerca  di 
        materiale un po' tutti gli aspetti del sistema Ms Dos.
        Spero che in qualche caso potra' risultarvi utile.
        Una eventuale collaborazione da parte vostra sara' gradita.
        Sperando  che non consideriate sciupate le 350 pagine  utilizzate 
        per stampare il file vi auguro


                                           Buon intrafficamento !!!!  














                                       343


